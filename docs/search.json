[
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "Data Sources",
    "section": "",
    "text": "This page lists the datasets used in the blog.\n\nBlog Post #1: Lineup Protection\nüìÑ Download statcast_data.csv\n\n\nBlog Post #2: Swing Profiles\nüìÑ Download statcast_data.csv"
  },
  {
    "objectID": "posts/blog-4-quantitative-analysis-of-protection/index.html#introduction",
    "href": "posts/blog-4-quantitative-analysis-of-protection/index.html#introduction",
    "title": "Blog Post #4: Quantitative Analysis of Protection",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "posts/blog-4-quantitative-analysis-of-protection/index.html#aim",
    "href": "posts/blog-4-quantitative-analysis-of-protection/index.html#aim",
    "title": "Blog Post #4: Quantitative Analysis of Protection",
    "section": "Aim",
    "text": "Aim"
  },
  {
    "objectID": "posts/blog-4-quantitative-analysis-of-protection/index.html#setup",
    "href": "posts/blog-4-quantitative-analysis-of-protection/index.html#setup",
    "title": "Blog Post #4: Quantitative Analysis of Protection",
    "section": "Setup",
    "text": "Setup"
  },
  {
    "objectID": "posts/blog-4-quantitative-analysis-of-protection/index.html#methods",
    "href": "posts/blog-4-quantitative-analysis-of-protection/index.html#methods",
    "title": "Blog Post #4: Quantitative Analysis of Protection",
    "section": "Methods",
    "text": "Methods\n\n\nShow Code\n# 1. Get the data used in the model (complete cases only)\nmodel_data &lt;- model.frame(m_protection_final)\n\n# 2. Add row index to identify the rows kept\nmodel_data_indexed &lt;- model_data %&gt;%\n  mutate(row_id = row_number())\n\n# 3. Add row ID to pa_filtered\npa_filtered_indexed &lt;- pa_filtered %&gt;%\n  mutate(row_id = row_number())\n\n# 4. Inner join to bring back the full columns for the model-kept rows\npa_with_model_preds &lt;- pa_filtered_indexed %&gt;%\n  semi_join(model_data_indexed, by = c(\"pa_xwOBA\", \"batter_xwOBA\", \"next_batter_xwOBA\",\n                                       \"current_matchup_advantage\", \"baserunner_state\",\n                                       \"outs_when_up\", \"pitcher_year\")) %&gt;%\n  mutate(model_xwOBA = predict(m_protection_final, newdata = ., re.form = NA))\n\n# Summarize to get player-year averages\nbatter_year_model_preds &lt;- pa_with_model_preds %&gt;%\n  group_by(batter, game_year) %&gt;%\n  summarize(\n    model_based_xwOBA = mean(model_xwOBA, na.rm = TRUE),\n    plate_appearances = n(),\n    .groups = \"drop\"\n  )\n\n\n\n\nShow Code\nbatter_stats_all = batter_stats_all %&gt;%\n  mutate(batter_id = factor(batter_id), game_year = factor(game_year))\n\nbatter_comparison &lt;- batter_year_model_preds %&gt;%\n  left_join(\n    batter_stats_all,\n    by = c(\"batter\" = \"batter_id\", \"game_year\")\n  ) %&gt;%\n  filter(plate_appearances &gt;= 200) %&gt;%\n  mutate(xwOBA_diff = model_based_xwOBA - batter_xwOBA)"
  },
  {
    "objectID": "posts/blog-4-quantitative-analysis-of-protection/index.html#analysis",
    "href": "posts/blog-4-quantitative-analysis-of-protection/index.html#analysis",
    "title": "Blog Post #4: Quantitative Analysis of Protection",
    "section": "Analysis",
    "text": "Analysis\n\n\nShow Code\nlibrary(gt)\n\n# Top 10 by raw xwOBA\ntop10_raw &lt;- batter_comparison %&gt;%\n  filter(game_year == 2024) %&gt;%\n  arrange(desc(batter_xwOBA)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  select(batter_raw = batter, raw_xwOBA = batter_xwOBA)\n\n# Top 10 by model-based xwOBA\ntop10_model &lt;- batter_comparison %&gt;%\n  filter(game_year == 2024) %&gt;%\n  arrange(desc(model_based_xwOBA)) %&gt;%\n  slice_head(n = 10) %&gt;%\n  select(batter_model = batter, model_xwOBA = model_based_xwOBA)\n\n# Combine side by side\ntop10_side_by_side &lt;- bind_cols(top10_raw, top10_model)\n\n# Format nicely with gt\ntop10_side_by_side %&gt;%\n  gt() %&gt;%\n  tab_header(title = \"Top 10 Hitters in 2024: Raw vs Model-Based xwOBA\") %&gt;%\n  cols_label(\n    batter_raw = \"Player ID (Raw xwOBA)\",\n    raw_xwOBA = \"Raw xwOBA\",\n    batter_model = \"Player ID (Model xwOBA)\",\n    model_xwOBA = \"Model xwOBA\"\n  ) %&gt;%\n  fmt_number(columns = c(raw_xwOBA, model_xwOBA), decimals = 3)\n\n\n\n\nShow Code\nggplot(batter_comparison, aes(x = batter_xwOBA, y = model_based_xwOBA)) +\n  geom_point(alpha = 0.5) +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\", color = \"red\") +\n  labs(\n    title = \"Raw xwOBA vs. Model-Based xwOBA by Batter-Year\",\n    x = \"Raw xwOBA\",\n    y = \"Model-Based xwOBA\"\n  ) +\n  theme_minimal()"
  },
  {
    "objectID": "posts/blog-4-quantitative-analysis-of-protection/index.html#visualizations",
    "href": "posts/blog-4-quantitative-analysis-of-protection/index.html#visualizations",
    "title": "Blog Post #4: Quantitative Analysis of Protection",
    "section": "Visualizations",
    "text": "Visualizations"
  },
  {
    "objectID": "posts/blog-4-quantitative-analysis-of-protection/index.html#discussion",
    "href": "posts/blog-4-quantitative-analysis-of-protection/index.html#discussion",
    "title": "Blog Post #4: Quantitative Analysis of Protection",
    "section": "Discussion",
    "text": "Discussion"
  },
  {
    "objectID": "posts/blog-4-quantitative-analysis-of-protection/index.html#references",
    "href": "posts/blog-4-quantitative-analysis-of-protection/index.html#references",
    "title": "Blog Post #4: Quantitative Analysis of Protection",
    "section": "References",
    "text": "References"
  },
  {
    "objectID": "posts/blog-3-baserunning/index.html",
    "href": "posts/blog-3-baserunning/index.html",
    "title": "Blog Post #3: Baserunning",
    "section": "",
    "text": "As Statcast expands the data they are able to collect and parse through, one big innovation is the creation of ‚ÄúBaserunning Runs,‚Äù which aims to estimate the number of runs a player is creating through baserunning alone. Statcast defines it as follows:\n‚ÄúA Statcast metric designed to express the overall value of a baserunner, measured in runs created (or lost) via stealing bases and taking extra bases on the basepaths. Each steal opportunity is assigned a probability of being successful or not, based on the pitcher and catcher the basestealer is running against. Each successful or failed steal attempt is assigned a run value, with a stolen base or advance via a balk worth +0.2 runs for the baserunner and a caught stealing or pickoff worth -0.45 runs. For non-steal baserunning plays, an estimated success probability is generated for each opportunity using inputs that include runner speed, outfielder throwing arm, runner position on the basepaths and outfielder distance from both the ball and the bases. That can be translated to a run value based on whether the runner successfully takes the extra base, is thrown out or does not attempt to advance (holds).‚Äù (MLB, 2025)\nA player‚Äôs speed is only as useful as they make it, so lineup construction analysis, which often references the need for speed at the top and bottom of the order, would benefit from using this advanced data. Managers no longer have to use sprint speed to proxy a player‚Äôs value on the basepaths, they can use a player‚Äôs true baserunning value.\nIt is worth noting that the MLB opted for bigger bases in 2023 to increase action on the basepaths. This means that although Statcast has baserunning data going back to 2016, we will focus on just the 2023 and 2024 seasons to make our analysis more applicable to future seasons.\n\n\n\nThis article aims to answer a couple of questions about the role baserunning has in lineup construction. We‚Äôd like to answer the following research questions, which focus on distinct parts of baserunner effects within the game:\n\nDoes having a perceived (and measured) speed threat on base lead to measurable changes in pitch selection or velocity, and does that in turn correlate with better offensive outcomes?\nWhat is the optimal positioning of baserunning value within a lineup? Is it better to cluster speedy players consecutively (for multiple stolen bases or first-to-third attempts in an inning) or to spread them out to maximize the impact in different segments of the lineup?\nSince 2023, how well have managers optimized their team‚Äôs speed in their lineups?\n\n\n\n\nTo answer Question #1, we will need two datasets: Statcast pitch-by-pitch data for all of 2023/2024 and Statcast Baserunning data for the same seasons.\n\n\n\nFor full methods and model outputs view the full appendix here.\n\n\n\nTo do models on pitcher behavior, we will need a new statcast dataframe that incorporates the baserunning data. We will create a new dataframe, statcast_data_baserunning, that contains the same columns as statcast_data but with the addition of the pa_runner_average_value column.\n\n\nOur first model will be a mixed-effects model studying how fast pitchers throw with different on-base variations.\n\n\nShow Code\nstatcast_data_baserunning = readRDS(\"data/statcast_data_baserunning.rds\")\n\n\n\n\nShow Code\nmodel_vel &lt;- lmer(\n  release_speed ~ first_base_runner_value + second_base_runner_value + third_base_runner_value + run_diff + outs_when_up + baserunner_state + factor(balls) + factor(strikes) +\n    (1 | pitcher),\n  data = statcast_data_baserunning\n)\nsummary(model_vel)\n\n\n\n\n\nOur next model will be a mixed-effects model studying how pitchers locate with different on-base variations.\n\n\nShow Code\nmodel_location &lt;- lmer(\n  plate_z ~ first_base_runner_value + second_base_runner_value + third_base_runner_value + run_diff + outs_when_up + baserunner_state + factor(balls) + factor(strikes) +\n    (1 | pitcher),\n  data = statcast_data_baserunning\n)\nsummary(model_location)\n\n\n\n\n\nIf you want to see whether pitchers throw more fastballs with speed on base, we can define a binary:\n\n\nShow Code\nstatcast_data_baserunning &lt;- statcast_data_baserunning %&gt;%\n  mutate(\n    is_fastball = if_else(\n      pitch_type %in% c(\"FF\",\"FA\",\"FT\",\"SI\",\"FC\"), 1, 0\n    )\n  )\n)\n\n# Fit logistic mixed model\nmodel_pitch_select &lt;- glmer(\n  is_fastball ~ first_base_runner_value + second_base_runner_value + third_base_runner_value + run_diff + outs_when_up + baserunner_state + factor(balls) + factor(strikes) +\n    (1 | pitcher), \n  data = statcast_data_baserunning,\n  family = binomial(link = \"logit\")\n)\nsummary(model_pitch_select)\n\n\n\n\n\n\nNext, we need to get PA-level data to analyze the impact of speed on base on offensive performance. Now that we have the speed on base for each pitch, we can aggregate this to the PA level to get the total speed on base for each PA.\n\n\nShow Code\nm_speed = lmer(pa_xwOBA ~ batter_xwOBA + pa_runner_average_value + (1 | pitcher),\n             data = pa_data_final)\n\nsummary(m_speed)\n\nm_speed &lt;- lmer(\n  pa_xwOBA ~ batter_xwOBA + next_batter_xwOBA + \n    batter_handedness + potential_next_batter_handedness +\n    outs_when_up + run_diff + baserunner_state * first_base_runner_value + baserunner_state * second_base_runner_value + baserunner_state * third_base_runner_value +\n    (1 | pitcher),\n  data = pa_data_final\n)\n\nsummary(m_speed)\n\n\n\n\n\nINSERT VISUALIZATIONS\n\n\n\nINSERT DISCUSSION\n\n\n\nINSERT REFERENCES"
  },
  {
    "objectID": "posts/blog-3-baserunning/index.html#introduction-to-baserunning",
    "href": "posts/blog-3-baserunning/index.html#introduction-to-baserunning",
    "title": "Blog Post #3: Baserunning",
    "section": "",
    "text": "As Statcast expands the data they are able to collect and parse through, one big innovation is the creation of ‚ÄúBaserunning Runs,‚Äù which aims to estimate the number of runs a player is creating through baserunning alone. Statcast defines it as follows:\n‚ÄúA Statcast metric designed to express the overall value of a baserunner, measured in runs created (or lost) via stealing bases and taking extra bases on the basepaths. Each steal opportunity is assigned a probability of being successful or not, based on the pitcher and catcher the basestealer is running against. Each successful or failed steal attempt is assigned a run value, with a stolen base or advance via a balk worth +0.2 runs for the baserunner and a caught stealing or pickoff worth -0.45 runs. For non-steal baserunning plays, an estimated success probability is generated for each opportunity using inputs that include runner speed, outfielder throwing arm, runner position on the basepaths and outfielder distance from both the ball and the bases. That can be translated to a run value based on whether the runner successfully takes the extra base, is thrown out or does not attempt to advance (holds).‚Äù (MLB, 2025)\nA player‚Äôs speed is only as useful as they make it, so lineup construction analysis, which often references the need for speed at the top and bottom of the order, would benefit from using this advanced data. Managers no longer have to use sprint speed to proxy a player‚Äôs value on the basepaths, they can use a player‚Äôs true baserunning value.\nIt is worth noting that the MLB opted for bigger bases in 2023 to increase action on the basepaths. This means that although Statcast has baserunning data going back to 2016, we will focus on just the 2023 and 2024 seasons to make our analysis more applicable to future seasons."
  },
  {
    "objectID": "posts/blog-3-baserunning/index.html#aim",
    "href": "posts/blog-3-baserunning/index.html#aim",
    "title": "Blog Post #3: Baserunning",
    "section": "",
    "text": "This article aims to answer a couple of questions about the role baserunning has in lineup construction. We‚Äôd like to answer the following research questions, which focus on distinct parts of baserunner effects within the game:\n\nDoes having a perceived (and measured) speed threat on base lead to measurable changes in pitch selection or velocity, and does that in turn correlate with better offensive outcomes?\nWhat is the optimal positioning of baserunning value within a lineup? Is it better to cluster speedy players consecutively (for multiple stolen bases or first-to-third attempts in an inning) or to spread them out to maximize the impact in different segments of the lineup?\nSince 2023, how well have managers optimized their team‚Äôs speed in their lineups?"
  },
  {
    "objectID": "posts/blog-3-baserunning/index.html#setup",
    "href": "posts/blog-3-baserunning/index.html#setup",
    "title": "Blog Post #3: Baserunning",
    "section": "",
    "text": "To answer Question #1, we will need two datasets: Statcast pitch-by-pitch data for all of 2023/2024 and Statcast Baserunning data for the same seasons."
  },
  {
    "objectID": "posts/blog-3-baserunning/index.html#methods",
    "href": "posts/blog-3-baserunning/index.html#methods",
    "title": "Blog Post #3: Baserunning",
    "section": "",
    "text": "For full methods and model outputs view the full appendix here."
  },
  {
    "objectID": "posts/blog-3-baserunning/index.html#model-1-pitcher-behavior",
    "href": "posts/blog-3-baserunning/index.html#model-1-pitcher-behavior",
    "title": "Blog Post #3: Baserunning",
    "section": "",
    "text": "To do models on pitcher behavior, we will need a new statcast dataframe that incorporates the baserunning data. We will create a new dataframe, statcast_data_baserunning, that contains the same columns as statcast_data but with the addition of the pa_runner_average_value column.\n\n\nOur first model will be a mixed-effects model studying how fast pitchers throw with different on-base variations.\n\n\nShow Code\nstatcast_data_baserunning = readRDS(\"data/statcast_data_baserunning.rds\")\n\n\n\n\nShow Code\nmodel_vel &lt;- lmer(\n  release_speed ~ first_base_runner_value + second_base_runner_value + third_base_runner_value + run_diff + outs_when_up + baserunner_state + factor(balls) + factor(strikes) +\n    (1 | pitcher),\n  data = statcast_data_baserunning\n)\nsummary(model_vel)\n\n\n\n\n\nOur next model will be a mixed-effects model studying how pitchers locate with different on-base variations.\n\n\nShow Code\nmodel_location &lt;- lmer(\n  plate_z ~ first_base_runner_value + second_base_runner_value + third_base_runner_value + run_diff + outs_when_up + baserunner_state + factor(balls) + factor(strikes) +\n    (1 | pitcher),\n  data = statcast_data_baserunning\n)\nsummary(model_location)\n\n\n\n\n\nIf you want to see whether pitchers throw more fastballs with speed on base, we can define a binary:\n\n\nShow Code\nstatcast_data_baserunning &lt;- statcast_data_baserunning %&gt;%\n  mutate(\n    is_fastball = if_else(\n      pitch_type %in% c(\"FF\",\"FA\",\"FT\",\"SI\",\"FC\"), 1, 0\n    )\n  )\n)\n\n# Fit logistic mixed model\nmodel_pitch_select &lt;- glmer(\n  is_fastball ~ first_base_runner_value + second_base_runner_value + third_base_runner_value + run_diff + outs_when_up + baserunner_state + factor(balls) + factor(strikes) +\n    (1 | pitcher), \n  data = statcast_data_baserunning,\n  family = binomial(link = \"logit\")\n)\nsummary(model_pitch_select)"
  },
  {
    "objectID": "posts/blog-3-baserunning/index.html#model-2-offensive-perfornance-with-speed-on-base-expand-on-these",
    "href": "posts/blog-3-baserunning/index.html#model-2-offensive-perfornance-with-speed-on-base-expand-on-these",
    "title": "Blog Post #3: Baserunning",
    "section": "",
    "text": "Next, we need to get PA-level data to analyze the impact of speed on base on offensive performance. Now that we have the speed on base for each pitch, we can aggregate this to the PA level to get the total speed on base for each PA.\n\n\nShow Code\nm_speed = lmer(pa_xwOBA ~ batter_xwOBA + pa_runner_average_value + (1 | pitcher),\n             data = pa_data_final)\n\nsummary(m_speed)\n\nm_speed &lt;- lmer(\n  pa_xwOBA ~ batter_xwOBA + next_batter_xwOBA + \n    batter_handedness + potential_next_batter_handedness +\n    outs_when_up + run_diff + baserunner_state * first_base_runner_value + baserunner_state * second_base_runner_value + baserunner_state * third_base_runner_value +\n    (1 | pitcher),\n  data = pa_data_final\n)\n\nsummary(m_speed)"
  },
  {
    "objectID": "posts/blog-3-baserunning/index.html#visualizations",
    "href": "posts/blog-3-baserunning/index.html#visualizations",
    "title": "Blog Post #3: Baserunning",
    "section": "",
    "text": "INSERT VISUALIZATIONS"
  },
  {
    "objectID": "posts/blog-3-baserunning/index.html#discussion",
    "href": "posts/blog-3-baserunning/index.html#discussion",
    "title": "Blog Post #3: Baserunning",
    "section": "",
    "text": "INSERT DISCUSSION"
  },
  {
    "objectID": "posts/blog-3-baserunning/index.html#references",
    "href": "posts/blog-3-baserunning/index.html#references",
    "title": "Blog Post #3: Baserunning",
    "section": "",
    "text": "INSERT REFERENCES"
  },
  {
    "objectID": "posts/blog-1-lineup-protection/index.html",
    "href": "posts/blog-1-lineup-protection/index.html",
    "title": "Blog Post #1: Lineup Protection or Lineup Penalty?",
    "section": "",
    "text": "The next batter‚Äôs xwOBA does have a small but significant impact on the current plate appearance‚Äôs xwOBA, and this effect is negative. A stronger on-deck hitter results in lower than expected outcomes for that plate appearance.\nSome of the league‚Äôs best pitchers perform better when a strong hitter is on deck, serving as an indication of mental aptitude or ability to elevate in high-leverage moments that makes them so successful. This suggests that lineup protection may not be a universal phenomenon and that individual pitchers may have different responses to it.\nWhile we see evidence pointing to fewer walks, more strikeouts, and fewer extra base hits with better next_batter_xwOBA, we cannot conclusively point to the next batter‚Äôs xwOBA as the cause of these effects.\nEven when controlling for batter skill, matchup effects, and game state, a higher next_batter_xwOBA is associated with a small but statistically significant decrease in the current batter‚Äôs expected batting average (xBA) for that plate appearance. If the next batter‚Äôs xwOBA goes up by 0.100, we estimate a ~-0.003 reduction in pa_xBA per plate appearance‚Äîover 500 plate appearances, that amounts to about 1.5 fewer hits compared to otherwise.\nWhen we select certain fixed effects, we find that the next batter‚Äôs xwOBA continue to have a small but significant impact on the current plate appearance‚Äôs xwOBA, and this effect is negative. A stronger on-deck hitter results in lower than expected outcomes for that plate appearance."
  },
  {
    "objectID": "posts/blog-1-lineup-protection/index.html#takeaways",
    "href": "posts/blog-1-lineup-protection/index.html#takeaways",
    "title": "Blog Post #1: Lineup Protection or Lineup Penalty?",
    "section": "",
    "text": "The next batter‚Äôs xwOBA does have a small but significant impact on the current plate appearance‚Äôs xwOBA, and this effect is negative. A stronger on-deck hitter results in lower than expected outcomes for that plate appearance.\nSome of the league‚Äôs best pitchers perform better when a strong hitter is on deck, serving as an indication of mental aptitude or ability to elevate in high-leverage moments that makes them so successful. This suggests that lineup protection may not be a universal phenomenon and that individual pitchers may have different responses to it.\nWhile we see evidence pointing to fewer walks, more strikeouts, and fewer extra base hits with better next_batter_xwOBA, we cannot conclusively point to the next batter‚Äôs xwOBA as the cause of these effects.\nEven when controlling for batter skill, matchup effects, and game state, a higher next_batter_xwOBA is associated with a small but statistically significant decrease in the current batter‚Äôs expected batting average (xBA) for that plate appearance. If the next batter‚Äôs xwOBA goes up by 0.100, we estimate a ~-0.003 reduction in pa_xBA per plate appearance‚Äîover 500 plate appearances, that amounts to about 1.5 fewer hits compared to otherwise.\nWhen we select certain fixed effects, we find that the next batter‚Äôs xwOBA continue to have a small but significant impact on the current plate appearance‚Äôs xwOBA, and this effect is negative. A stronger on-deck hitter results in lower than expected outcomes for that plate appearance."
  },
  {
    "objectID": "posts/blog-1-lineup-protection/index.html#introduction-to-lineup-protection",
    "href": "posts/blog-1-lineup-protection/index.html#introduction-to-lineup-protection",
    "title": "Blog Post #1: Lineup Protection or Lineup Penalty?",
    "section": "Introduction to Lineup Protection",
    "text": "Introduction to Lineup Protection\nBatting order optimization is a heavily studied aspect of baseball decision-making, where teams construct lineups to maximize run production. Most studies in this area assume that hitters in the lineup are independent of one another. However, the concept of lineup protection‚Äîthe idea that a hitter‚Äôs performance is influenced by the quality of the hitter after them‚Äîremains debated within the sabermetrics community, most often not believed in by it; it has not been supported by previous statistical studies. Although batting order decisions may offer only marginal advantages in expected runs, in an era where every competitive edge counts, even subtle effects like lineup protection deserve closer examination. The theory behind lineup protection is that a hitter with a good hitter behind them will be harder to pitch around because pitchers won‚Äôt want to face the guy after him either, particularly with more runners on base. Thus, walks would decrease, and that would mean more fastballs, strikes, and pitches over the plate, essentially increasing the probability for productive hitting, specifically extra-base hits (doubles, triples, and homeruns).\nThere are two main ways to study lineup protection:\nPitcher-Centric Analysis: Examining how pitchers alter their approach based on the quality next hitter. Previous research using 30 hitter pairs since the advent of Statcast suggested that protected hitters see an average of 0.25% more strikes compared to league average, and 0.07% more pitches down the middle of the zone. This would lead to 6 additional strikes and 2 additional pitches down the middle over a season. This study was extremely limited, however, and did not account for situations without protection, only used 30 pairs of hitters, and only compared the strike percentage a protected hitter received to the league average of that year, not to the strike percentage they had in other non-protected plate appearances. If lineup protection were to exist, teams should avoid wasting lineup protection on free swingers (putting free swingers before ‚Äúprotectors‚Äù) so that the protection is not wasted on hitters who would swing at a higher rate anyway (The Paraball Notes, 2024). Quantitatively, the hitter who bats behind you SHOULD impact the pitches you see, because the run expectancy of certain plays occurring (like walks) would change based on who the following batter is (Weinberg, 2013). Evidence of certain pairs often seems to point to the opposite, with a 2012 evaluation of players hitting after Andrew McCutchen, Ryan Braun, and Joey Votto showing no evidence that pitchers were pitching them differently based on the protection they had (Cameron, 2012).\nHall of Famer Miguel Cabrera attributed part of his power struggles early in the 2019 season to a lack of lineup protection, essentially calling out productive-yet-not-spectacular hitter behind him, Niko Goodrum, saying, ‚ÄúIn the past‚Ä¶ I got a big bat behind me. You see the way guys pitch me? that explains everything.‚Äù His manager responded by saying his statement was ‚Äúcrazy.‚Äù Data revealed that he wasn‚Äôt getting particularly fewer fastballs, strikes, or good pitches to hit in general, and that in his particular case, there wasn‚Äôt evidence for lineup protection (Stavenhagen, 2019).\nHitter Outcome Analysis: Investigating whether the quality of the next hitter influences the current hitter‚Äôs performance. Pre-Pitch F/X research found that pitchers who know that a good hitter is up next will ‚Äúpitch around‚Äù the current hitter, resulting in significantly more walks, and moderately more strikeouts. However, it found that when it comes to putting the ball in play, there was no significant impact (Tango, 2006). Much of the sabermetric community says that lineup protection is a myth, and that a player‚Äôs production is almost solely determined by their own skills; luck and random variation also play a small role (Ambrosino, 2011). A 2008 study found that with a small magnitude, the quality of the on-deck hitter negatively impacts the preceding hitter (Bradbury, 2008).\nHowever, a study in 2011 using Retrosheet play-by-play data from 2002-2009 MLB seasons found that power numbers did have significant differences in situations of potential lineup protection. This study argues that previous evidence of lineup protection was not uncovered because endogeneity bias introduced by managers selectively choosing their lineups. For a player‚Äôs own performance, they likely are hitting better than their own season averages when they are near the top of the lineup (they have more protection) because they are already doing well at that time for a number of reasons. A good hitter who, for whatever reason, is hitting poorly will be put at the bottom of the lineup (and have less protection), but likely hit well at that spot, and thus, we would observe better hitting with less protection. Thus, protection and performance numbers become tangled in unobservable ways. While these endogeneity issues are a concern, they seem to work in both directions, and with a robust enough dataset, we should be able to see the effects of lineup protection, if it is a real phenomenon.\nUsing injuries to a batter‚Äôs ‚Äúprotector‚Äù as a quasi-random natural experiment, this study finds that batters who have stronger protection (i.e., a higher OPS hitter behind them) produce significantly more power. Specifically, a 100-point increase in the protector‚Äôs OPS correlates with a 9.7% rise in extra-base hits, and the effect is especially pronounced for third hitters (a 26% increase). The results also suggest that when left unprotected, batters draw more walks‚Äîparticularly intentional walks, as previous literature has supported (Phillips, 2011). It also found that hits in general remained unchanged with protection or not, suggesting that batters are not simply putting the ball into play fewer times, but having less powerful, and thus, productive, contact. However, this study simply made claims about the distribution of outcomes and not about overall offensive production. Protected hitters got fewer walks and more extra-base hits, which act in opposing manners. Our study will use Expected Weighted On-Base Average, an offensive statistic that correlates directly with a player‚Äôs overall contribution to run production from the plate, to tackle this gap in research.\nWe will also use a large sample size of over 3 million plate appearances from 2015-2024 to ensure that our results are robust.\nMost other previous literature of hitter outcome analysis has been rather anecdotal, focusing on specific players and how they fare with protection. Using over 3000 Plate Appearances from Pete Alonso‚Äôs career before his 2024 season, we can see higher slugging percentages with better hitters behind him, along with being 11% more likely to homer. With worse protection, he is more likely to walk, although his strikeout rates go against previous research and actually decrease with poor hitters behind him (Britton, 2024). Other research takes specific teams and analyzes whether the topic of lineup protection even applies and whether it serves a purpose in that roster‚Äôs decision-making. When the Diamondbacks acquired Mark Trumbo in 2014, writers brought up the fact that even though Trumbo‚Äôs power threat could serve to protect Paul Goldschmidt, Trumbo may not even be much better than other Diamondbacks hitters who could replace him in terms of offensive threat in general (Wiser, 2014). In 2015, Billy Hamilton pointed to a different sort of offensive advantage owing to the hitter behind him‚Äìknowing Joey Votto was hitting after him, an incredibly selective hitter often with long counts, allowed Hamilton to be patient and wait for the right pitch to steal on. In this situation, with a small sample size, the threat of Votto was preventing opposing pitchers from throwing fastballs with Hamilton on base, allowing Hamilton to get better base-stealing opportunities (Petriello, 2015).\nIt is worth noting that many within baseball discuss lineup protection with certainty. Alonso had pushed for J.D. Martinez to join and hit behind him for the Mets in 2024, hoping it would help his offensive statistics. Interviews with several within the game in 2015 resulted in a plethora of answers, from Joe Girardi saying lineup protection was most significant in lefty-righty matchups, Madison Bumgarner saying he doesn‚Äôt pay attention to the on-deck circle, Tim Hudson saying that it‚Äôs ‚Äúfoolish if you don‚Äôt look at the next hitter,‚Äù and multiple other pitchers saying it is a factor in their decision-making, especially later in the game (Laurila, 2016).\nIt is also worth noting that these anecdotal examinations are subject to sample size constraints and extremely limited in their ability to observe lineup protection on a large scale in Major League Baseball. This article aims to tackle that problem."
  },
  {
    "objectID": "posts/blog-1-lineup-protection/index.html#aim",
    "href": "posts/blog-1-lineup-protection/index.html#aim",
    "title": "Blog Post #1: Lineup Protection or Lineup Penalty?",
    "section": "Aim",
    "text": "Aim\nThis article aims to provide further insights into lineup protection using pitch-by-pitch data Statcast data from the 2015 to 2024 Major League Baseball seasons, focusing on analyzing hitter outcomes. While literature is mixed and often negative on the existence of lineup protection, it often uses anecdotal evidence, and a more thorough investigation is necessary, especially one using the more advanced expected statistics we now have available."
  },
  {
    "objectID": "posts/blog-1-lineup-protection/index.html#setup",
    "href": "posts/blog-1-lineup-protection/index.html#setup",
    "title": "Blog Post #1: Lineup Protection or Lineup Penalty?",
    "section": "Setup",
    "text": "Setup\nWe would like our independent variables to be the following:\n\nCurrent pitcher random effects\nCurrent hitter‚Äôs handedness and underlying quality (e.g.¬†xwOBA, xBA)\nNext hitter‚Äôs handedness and underlying quality (e.g.¬†xwOBA, xBA)\nBase-out state\nInning\nRun differential\n\nPrevious studies have looked at protection as a binary independent variable, but that is a narrow view on lineup protection. Lineup protection must be considered as a continuous variable because some players will protect more than others.\nOur outcome variable for our first model will be that plate appearance‚Äôs xwOBA, which will essentially give us the quality of that plate appearance based on the independent variables. We would then like to see what factor the quality of the next batter has in the outcome.\nWe will use a mixed-effects linear model to account for the random effects of pitchers and batters. Our models are described in detail below."
  },
  {
    "objectID": "posts/blog-1-lineup-protection/index.html#methods",
    "href": "posts/blog-1-lineup-protection/index.html#methods",
    "title": "Blog Post #1: Lineup Protection or Lineup Penalty?",
    "section": "Methods",
    "text": "Methods\nFor full methods and model outputs view the full appendix here."
  },
  {
    "objectID": "posts/blog-1-lineup-protection/index.html#model-1-mixed-effects-linear-model-of-plate-appearances",
    "href": "posts/blog-1-lineup-protection/index.html#model-1-mixed-effects-linear-model-of-plate-appearances",
    "title": "Blog Post #1: Lineup Protection or Lineup Penalty?",
    "section": "Model #1: Mixed Effects Linear Model of Plate Appearances",
    "text": "Model #1: Mixed Effects Linear Model of Plate Appearances\n\nI. Overall Offensive Value: wOBA and xWOBA\nFirst, let‚Äôs look at residuals from season-long averages for each plate appearance. We will read in our libraries and data.\n\n\nShow Code\nlibrary(lme4)\n\n\nLoading required package: Matrix\n\n\nShow Code\nlibrary(lmerTest)\n\n\n\nAttaching package: 'lmerTest'\n\n\nThe following object is masked from 'package:lme4':\n\n    lmer\n\n\nThe following object is masked from 'package:stats':\n\n    step\n\n\nShow Code\nlibrary(tidyverse)\n\n\n‚îÄ‚îÄ Attaching core tidyverse packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 2.0.0 ‚îÄ‚îÄ\n‚úî dplyr     1.1.4     ‚úî readr     2.1.5\n‚úî forcats   1.0.0     ‚úî stringr   1.5.1\n‚úî ggplot2   3.5.1     ‚úî tibble    3.2.1\n‚úî lubridate 1.9.4     ‚úî tidyr     1.3.1\n‚úî purrr     1.0.4     \n\n\n‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n‚úñ tidyr::expand() masks Matrix::expand()\n‚úñ dplyr::filter() masks stats::filter()\n‚úñ dplyr::lag()    masks stats::lag()\n‚úñ tidyr::pack()   masks Matrix::pack()\n‚úñ tidyr::unpack() masks Matrix::unpack()\n‚Ñπ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nShow Code\nlibrary(pubtheme)\n\n\nLoading required package: plotly\n\nAttaching package: 'plotly'\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\nThe following object is masked from 'package:stats':\n\n    filter\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\nLoading required package: scales\n\nAttaching package: 'scales'\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\nLoading required package: ggrepel\n\n\nShow Code\nlibrary(purrr)\n\npa_data_final = readRDS(\"data/pa_data_final.rds\")\n\n\nOur first model will be a mixed-effects linear model of plate appearances, where we will use the xwOBA of the current plate appearance as our outcome variable. We will use the xwOBA of the current and next batters as our main independent fixed effect, and we will also include the batter‚Äôs handedness matchup, the next batter‚Äôs handedness matchup, the baserunner state, outs when up, run differential, and game year as fixed effects. We will also include random effects for pitcher and batter. Note that the next batter‚Äôs handedness matchup is the handedness of the next batter with the handedness of the current pitcher, and thus does not account for potential anticipated calls to the bullpen (when a pitcher knows they are coming out after the current batter) or pinch-hitting situations.\n\n\nShow Code\nm_protection_1 &lt;- lmer(\n  pa_xwOBA ~ batter_xwOBA + next_batter_xwOBA + \n    current_matchup_advantage + next_matchup_advantage +\n    baserunner_state + outs_when_up + run_diff + game_year +\n    (1 | pitcher),\n  data = pa_data_final\n)\n\nsummary(m_protection_1)\n\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: \npa_xwOBA ~ batter_xwOBA + next_batter_xwOBA + current_matchup_advantage +  \n    next_matchup_advantage + baserunner_state + outs_when_up +  \n    run_diff + game_year + (1 | pitcher)\n   Data: pa_data_final\n\nREML criterion at convergence: 741757.7\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-1.3711 -0.7738 -0.3856  0.7186  4.7365 \n\nRandom effects:\n Groups   Name        Variance  Std.Dev.\n pitcher  (Intercept) 0.0005167 0.02273 \n Residual             0.1460217 0.38213 \nNumber of obs: 809909, groups:  pitcher, 2358\n\nFixed effects:\n                            Estimate Std. Error         df t value Pr(&gt;|t|)    \n(Intercept)               -6.786e-05  4.986e-03  4.402e+05  -0.014 0.989140    \nbatter_xwOBA               1.020e+00  1.128e-02  8.098e+05  90.401  &lt; 2e-16 ***\nnext_batter_xwOBA         -2.742e-02  1.170e-02  8.097e+05  -2.344 0.019074 *  \ncurrent_matchup_advantage  2.001e-02  9.017e-04  5.310e+05  22.191  &lt; 2e-16 ***\nnext_matchup_advantage     8.058e-04  9.045e-04  4.962e+05   0.891 0.372992    \nbaserunner_state1B         1.595e-03  1.147e-03  8.097e+05   1.390 0.164438    \nbaserunner_state1B-2B      1.960e-03  1.781e-03  8.098e+05   1.100 0.271155    \nbaserunner_state1B-3B      6.192e-03  2.639e-03  8.098e+05   2.346 0.018970 *  \nbaserunner_state2B         7.951e-03  1.612e-03  8.098e+05   4.933 8.10e-07 ***\nbaserunner_state2B-3B      3.182e-03  3.054e-03  8.098e+05   1.042 0.297390    \nbaserunner_state3B         4.995e-03  2.690e-03  8.097e+05   1.857 0.063292 .  \nbaserunner_stateLoaded     1.820e-03  2.937e-03  8.092e+05   0.620 0.535527    \nouts_when_up              -4.443e-03  5.360e-04  8.096e+05  -8.288  &lt; 2e-16 ***\nrun_diff                   6.541e-04  1.435e-04  5.644e+05   4.559 5.15e-06 ***\ngame_year2016              2.664e-03  1.800e-03  3.502e+05   1.480 0.138963    \ngame_year2017              3.513e-03  1.872e-03  2.067e+05   1.877 0.060501 .  \ngame_year2018              3.275e-03  1.904e-03  1.401e+05   1.721 0.085344 .  \ngame_year2019              7.899e-03  1.996e-03  1.154e+05   3.958 7.57e-05 ***\ngame_year2020              2.297e-03  3.233e-03  3.128e+05   0.710 0.477489    \ngame_year2021              6.133e-03  2.001e-03  6.650e+04   3.064 0.002183 ** \ngame_year2022              6.765e-03  2.009e-03  5.118e+04   3.367 0.000760 ***\ngame_year2023              7.512e-03  1.994e-03  3.849e+04   3.768 0.000165 ***\ngame_year2024              6.872e-03  2.039e-03  3.030e+04   3.371 0.000751 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\nCorrelation matrix not shown by default, as p = 23 &gt; 12.\nUse print(x, correlation=TRUE)  or\n    vcov(x)        if you need it\n\n\nOne piece of verifying evidence for our model is that the coefficient of batter_xwOBA is about 1 (it is 1.02), as we are predicting the xwOBA of a player‚Äôs plate appearance using their average xwOBA from the year. It is also verifying that our current_matchup_advantage is positive and signficant, with a coefficient of 0.02, indicating that the batter‚Äôs handedness matchup advantage does have a positive impact on the xwOBA of the current plate appearance.\nWhen accounting for all of the other variables, we can see that the coefficient of next_batter_xwOBA is negative, at -0.02742, and signficant at the \\(\\alpha\\) = 0.05 level, with a p-value of 0.02.\nThis coefficient means that with a 0.100 increase in the next batter‚Äôs xwOBA, we would expect a 0.0027 decrease in the current plate appearance‚Äôs xwOBA. This is a small effect, but it is statistically significant and suggests that a reverse lineup protection, or a lineup penalty does exist to some degree when a better hitter is on deck.\nWe do not find that a matchup advantage on deck has a significant impact on the current plate appearance‚Äôs xwOBA, with a coefficient of 0.0008 and a p-value of 0.37.\nWhile we will want to use model selection techniques to check if all of these variables are important, other signficant coefficients make sense. The only two baserunner_state with a singificant coefficient is when a runner is on 2B, with a positive coefficient of 0.008, or 1B and 3B, with a postivie coefficient of 0.006 indicating that having a runner on 2B or 1B-3B increases the xwOBA of the current plate appearance. The outs_when_up variable has a negative and signficiant coefficient, indicating that having more outs when up decreases the xwOBA of the current plate appearance. The run_diff variable has a positive and significant coefficient, indicating that having a larger run differential increases the xwOBA of the current plate appearance. This could indicate that when teams are up by a lot, they tend to be facing weaker pitchers, or have a confidence that helps them at the plate. Overall, this effect is incredibly small. game_year also makes sense, as the most signficant positive coefficeints in years 2019, 2021, 2022, 2023, and 2024 were all years with higher run scoring environments than the reference level of 2015.\nLet‚Äôs check this model with a mixed-effects linear model of plate appearances, where we will use the xwOBA difference of the current plate appearance from the batter‚Äôs season long average as the outcome variable. We will use the xwOBA of the next batter as our main independent variable, and we will also include the batter‚Äôs handedness, the next batter‚Äôs handedness, the baserunner state, outs when up, run differential, and game year as fixed effects. We will also include random effects for pitcher.\nIt is worth noting that initially we got a singularity with regards to the random effect (1 | batter) when it was included. This indicated that the model already had the effect of the batter baked into the model through the xwOBA_diff outcome variable, which is derived from pa_xwOBA and batter_xwOBA. So, we knew that almost all of the variance between batters can be accounted for by their season-long batter_xwOBA.\n\n\nShow Code\nm_protection_2 &lt;- lmer(\n  xwOBA_diff ~ next_batter_xwOBA + \n    current_matchup_advantage + next_matchup_advantage +\n    baserunner_state + outs_when_up + run_diff + game_year +\n    (1 | pitcher),\n  data = pa_data_final\n)\n\nsummary(m_protection_2)\n\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: xwOBA_diff ~ next_batter_xwOBA + current_matchup_advantage +  \n    next_matchup_advantage + baserunner_state + outs_when_up +  \n    run_diff + game_year + (1 | pitcher)\n   Data: pa_data_final\n\nREML criterion at convergence: 741753.7\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-1.3634 -0.7742 -0.3862  0.7195  4.7311 \n\nRandom effects:\n Groups   Name        Variance  Std.Dev.\n pitcher  (Intercept) 0.0005166 0.02273 \n Residual             0.1460221 0.38213 \nNumber of obs: 809909, groups:  pitcher, 2358\n\nFixed effects:\n                            Estimate Std. Error         df t value Pr(&gt;|t|)    \n(Intercept)                4.685e-03  4.192e-03  3.107e+05   1.118 0.263711    \nnext_batter_xwOBA         -2.224e-02  1.132e-02  8.099e+05  -1.964 0.049480 *  \ncurrent_matchup_advantage  1.995e-02  9.010e-04  5.317e+05  22.139  &lt; 2e-16 ***\nnext_matchup_advantage     7.917e-04  9.044e-04  4.965e+05   0.875 0.381370    \nbaserunner_state1B         1.633e-03  1.147e-03  8.097e+05   1.423 0.154655    \nbaserunner_state1B-2B      1.990e-03  1.781e-03  8.098e+05   1.117 0.263913    \nbaserunner_state1B-3B      6.218e-03  2.639e-03  8.098e+05   2.356 0.018474 *  \nbaserunner_state2B         7.969e-03  1.612e-03  8.098e+05   4.944 7.65e-07 ***\nbaserunner_state2B-3B      3.147e-03  3.054e-03  8.098e+05   1.031 0.302774    \nbaserunner_state3B         5.007e-03  2.690e-03  8.097e+05   1.862 0.062659 .  \nbaserunner_stateLoaded     1.806e-03  2.937e-03  8.092e+05   0.615 0.538656    \nouts_when_up              -4.439e-03  5.360e-04  8.096e+05  -8.281  &lt; 2e-16 ***\nrun_diff                   6.577e-04  1.435e-04  5.646e+05   4.584 4.56e-06 ***\ngame_year2016              2.747e-03  1.800e-03  3.498e+05   1.526 0.126944    \ngame_year2017              3.649e-03  1.870e-03  2.062e+05   1.951 0.051045 .  \ngame_year2018              3.350e-03  1.903e-03  1.399e+05   1.761 0.078324 .  \ngame_year2019              8.099e-03  1.992e-03  1.147e+05   4.065 4.81e-05 ***\ngame_year2020              2.576e-03  3.229e-03  3.116e+05   0.798 0.425082    \ngame_year2021              6.297e-03  1.999e-03  6.616e+04   3.150 0.001636 ** \ngame_year2022              6.727e-03  2.009e-03  5.118e+04   3.348 0.000814 ***\ngame_year2023              7.618e-03  1.993e-03  3.839e+04   3.823 0.000132 ***\ngame_year2024              6.869e-03  2.039e-03  3.030e+04   3.369 0.000755 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\nCorrelation matrix not shown by default, as p = 22 &gt; 12.\nUse print(x, correlation=TRUE)  or\n    vcov(x)        if you need it\n\n\nCoefficients of this model mirror those of the previous model in both signficance and direction, but our next_batter_xwOBA coefficient has decreased in magnitude to -0.02224, and is still signficant at the \\(\\alpha\\) = 0.05 level, with a p-value of 0.05. This further supports our evidence that the next batter‚Äôs xwOBA does have a small but significant impact on the current plate appearance‚Äôs xwOBA, and that this effect is negative.\nFor interpretability, we will go back to predicting pa_xwOBA in our next model, as it is a more intuitive metric to understand than the difference from the batter‚Äôs season-long average.\nTakeaway: The next batter‚Äôs xwOBA does have a small but significant impact on the current plate appearance‚Äôs xwOBA, and this effect is negative. A stronger on-deck hitter results in lower than expected outcomes for that plate appearance.\nIf we now want to incorporate how different hitters and pitchers are affected by the next batter, we can add a slope for the next batter‚Äôs xwOBA as a random effect. This will allow us to see how the effect of the next batter‚Äôs xwOBA varies by pitcher. We do not expect an equivalent effect with batters, as players describe how the pitcher will act differently based on the abilities of the next batter, not the batter. To make sure there is enough data to get a good estimate of the slope, we will only include pitchers with at least 100 plate appearances in our dataset for a given year. We will treat the slope and intercept independently, as we do not expect that pitchers who allow higher/lower overall xwOBA also respond differently to lineup protection.\n\n\nShow Code\n# Count number of plate appearances per pitcher per year\npitcher_counts &lt;- pa_data_final %&gt;%\n  group_by(pitcher, game_year) %&gt;%\n  summarize(n_pa = n(), .groups = \"drop\") %&gt;%\n  filter(n_pa &gt;= 100) \n\n# Filter dataset to just those pitchers\npa_filtered &lt;- pa_data_final %&gt;%\n  mutate(pitcher_year = interaction(pitcher, game_year)) %&gt;%\n  filter(pitcher_year %in% interaction(pitcher_counts$pitcher, pitcher_counts$game_year))\n\n\nLet‚Äôs run our model using pa_filtered.\n\n\nShow Code\nm_protection_slope &lt;- lmer(\n  pa_xwOBA ~ batter_xwOBA + next_batter_xwOBA +\n    current_matchup_advantage + next_matchup_advantage +\n    baserunner_state + outs_when_up + run_diff + game_year +\n    (1 + next_batter_xwOBA || pitcher_year),  # uncorrelated random effects\n  data = pa_filtered\n)\n\nsummary(m_protection_slope)\n\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: \npa_xwOBA ~ batter_xwOBA + next_batter_xwOBA + current_matchup_advantage +  \n    next_matchup_advantage + baserunner_state + outs_when_up +  \n    run_diff + game_year + (1 + next_batter_xwOBA || pitcher_year)\n   Data: pa_filtered\n\nREML criterion at convergence: 565997.2\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-1.3677 -0.7696 -0.3876  0.7057  4.7346 \n\nRandom effects:\n Groups         Name              Variance  Std.Dev.\n pitcher_year   (Intercept)       0.0003614 0.01901 \n pitcher_year.1 next_batter_xwOBA 0.0028632 0.05351 \n Residual                         0.1449113 0.38067 \nNumber of obs: 622199, groups:  pitcher_year, 2876\n\nFixed effects:\n                            Estimate Std. Error         df t value Pr(&gt;|t|)    \n(Intercept)               -4.600e-04  5.783e-03  6.510e+04  -0.080 0.936606    \nbatter_xwOBA               1.017e+00  1.283e-02  6.222e+05  79.288  &lt; 2e-16 ***\nnext_batter_xwOBA         -3.152e-02  1.336e-02  1.258e+05  -2.359 0.018346 *  \ncurrent_matchup_advantage  1.944e-02  1.018e-03  3.706e+05  19.093  &lt; 2e-16 ***\nnext_matchup_advantage     8.983e-04  1.019e-03  3.322e+05   0.881 0.378098    \nbaserunner_state1B         1.537e-03  1.304e-03  6.220e+05   1.179 0.238511    \nbaserunner_state1B-2B      9.683e-04  2.078e-03  6.222e+05   0.466 0.641151    \nbaserunner_state1B-3B      2.719e-03  3.080e-03  6.220e+05   0.883 0.377282    \nbaserunner_state2B         6.106e-03  1.843e-03  6.221e+05   3.314 0.000921 ***\nbaserunner_state2B-3B     -1.422e-03  3.559e-03  6.220e+05  -0.399 0.689560    \nbaserunner_state3B         7.113e-03  3.085e-03  6.220e+05   2.305 0.021151 *  \nbaserunner_stateLoaded    -2.722e-03  3.593e-03  6.219e+05  -0.758 0.448645    \nouts_when_up              -4.318e-03  6.092e-04  6.217e+05  -7.087 1.37e-12 ***\nrun_diff                   1.121e-04  1.837e-04  4.468e+05   0.610 0.541649    \ngame_year2016              9.108e-04  2.866e-03  2.200e+03   0.318 0.750657    \ngame_year2017             -1.016e-04  2.911e-03  2.327e+03  -0.035 0.972148    \ngame_year2018             -1.458e-03  2.931e-03  2.290e+03  -0.497 0.618886    \ngame_year2019              2.813e-03  3.100e-03  2.453e+03   0.907 0.364376    \ngame_year2020             -1.089e-02  1.486e-02  4.693e+03  -0.733 0.463727    \ngame_year2021              1.866e-03  3.026e-03  2.450e+03   0.617 0.537514    \ngame_year2022              1.698e-03  2.977e-03  2.303e+03   0.570 0.568543    \ngame_year2023              1.003e-03  2.887e-03  2.376e+03   0.348 0.728162    \ngame_year2024             -1.737e-03  2.937e-03  2.286e+03  -0.591 0.554288    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\nCorrelation matrix not shown by default, as p = 23 &gt; 12.\nUse print(x, correlation=TRUE)  or\n    vcov(x)        if you need it\n\n\nWhile the signficance of game_year coefficients have disappeared, the rest of the coefficients are similar to the previous model. The coefficient of next_batter_xwOBA is now -0.0315, and is signficant at the \\(\\alpha\\) = 0.05 level, with a p-value of 0.02.\n\nIA. Inspection of the Random Effects for xwOBA\nIn order to get an indication of whether these random slopes are important and not just a product of random noise, we can look at the random effects of the model. We can do this by looking at the random slopes for the next batter‚Äôs xwOBA for each pitcher-year combination.\n\n\nShow Code\n## Convert to a dataframe with rownames as a column\nre_df &lt;- ranef(m_protection_slope)$pitcher_year %&gt;%\n  as.data.frame() %&gt;%\n  rownames_to_column(var = \"pitcher_year\")\n\n## Separate into pitcher ID and year\nre_df &lt;- re_df %&gt;%\n  separate(pitcher_year, into = c(\"pitcher\", \"year\"), sep = \"\\\\.\", convert = TRUE)\n\n## Initialize a list to store correlation results\nyoy_results &lt;- list()\n\n## Loop through each year pair and calculate correlations\nyears &lt;- sort(unique(re_df$year))\n\nfor (i in 1:(length(years) - 1)) {\n  y1 &lt;- years[i]\n  y2 &lt;- years[i + 1]\n  \n  df_pair &lt;- re_df %&gt;%\n    filter(year %in% c(y1, y2)) %&gt;%\n    select(pitcher, year, next_batter_xwOBA) %&gt;%\n    pivot_wider(names_from = year, values_from = next_batter_xwOBA, names_prefix = \"xwOBA_\") %&gt;%\n    drop_na()\n  \n  cor_val &lt;- cor(df_pair[[paste0(\"xwOBA_\", y1)]], df_pair[[paste0(\"xwOBA_\", y2)]])\n  \n  yoy_results[[paste0(y1, \"_to_\", y2)]] &lt;- list(\n    from = y1,\n    to = y2,\n    correlation = cor_val,\n    n_shared_pitchers = nrow(df_pair)\n  )\n}\n\n## Print all year-over-year correlations\nyoy_df &lt;- bind_rows(yoy_results, .id = \"year_pair\")\nprint(yoy_df)\n\n\n# A tibble: 9 √ó 5\n  year_pair     from    to correlation n_shared_pitchers\n  &lt;chr&gt;        &lt;int&gt; &lt;int&gt;       &lt;dbl&gt;             &lt;int&gt;\n1 2015_to_2016  2015  2016       0.396               221\n2 2016_to_2017  2016  2017       0.374               220\n3 2017_to_2018  2017  2018       0.367               200\n4 2018_to_2019  2018  2019       0.377               185\n5 2019_to_2020  2019  2020       0.175                 9\n6 2020_to_2021  2020  2021       0.571                 9\n7 2021_to_2022  2021  2022       0.317               182\n8 2022_to_2023  2022  2023       0.328               191\n9 2023_to_2024  2023  2024       0.261               199\n\n\nAll of these Year-Over-Year correlations (with 2020 results ommitted due to limited sample size) are positive and greater than 0.3, except for 2019 to 2021 (still 0.25). This indicates that the random slopes for the next batter‚Äôs xwOBA are relatively stable over time, and that pitchers who are more affected by the next batter‚Äôs xwOBA in one year are likely to be similarly affected in the following year. This implies that the effect of the next batter‚Äôs xwOBA is not just a product of random noise, but rather a consistent pattern across pitchers.\nWe can graph the most recent year pair (2023 to 2024) to visualize the relationship between the random slopes for the next batter‚Äôs xwOBA in those two years.\n\n\nShow Code\n## Make a graph for the most recent year pair (2023 to 2024)\nre_23_24 &lt;- re_df %&gt;%\n  filter(year %in% c(2023, 2024)) %&gt;%\n  select(pitcher, year, next_batter_xwOBA) %&gt;%\n  pivot_wider(names_from = year, values_from = next_batter_xwOBA, names_prefix = \"xwOBA_\") %&gt;%\n  drop_na()\n\n## Plot\nggplot(re_23_24, aes(x = xwOBA_2023, y = xwOBA_2024)) +\n  geom_point(alpha = 0.6) +\n  geom_smooth(method = \"lm\", se = FALSE, color = \"blue\") +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\", color = \"red\") +\n  labs(\n    title = \"Pitcher Susceptibility to Lineup Protection (2023 vs. 2024)\",\n    subtitle = paste0(\"r = \", round(cor(re_23_24$xwOBA_2023, re_23_24$xwOBA_2024), 3)),\n    x = \"Random Slope on next_batter_xwOBA (2023)\",\n    y = \"Random Slope on next_batter_xwOBA (2024)\"\n  ) +\n  theme_pub()\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nNow that we know that these random slopes are stable over time, we will decide to keep them in our model going forward for interpretability.\nThis also means that studying indvidual pitcher‚Äôs susceptibility to lineup protection is a worthwhile endeavor. We can look at the top 10 and bottom 10 pitchers in terms of their random slope for the next batter‚Äôs xwOBA.\n\n\nShow Code\n## Get 2024 slopes\nslopes_2024 &lt;- re_df %&gt;%\n  filter(year == 2024) %&gt;%\n  select(pitcher, year, next_batter_xwOBA)\n\n## Get top and bottom 10\ntop_10 &lt;- slopes_2024 %&gt;% arrange(desc(next_batter_xwOBA)) %&gt;% slice(1:10)\nbottom_10 &lt;- slopes_2024 %&gt;% arrange(next_batter_xwOBA) %&gt;% slice(1:10)\n\n## Base URL of the data\nbase_url &lt;- \"https://raw.githubusercontent.com/chadwickbureau/register/master/data/\"\n\n## Create vector of suffixes for filenames\nsuffixes &lt;- c(0:9, letters[1:6])\nfile_urls &lt;- paste0(base_url, \"people-\", suffixes, \".csv\")\n\n## Read and combine all files safely, treating all columns as characters\npeople &lt;- map_dfr(file_urls, ~ read_csv(.x, col_types = cols(.default = \"c\")))\n\n## Clean and convert MLBAM ID for joining\npeople_clean &lt;- people %&gt;%\n  select(key_mlbam, name_first, name_last) %&gt;%\n  mutate(key_mlbam = as.integer(key_mlbam))\n\n## Join to top 10 and bottom 10 results\ntop_10 &lt;- top_10 %&gt;%\n  left_join(people_clean, by = c(\"pitcher\" = \"key_mlbam\")) %&gt;%\n  select(name_first, name_last, pitcher, next_batter_xwOBA)\n\nbottom_10 &lt;- bottom_10 %&gt;%\n  left_join(people_clean, by = c(\"pitcher\" = \"key_mlbam\")) %&gt;%\n  select(name_first, name_last, pitcher, next_batter_xwOBA)\n\n## Display\ntop_10\n\n\n   name_first name_last pitcher next_batter_xwOBA\n1     Roddery     Mu√±oz  682610        0.07649964\n2      Mart√≠n     P√©rez  527048        0.06512998\n3     Taijuan    Walker  592836        0.06485610\n4       Randy   V√°squez  681190        0.05401922\n5     Emerson   Hancock  676106        0.04734642\n6         Jon      Gray  592351        0.04470282\n7     Valente   Bellozo  678368        0.04205315\n8     Anthony    Molina  683627        0.04131252\n9       Kenta     Maeda  628317        0.04045721\n10       Kyle    Gibson  502043        0.03925565\n\n\nShow Code\nbottom_10\n\n\n   name_first name_last pitcher next_batter_xwOBA\n1       Tyler   Glasnow  607192       -0.06585163\n2       Mason    Miller  695243       -0.06031694\n3        Paul    Skenes  694973       -0.05088475\n4      Raisel  Iglesias  628452       -0.04973264\n5       Bryan       Woo  693433       -0.04841714\n6      Justin    Steele  657006       -0.04629680\n7         Joe   Jim√©nez  641729       -0.04529517\n8        Ryan    Walker  676254       -0.04428940\n9        Sean    Hjelle  663546       -0.04105592\n10     Carlos     Rod√≥n  607074       -0.04101263\n\n\nIn 2024, the random slopes on next_batter_xwOBA reveal how individual pitchers deviated from the average lineup protection effect‚Äîwhere the fixed effect of next_batter_xwOBA was negative, indicating that pitchers tend to allow lower expected outcomes when a strong hitter is looming. At the top of the slope distribution, pitchers like Roddery Mu√±oz, Mart√≠n P√©rez, and Randy V√°squez had positive random slopes, meaning the usual lineup protection suppression effect was less true for them‚Äîor even reversed. These pitchers were more susceptible to lineup protection (they allow better results when a stronger batter is on deck).\nIn contrast, pitchers like Tyler Glasnow, Paul Skenes, and Bryan Woo had even more negative slopes than average, suggesting they are especially effective at suppressing outcomes when a strong next batter is present. These pitchers were less affected (or may even pitch better) in those scenarios where a stronger batter is on deck.\nIt is worth noting that although some of the league‚Äôs best pitchers (like Glasnow and Skenes) are at the bottom of this list, this does not mean that these lists are simply a ranking of pitcher quality. The random slopes are not correlated with the fixed effect of next_batter_xwOBA, and thus, a pitcher can be very good and still have a high random slope. This is because the random slope is measuring how much the pitcher deviates from the average lineup protection effect, not how good they are overall.\nSo, when we see some of the leagues best pitchers at the bottom of this list, it means that one of their skills is to be able to pitch well regardless of the next batter‚Äôs quality, and potentially even better when there is a threat looming.\nTakeaway: Some of the league‚Äôs best pitchers perform better when a strong hitter is on deck, serving as an indication of mental aptitude or ability to elevate in high-leverage moments that makes them so successful. This suggests that lineup protection may not be a universal phenomenon and that individual pitchers may have different responses to it.\n\n\nIB. Drivers of the Overall Offensive Effect\nLet‚Äôs try to uncover where these overall offensive effects are coming from. Since is_walk, is_strikeout, and is_extra_base_hit are binary outcome variables (TRUE/FALSE), we‚Äôll want to use logistic regression models. We will use glm instead of glmer as models including failed to converge within a reasonable amount of time. First, we will look at walks.\n\n\nShow Code\nm_protection_walk &lt;- glm(\n  is_walk ~ batter_bb_pct + next_batter_xwOBA +\n    current_matchup_advantage + next_matchup_advantage +\n    baserunner_state + outs_when_up + run_diff + game_year,\n  data = pa_data_final,\n  family = binomial(link = \"logit\")\n)\nsummary(m_protection_walk)\n\n\n\nCall:\nglm(formula = is_walk ~ batter_bb_pct + next_batter_xwOBA + current_matchup_advantage + \n    next_matchup_advantage + baserunner_state + outs_when_up + \n    run_diff + game_year, family = binomial(link = \"logit\"), \n    data = pa_data_final)\n\nCoefficients:\n                           Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)               -3.604417   0.051621 -69.824  &lt; 2e-16 ***\nbatter_bb_pct             10.764657   0.147696  72.884  &lt; 2e-16 ***\nnext_batter_xwOBA         -0.180966   0.138735  -1.304  0.19210    \ncurrent_matchup_advantage  0.150153   0.010445  14.376  &lt; 2e-16 ***\nnext_matchup_advantage    -0.031530   0.010364  -3.042  0.00235 ** \nbaserunner_state1B        -0.106451   0.014102  -7.549 4.39e-14 ***\nbaserunner_state1B-2B     -0.011978   0.021270  -0.563  0.57332    \nbaserunner_state1B-3B     -0.140937   0.033013  -4.269 1.96e-05 ***\nbaserunner_state2B         0.398295   0.016610  23.979  &lt; 2e-16 ***\nbaserunner_state2B-3B      0.470568   0.030704  15.326  &lt; 2e-16 ***\nbaserunner_state3B         0.354781   0.027459  12.920  &lt; 2e-16 ***\nbaserunner_stateLoaded    -0.241287   0.038858  -6.209 5.32e-10 ***\nouts_when_up               0.089101   0.006316  14.106  &lt; 2e-16 ***\nrun_diff                   0.010447   0.001696   6.160 7.29e-10 ***\ngame_year2016              0.062527   0.020564   3.041  0.00236 ** \ngame_year2017             -0.030562   0.021438  -1.426  0.15399    \ngame_year2018             -0.016728   0.021364  -0.783  0.43362    \ngame_year2019              0.014724   0.022190   0.664  0.50697    \ngame_year2020              0.006981   0.032404   0.215  0.82942    \ngame_year2021              0.016040   0.021642   0.741  0.45860    \ngame_year2022              0.032436   0.021892   1.482  0.13844    \ngame_year2023              0.016310   0.021369   0.763  0.44532    \ngame_year2024             -0.006361   0.022114  -0.288  0.77362    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 300566  on 509603  degrees of freedom\nResidual deviance: 293300  on 509581  degrees of freedom\n  (309808 observations deleted due to missingness)\nAIC: 293346\n\nNumber of Fisher Scoring iterations: 5\n\n\nAs expected, batter_bb_pct and current_matchup_advantage both have positive and signficant coefficients in our walk model. m_protection_walk shows that the coefficient of next_batter_xwOBA is negative, but insignificant. This indicates that the next batter‚Äôs xwOBA does not have a significant impact on the current plate appearance‚Äôs walk rate. We can do the same for strikeouts:\n\n\nShow Code\nm_protection_strikeout &lt;- glm(\n  is_strikeout ~ batter_k_pct + next_batter_xwOBA +\n    current_matchup_advantage + next_matchup_advantage +\n    baserunner_state + outs_when_up + run_diff + game_year,\n  data = pa_data_final,\n  family = binomial(link = \"logit\")\n)\nsummary(m_protection_strikeout)\n\n\n\nCall:\nglm(formula = is_strikeout ~ batter_k_pct + next_batter_xwOBA + \n    current_matchup_advantage + next_matchup_advantage + baserunner_state + \n    outs_when_up + run_diff + game_year, family = binomial(link = \"logit\"), \n    data = pa_data_final)\n\nCoefficients:\n                            Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)               -2.7599069  0.0404130 -68.293  &lt; 2e-16 ***\nbatter_k_pct               6.2888199  0.0688935  91.283  &lt; 2e-16 ***\nnext_batter_xwOBA          0.1196696  0.0993374   1.205    0.228    \ncurrent_matchup_advantage -0.0688817  0.0073531  -9.368  &lt; 2e-16 ***\nnext_matchup_advantage    -0.0026393  0.0073570  -0.359    0.720    \nbaserunner_state1B        -0.1499402  0.0097384 -15.397  &lt; 2e-16 ***\nbaserunner_state1B-2B     -0.1076912  0.0150464  -7.157 8.23e-13 ***\nbaserunner_state1B-3B     -0.2957063  0.0235681 -12.547  &lt; 2e-16 ***\nbaserunner_state2B        -0.0984864  0.0134549  -7.320 2.48e-13 ***\nbaserunner_state2B-3B     -0.1337799  0.0261563  -5.115 3.14e-07 ***\nbaserunner_state3B        -0.1344568  0.0226108  -5.947 2.74e-09 ***\nbaserunner_stateLoaded    -0.1370497  0.0254082  -5.394 6.89e-08 ***\nouts_when_up               0.0605834  0.0044796  13.524  &lt; 2e-16 ***\nrun_diff                  -0.0137829  0.0012004 -11.482  &lt; 2e-16 ***\ngame_year2016             -0.0039130  0.0148857  -0.263    0.793    \ngame_year2017              0.0181779  0.0152747   1.190    0.234    \ngame_year2018              0.0179369  0.0152552   1.176    0.240    \ngame_year2019              0.0002611  0.0159714   0.016    0.987    \ngame_year2020              0.0149747  0.0236182   0.634    0.526    \ngame_year2021              0.0241461  0.0154535   1.563    0.118    \ngame_year2022              0.0124838  0.0155830   0.801    0.423    \ngame_year2023              0.0140535  0.0152468   0.922    0.357    \ngame_year2024              0.0224673  0.0154996   1.450    0.147    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 504132  on 509603  degrees of freedom\nResidual deviance: 494273  on 509581  degrees of freedom\n  (309808 observations deleted due to missingness)\nAIC: 494319\n\nNumber of Fisher Scoring iterations: 4\n\n\nThe coefficient of next_batter_xwOBA is positive, but insignificant again. This indicates that the next batter‚Äôs xwOBA does not have a significant impact on the current plate appearance‚Äôs strikeout rate.\nWe will also look at extra base hits:\n\n\nShow Code\nm_protection_extra_base_hit &lt;- glm(\n  is_extra_base_hit ~ batter_xbh_rate + next_batter_xwOBA +\n    current_matchup_advantage + next_matchup_advantage +\n    baserunner_state + outs_when_up + run_diff + game_year,\n  data = pa_data_final,\n  family = binomial(link = \"logit\")\n)\nsummary(m_protection_extra_base_hit)\n\n\n\nCall:\nglm(formula = is_extra_base_hit ~ batter_xbh_rate + next_batter_xwOBA + \n    current_matchup_advantage + next_matchup_advantage + baserunner_state + \n    outs_when_up + run_diff + game_year, family = binomial(link = \"logit\"), \n    data = pa_data_final)\n\nCoefficients:\n                           Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)               -3.441736   0.040563 -84.848  &lt; 2e-16 ***\nbatter_xbh_rate           13.057888   0.192080  67.981  &lt; 2e-16 ***\nnext_batter_xwOBA         -0.142683   0.108539  -1.315 0.188651    \ncurrent_matchup_advantage  0.135176   0.008168  16.549  &lt; 2e-16 ***\nnext_matchup_advantage    -0.006115   0.008136  -0.752 0.452340    \nbaserunner_state1B         0.017441   0.010602   1.645 0.099965 .  \nbaserunner_state1B-2B      0.006205   0.016541   0.375 0.707566    \nbaserunner_state1B-3B      0.019531   0.024393   0.801 0.423319    \nbaserunner_state2B        -0.097752   0.015498  -6.307 2.84e-10 ***\nbaserunner_state2B-3B     -0.101633   0.029553  -3.439 0.000584 ***\nbaserunner_state3B        -0.048229   0.025613  -1.883 0.059699 .  \nbaserunner_stateLoaded     0.088488   0.026673   3.318 0.000908 ***\nouts_when_up              -0.046111   0.005006  -9.211  &lt; 2e-16 ***\nrun_diff                   0.008150   0.001319   6.180 6.42e-10 ***\ngame_year2016              0.012814   0.016321   0.785 0.432382    \ngame_year2017             -0.010829   0.016705  -0.648 0.516839    \ngame_year2018             -0.005318   0.016873  -0.315 0.752632    \ngame_year2019             -0.007030   0.017236  -0.408 0.683384    \ngame_year2020             -0.011723   0.029103  -0.403 0.687089    \ngame_year2021              0.003950   0.017173   0.230 0.818058    \ngame_year2022              0.011099   0.017279   0.642 0.520644    \ngame_year2023              0.011634   0.016694   0.697 0.485843    \ngame_year2024              0.007072   0.017127   0.413 0.679678    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 477885  on 819411  degrees of freedom\nResidual deviance: 472591  on 819389  degrees of freedom\nAIC: 472637\n\nNumber of Fisher Scoring iterations: 5\n\n\nAgain, the coefficient of next_batter_xwOBA is negative, but insignificant.\nThese results suggest that the overall offensive effect attributed to lineup protection is not strongly driven by any single offensive outcome. While pitchers may slightly adjust their approach (especially walk likelihood) when facing a strong next batter or easier upcoming matchup, these adjustments do not translate significantly into changes in strikeout, walk, or extra-base hit rates.\nTakeaway: While we see evidence pointing to fewer walks, more strikeouts, and fewer extra base hits with better next_batter_xwOBA, we cannot conclusively point to the next batter‚Äôs xwOBA as the cause of these effects.\n\n\n\nII. Increased Interpretability: xBA\nIn order to increase interpretability, we will also look at the xBA of the current plate appearance. We will use the same model as above, but with pa_xBA as our outcome variable instead of pa_xwOBA. We will also use the xBA of the current batter as our main independent fixed effect, along with the next batter‚Äôs strength (as determined by xwOBA). We will also include the batter‚Äôs handedness matchup, the next batter‚Äôs handedness matchup, the baserunner state, outs when up, run differential, and game year as fixed effects. We will also include random effects for pitcher and batter.\n\n\nShow Code\npa_data_xba &lt;- pa_data_final %&gt;%\n  mutate(pa_xBA = ifelse(is.na(pa_xBA) & pa_xwOBA == 0, 0, pa_xBA)) %&gt;%\n  filter(!is.na(pa_xBA) & !is.na(batter_xBA) & !is.na(next_batter_xBA))\n\nm_protection_xBA &lt;- lmer(\n  pa_xBA ~ batter_xBA + next_batter_xwOBA + \n    current_matchup_advantage + next_matchup_advantage +\n    baserunner_state + outs_when_up + run_diff + game_year +\n    (1 | pitcher),\n  data = pa_data_xba\n)\n\nsummary(m_protection_xBA)\n\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: pa_xBA ~ batter_xBA + next_batter_xwOBA + current_matchup_advantage +  \n    next_matchup_advantage + baserunner_state + outs_when_up +  \n    run_diff + game_year + (1 | pitcher)\n   Data: pa_data_xba\n\nREML criterion at convergence: 276850\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-1.3726 -0.7915 -0.4387  0.6376  3.0151 \n\nRandom effects:\n Groups   Name        Variance  Std.Dev.\n pitcher  (Intercept) 0.0004604 0.02146 \n Residual             0.0851418 0.29179 \nNumber of obs: 734304, groups:  pitcher, 2347\n\nFixed effects:\n                            Estimate Std. Error         df t value Pr(&gt;|t|)    \n(Intercept)                1.295e-02  4.258e-03  4.365e+05   3.041 0.002361 ** \nbatter_xBA                 9.887e-01  1.317e-02  7.341e+05  75.094  &lt; 2e-16 ***\nnext_batter_xwOBA         -2.290e-02  9.388e-03  7.340e+05  -2.440 0.014706 *  \ncurrent_matchup_advantage  1.205e-02  7.253e-04  5.687e+05  16.610  &lt; 2e-16 ***\nnext_matchup_advantage     4.790e-04  7.274e-04  5.498e+05   0.658 0.510262    \nbaserunner_state1B         5.076e-03  9.161e-04  7.341e+05   5.541 3.01e-08 ***\nbaserunner_state1B-2B      3.190e-03  1.427e-03  7.343e+05   2.235 0.025400 *  \nbaserunner_state1B-3B      1.134e-02  2.107e-03  7.341e+05   5.381 7.41e-08 ***\nbaserunner_state2B        -1.126e-03  1.310e-03  7.341e+05  -0.859 0.390256    \nbaserunner_state2B-3B     -2.789e-03  2.483e-03  7.341e+05  -1.123 0.261369    \nbaserunner_state3B        -2.150e-03  2.193e-03  7.340e+05  -0.981 0.326733    \nbaserunner_stateLoaded     8.590e-03  2.346e-03  7.341e+05   3.662 0.000250 ***\nouts_when_up              -5.730e-03  4.299e-04  7.337e+05 -13.328  &lt; 2e-16 ***\nrun_diff                   4.217e-04  1.153e-04  5.680e+05   3.656 0.000256 ***\ngame_year2016              1.773e-03  1.445e-03  3.783e+05   1.227 0.219947    \ngame_year2017              2.521e-03  1.507e-03  2.408e+05   1.673 0.094291 .  \ngame_year2018              1.790e-03  1.537e-03  1.684e+05   1.165 0.244160    \ngame_year2019              4.417e-03  1.613e-03  1.400e+05   2.738 0.006173 ** \ngame_year2020             -1.605e-03  2.619e-03  3.436e+05  -0.613 0.539805    \ngame_year2021              3.210e-03  1.623e-03  8.141e+04   1.978 0.047935 *  \ngame_year2022              3.134e-03  1.635e-03  6.381e+04   1.917 0.055183 .  \ngame_year2023              4.666e-03  1.624e-03  4.763e+04   2.874 0.004054 ** \ngame_year2024              4.729e-03  1.664e-03  3.673e+04   2.841 0.004498 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\nCorrelation matrix not shown by default, as p = 23 &gt; 12.\nUse print(x, correlation=TRUE)  or\n    vcov(x)        if you need it\n\n\nThis model examines how a plate appearance‚Äôs batting average metric (pa_xBA) depends on the batter‚Äôs season-long average (batter_xBA), the following hitter‚Äôs season-long expected wOBA (next_batter_xwOBA), and various other contextual factors. The large positive coefficient on batter_xBA (~0.989) reaffirms that the best predictor of a single PA‚Äôs batting outcome is the batter‚Äôs own established average. Meanwhile, having a higher next_batter_xwOBA (coefficient ~-0.029) shows a small but statistically significant negative association, indicating the current hitter‚Äôs pa_xBA may drop a bit when a stronger hitter is on deck. Some baserunner states (e.g., runner on 1B, 1B-2B, or 1B-#B) slightly increase pa_xBA, others (like runner on 2B alone) decrease it, and having more outs also lowers pa_xBA.\nTakeaway: Even when controlling for batter skill, matchup effects, and game state, a higher next_batter_xwOBA is associated with a small but statistically significant decrease in the current batter‚Äôs expected batting average (xBA) for that plate appearance. If the next batter‚Äôs xwOBA goes up by 0.100, we estimate a ~-0.003 reduction in pa_xBA per plate appearance‚Äîover 500 plate appearances, that amounts to about 1.5 fewer hits compared to otherwise.\n\n\nIII. Model Selection of the Overall Offensive Output\nLet‚Äôs return to our m_protection_slope model and see if we can improve it with model selection. Using the drop1 function, which uses F-tests with Satterthwaite‚Äôs approximation for degrees of freedom to see what would happen to model fit if we removed each fixed effect one at a time, we get the following results.\n\n\nShow Code\ndrop1(m_protection_slope, test = \"Chisq\")\n\n\nSingle term deletions using Satterthwaite's method:\n\nModel:\npa_xwOBA ~ batter_xwOBA + next_batter_xwOBA + current_matchup_advantage + next_matchup_advantage + baserunner_state + outs_when_up + run_diff + game_year + ((1 | pitcher_year) + (0 + next_batter_xwOBA | pitcher_year))\n                          Sum Sq Mean Sq NumDF  DenDF   F value    Pr(&gt;F)    \nbatter_xwOBA              910.99  910.99     1 622176 6286.5539 &lt; 2.2e-16 ***\nnext_batter_xwOBA           0.81    0.81     1 125767    5.5630   0.01835 *  \ncurrent_matchup_advantage  52.83   52.83     1 370579  364.5597 &lt; 2.2e-16 ***\nnext_matchup_advantage      0.11    0.11     1 332189    0.7769   0.37810    \nbaserunner_state            2.51    0.36     7 621854    2.4699   0.01562 *  \nouts_when_up                7.28    7.28     1 621657   50.2323 1.367e-12 ***\nrun_diff                    0.05    0.05     1 446802    0.3725   0.54165    \ngame_year                   0.65    0.07     9   2584    0.5008   0.87484    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nAs expected, batter_xwOBA is incredibly important to the model, along with current_matchup_advantage. next_batter_xwOBA, outs_when_up, and baserunner_state are also important, while next_matchip_advantage, run_diff, and game_year are not.\nLet‚Äôs create a final model with just the most important fixed effects. We will also include the random slope for the next batter‚Äôs xwOBA.\n\n\nShow Code\nm_protection_final &lt;- lmer(\n  pa_xwOBA ~ batter_xwOBA + next_batter_xwOBA +\n    current_matchup_advantage + \n    baserunner_state + outs_when_up +\n    (1 + next_batter_xwOBA || pitcher_year),  # uncorrelated random effects\n  data = pa_filtered\n)\n\n\nWarning in checkConv(attr(opt, \"derivs\"), opt$par, ctrl = control$checkConv, :\nModel failed to converge with max|grad| = 0.00623311 (tol = 0.002, component 1)\n\n\nShow Code\nsummary(m_protection_final)\n\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: \npa_xwOBA ~ batter_xwOBA + next_batter_xwOBA + current_matchup_advantage +  \n    baserunner_state + outs_when_up + (1 + next_batter_xwOBA ||  \n    pitcher_year)\n   Data: pa_filtered\n\nREML criterion at convergence: 565887.3\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-1.3680 -0.7696 -0.3876  0.7056  4.7366 \n\nRandom effects:\n Groups         Name              Variance  Std.Dev.\n pitcher_year   (Intercept)       0.0003593 0.01896 \n pitcher_year.1 next_batter_xwOBA 0.0028778 0.05365 \n Residual                         0.1449103 0.38067 \nNumber of obs: 622199, groups:  pitcher_year, 2876\n\nFixed effects:\n                            Estimate Std. Error         df t value Pr(&gt;|t|)    \n(Intercept)                8.100e-05  5.440e-03  2.220e+05   0.015 0.988120    \nbatter_xwOBA               1.018e+00  1.280e-02  6.188e+05  79.544  &lt; 2e-16 ***\nnext_batter_xwOBA         -3.083e-02  1.333e-02  1.332e+05  -2.313 0.020733 *  \ncurrent_matchup_advantage  1.921e-02  9.856e-04  5.109e+05  19.487  &lt; 2e-16 ***\nbaserunner_state1B         1.540e-03  1.304e-03  6.220e+05   1.181 0.237718    \nbaserunner_state1B-2B      9.825e-04  2.077e-03  6.222e+05   0.473 0.636239    \nbaserunner_state1B-3B      2.766e-03  3.079e-03  6.221e+05   0.899 0.368883    \nbaserunner_state2B         6.140e-03  1.842e-03  6.221e+05   3.334 0.000857 ***\nbaserunner_state2B-3B     -1.358e-03  3.558e-03  6.221e+05  -0.382 0.702700    \nbaserunner_state3B         7.146e-03  3.084e-03  6.221e+05   2.317 0.020524 *  \nbaserunner_stateLoaded    -2.701e-03  3.592e-03  6.218e+05  -0.752 0.452108    \nouts_when_up              -4.307e-03  6.086e-04  6.216e+05  -7.077 1.47e-12 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            (Intr) bt_OBA n__OBA crrn__ bsr_1B b_1B-2 b_1B-3 bsr_2B b_2B-3\nbattr_xwOBA -0.569                                                        \nnxt_btt_OBA -0.607 -0.253                                                 \ncrrnt_mtch_ -0.122  0.035 -0.004                                          \nbsrnnr_st1B -0.026 -0.019  0.007  0.005                                   \nbsrnn_1B-2B -0.019 -0.009  0.015  0.010  0.160                            \nbsrnn_1B-3B -0.009 -0.005  0.007  0.009  0.109  0.074                     \nbsrnnr_st2B -0.009 -0.008  0.001  0.005  0.180  0.120  0.082              \nbsrnn_2B-3B -0.013  0.006  0.003  0.009  0.095  0.064  0.044  0.072       \nbsrnnr_st3B  0.005 -0.004 -0.002  0.006  0.113  0.077  0.054  0.088  0.047\nbsrnnr_sttL -0.016  0.004  0.008  0.011  0.094  0.064  0.044  0.071  0.039\nouts_when_p -0.211 -0.007  0.015  0.006 -0.107 -0.115 -0.089 -0.131 -0.078\n            bsr_3B bsrn_L\nbattr_xwOBA              \nnxt_btt_OBA              \ncrrnt_mtch_              \nbsrnnr_st1B              \nbsrnn_1B-2B              \nbsrnn_1B-3B              \nbsrnnr_st2B              \nbsrnn_2B-3B              \nbsrnnr_st3B              \nbsrnnr_sttL  0.046       \nouts_when_p -0.126 -0.077\noptimizer (nloptwrap) convergence code: 0 (OK)\nModel failed to converge with max|grad| = 0.00623311 (tol = 0.002, component 1)\n\n\nIn our final model, all coefficients, except for the different levels of baserunner_state, are significant. The coefficient of next_batter_xwOBA is -0.03083, and is signficant at the \\(\\alpha\\) = 0.05 level, with a p-value of 0.02. This indicates that the next batter‚Äôs xwOBA does have a small but significant impact on the current plate appearance‚Äôs xwOBA, and this effect is negative.\nTakeaway: When we select certain fixed effects, we find that the next batter‚Äôs xwOBA continue to have a small but significant impact on the current plate appearance‚Äôs xwOBA, and this effect is negative. A stronger on-deck hitter results in lower than expected outcomes for that plate appearance."
  },
  {
    "objectID": "posts/blog-1-lineup-protection/index.html#discussion",
    "href": "posts/blog-1-lineup-protection/index.html#discussion",
    "title": "Blog Post #1: Lineup Protection or Lineup Penalty?",
    "section": "Discussion",
    "text": "Discussion\nThis study, although rather simple, tackles some of the problems with sabermetrics‚Äô view of lineup protection. By accounting for different game situations, we find that the skill of the next batter does have a statistically significant impact on the offensive outcomes of the current one. While small, this will have significant implications for player evaluation and valuation, as we are establishing dependencies between players that have not been accounted for in the past. We also importantly incorporate the current baserunner situation, number of outs, and current batter handedness advantages, which proved signficant. These all point to the idea that simulations of baseball lineups should both include game situation states and the next batter‚Äôs skill in order to get a more accurate picture of the current batter‚Äôs expected outcomes. Each batter does not come up as an indepdent entity with a unique and stationary probability distribution of their outcomes, but rather a probability distribution slightly altered by externalities."
  },
  {
    "objectID": "posts/blog-1-lineup-protection/index.html#references",
    "href": "posts/blog-1-lineup-protection/index.html#references",
    "title": "Blog Post #1: Lineup Protection or Lineup Penalty?",
    "section": "References",
    "text": "References\nAmbrosino,¬†D. (2011, November 30). Orders of protection. The Hardball Times. https://tht.fangraphs.com/orders-of-protection/\nBradbury,¬†J.¬†C., & Drinen,¬†D.¬†J. (2007). Pigou at the plate. Journal of Sports Economics, 9(2), 211-224. https://doi.org/10.1177/1527002507300178\nBritton,¬†T. (2024, April 26). J.D. Martinez will be Pete Alonso‚Äôs protection in Mets lineup. Does that matter? The New York Times. https://www.nytimes.com/athletic/5443604/2024/04/26/mets-pete-alonso-jd-martinez-lineup/\nCameron,¬†D. (2012, May 25). Cameron: McCutchen disproves lineup protection. ESPN.com. https://insider.espn.com/mlb/insider/story/_/id/7970598/andrew-mccutchen-another-example-why-lineup-protection-myth-mlb\nHow to quantify lineup protection in baseball ‚Äî The Paraball notes. (2024, April 9). The Paraball Notes. https://www.paraballnotes.com/blog/how-to-quantify-lineup-protection-in-baseball\nLaurila,¬†D. (2016, July 14). Player‚Äôs view: Does lineup protection exist? FanGraphs Baseball. https://blogs.fangraphs.com/players-view-does-lineup-protection-exist/\nPetriello,¬†M. (2015, April 13). Billy Hamilton‚Äôs reverse lineup protection. FanGraphs Baseball. https://blogs.fangraphs.com/billy-hamiltons-reverse-lineup-protection/\nPhillips,¬†D.¬†C. (2011). You‚Äôre hurting my game: Lineup protection and injuries in Major League Baseball. Journal of Quantitative Analysis in Sports, 7(3). https://doi.org/10.2202/1559-0410.1296\nStavenhagen,¬†C. (2019, May 7). The (latest) numbers behind Miguel Cabrera‚Äôs remarks on lineup protection. The New York Times. https://www.nytimes.com/athletic/965467/2019/05/07/the-latest-numbers-behind-miguel-cabreras-remarks-on-lineup-protection/\nTango,¬†T. (2006, April 7). Pitching around batters. The Hardball Times. https://tht.fangraphs.com/pitching-around-batters/\nWeinberg,¬†N. (2013, January 1). Lineup protection: Fact or fiction? New English D. https://newenglishd.com/2013/01/01/lineup-protection-fact-or-fiction/\nWiser,¬†J. (2014, February 19). Let‚Äôs talk about lineup protection. Inside the ‚ÄôZona. https://insidethezona.com/2014/02/lets-talk-lineup-protection/"
  },
  {
    "objectID": "appendix/blog3-appendix.html",
    "href": "appendix/blog3-appendix.html",
    "title": "Appendix: Blog Post #3",
    "section": "",
    "text": "First, we loaded in our libraries and read the data, which contains almost every pitch from the 2023 and 2024 seasons (excluding when poor data was retrieved).\n\n\nShow Code\npa_data_final = readRDS(\"data/pa_data_final.rds\")\nbaserunning_data = readRDS(\"data/baserunning_data.rds\")\nstatcast_data = readRDS(\"data/statcast_all_years.rds\")\n\n\nOur baserunning dataset, baserunning_data contains 1806 rows, each representing a player/year combination, each listed with baserunning contributions broken down by stolen bases (SB) and extra bases taken (XB).\nWe will want to do our analysis taking into account how many opportunities each player has to generate baserunning runs. This is more representative of their true baserunning threat than just the number of total baserunning runs they generated.\nIn this code, we first create a lookup table of running_opportunities at the player‚Äìyear level by collecting all the baserunner IDs from on_1b, on_2b, and on_3b in pa_data_final and grouping by both runner_id and game_year. Next, we merge these counts with baserunning_data‚Äîafter converting its start_year column into a game_year‚Äîto compute a per-player average value (runner_average_value), defined as runner_runs_tot divided by running_opportunities for each player-year. We then merge these calculated averages back into pa_data_final by joining on each of the on-base columns (on_1b, on_2b, and on_3b) along with game_year, thereby creating new columns first_base_runner_value, second_base_runner_value, and third_base_runner_value (with any missing values set to 0).\nFinally, we construct a running_opportunities column that counts the occupied bases in each plate appearance and compute a new metric, pa_runner_average_value, by dividing the sum of the individual base runner values by the number of opportunities. This metric reflects the average baserunning value per opportunity for each plate appearance, accounting for player performance on a player‚Äìyear basis.\n\n\nShow Code\n## Create a table of running opportunities per player-year.\n## For every plate appearance in pa_data_final, collect the baserunner IDs\n## from `on_1b`, `on_2b`, and `on_3b`, and group by both `game_year` and the runner ID.\nbaserunner_opportunities &lt;- pa_data_final %&gt;%\n  select(game_pk, at_bat_number, game_year, on_1b, on_2b, on_3b) %&gt;%\n  pivot_longer(\n    cols = c(on_1b, on_2b, on_3b),\n    names_to = \"base\",\n    values_to = \"runner_id\"\n  ) %&gt;%\n  filter(!is.na(runner_id)) %&gt;%\n  group_by(game_year, runner_id) %&gt;%\n  summarize(running_opportunities = n(), .groups = \"drop\")\n\n## Create a lookup table for runner values based on baserunning_data.\n## We assume baserunning_data contains columns: `player_id` and `runner_runs_tot`.\n## We convert `player_id` to character and also set `game_year` equal to `start_year`.\nbaserunning_data &lt;- baserunning_data %&gt;%\n  mutate(\n    player_id = as.character(player_id),\n    game_year = as.character(start_year)\n  )\n\nbaserunner_opportunities = baserunner_opportunities %&gt;%\n  mutate(\n    game_year = as.character(game_year),\n    runner_id = as.character(runner_id)\n  )\n\nbaserunner_values &lt;- baserunning_data %&gt;%\n  select(game_year, player_id, runner_runs_tot) %&gt;%\n  left_join(baserunner_opportunities, by = c(\"game_year\", \"player_id\" = \"runner_id\")) %&gt;%\n  filter(running_opportunities &gt;= 30) %&gt;%\n  mutate(\n    runner_average_value = ifelse(running_opportunities &gt; 0,\n                                  runner_runs_tot / running_opportunities,\n                                  0)\n  )\n\n## Join runner_average_value back to pa_data_final for each base.\n## First, ensure the on-base columns and game_year in pa_data_final are characters.\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    on_1b = as.character(on_1b),\n    on_2b = as.character(on_2b),\n    on_3b = as.character(on_3b),\n    game_year = as.character(game_year)\n  )\n\n# Join for 1B:\npa_data_final &lt;- pa_data_final %&gt;%\n  left_join(\n    baserunner_values %&gt;% select(game_year, player_id, runner_average_value),\n    by = c(\"game_year\", \"on_1b\" = \"player_id\")\n  ) %&gt;%\n  rename(first_base_runner_value = runner_average_value)\n\n# Join for 2B:\npa_data_final &lt;- pa_data_final %&gt;%\n  left_join(\n    baserunner_values %&gt;% select(game_year, player_id, runner_average_value),\n    by = c(\"game_year\", \"on_2b\" = \"player_id\")\n  ) %&gt;%\n  rename(second_base_runner_value = runner_average_value)\n\n# Join for 3B:\npa_data_final &lt;- pa_data_final %&gt;%\n  left_join(\n    baserunner_values %&gt;% select(game_year, player_id, runner_average_value),\n    by = c(\"game_year\", \"on_3b\" = \"player_id\")\n  ) %&gt;%\n  rename(third_base_runner_value = runner_average_value)\n\n## Replace NAs (if a base is empty) with 0 runner value.\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    first_base_runner_value   = ifelse(is.na(on_1b), 0, first_base_runner_value),\n    second_base_runner_value   = ifelse(is.na(on_2b), 0, second_base_runner_value),\n    third_base_runner_value = ifelse(is.na(on_3b), 0, third_base_runner_value)\n  )\n\n## Create a \"running_opportunities\" column in pa_data_final.\n## This counts how many bases are occupied (i.e. not NA) for that plate appearance.\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    running_opportunities = ifelse(!is.na(on_1b), 1, 0) +\n                              ifelse(!is.na(on_2b), 1, 0) +\n                              ifelse(!is.na(on_3b), 1, 0)\n  )\n\n## Compute the plate appearance's average runner value.\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    pa_runner_total_value   = first_base_runner_value + \n      second_base_runner_value + third_base_runner_value,\n    pa_runner_average_value = ifelse(running_opportunities &gt; 0,\n                                     pa_runner_total_value / running_opportunities,\n                                     0)\n  )"
  },
  {
    "objectID": "appendix/blog3-appendix.html#methods",
    "href": "appendix/blog3-appendix.html#methods",
    "title": "Appendix: Blog Post #3",
    "section": "",
    "text": "First, we loaded in our libraries and read the data, which contains almost every pitch from the 2023 and 2024 seasons (excluding when poor data was retrieved).\n\n\nShow Code\npa_data_final = readRDS(\"data/pa_data_final.rds\")\nbaserunning_data = readRDS(\"data/baserunning_data.rds\")\nstatcast_data = readRDS(\"data/statcast_all_years.rds\")\n\n\nOur baserunning dataset, baserunning_data contains 1806 rows, each representing a player/year combination, each listed with baserunning contributions broken down by stolen bases (SB) and extra bases taken (XB).\nWe will want to do our analysis taking into account how many opportunities each player has to generate baserunning runs. This is more representative of their true baserunning threat than just the number of total baserunning runs they generated.\nIn this code, we first create a lookup table of running_opportunities at the player‚Äìyear level by collecting all the baserunner IDs from on_1b, on_2b, and on_3b in pa_data_final and grouping by both runner_id and game_year. Next, we merge these counts with baserunning_data‚Äîafter converting its start_year column into a game_year‚Äîto compute a per-player average value (runner_average_value), defined as runner_runs_tot divided by running_opportunities for each player-year. We then merge these calculated averages back into pa_data_final by joining on each of the on-base columns (on_1b, on_2b, and on_3b) along with game_year, thereby creating new columns first_base_runner_value, second_base_runner_value, and third_base_runner_value (with any missing values set to 0).\nFinally, we construct a running_opportunities column that counts the occupied bases in each plate appearance and compute a new metric, pa_runner_average_value, by dividing the sum of the individual base runner values by the number of opportunities. This metric reflects the average baserunning value per opportunity for each plate appearance, accounting for player performance on a player‚Äìyear basis.\n\n\nShow Code\n## Create a table of running opportunities per player-year.\n## For every plate appearance in pa_data_final, collect the baserunner IDs\n## from `on_1b`, `on_2b`, and `on_3b`, and group by both `game_year` and the runner ID.\nbaserunner_opportunities &lt;- pa_data_final %&gt;%\n  select(game_pk, at_bat_number, game_year, on_1b, on_2b, on_3b) %&gt;%\n  pivot_longer(\n    cols = c(on_1b, on_2b, on_3b),\n    names_to = \"base\",\n    values_to = \"runner_id\"\n  ) %&gt;%\n  filter(!is.na(runner_id)) %&gt;%\n  group_by(game_year, runner_id) %&gt;%\n  summarize(running_opportunities = n(), .groups = \"drop\")\n\n## Create a lookup table for runner values based on baserunning_data.\n## We assume baserunning_data contains columns: `player_id` and `runner_runs_tot`.\n## We convert `player_id` to character and also set `game_year` equal to `start_year`.\nbaserunning_data &lt;- baserunning_data %&gt;%\n  mutate(\n    player_id = as.character(player_id),\n    game_year = as.character(start_year)\n  )\n\nbaserunner_opportunities = baserunner_opportunities %&gt;%\n  mutate(\n    game_year = as.character(game_year),\n    runner_id = as.character(runner_id)\n  )\n\nbaserunner_values &lt;- baserunning_data %&gt;%\n  select(game_year, player_id, runner_runs_tot) %&gt;%\n  left_join(baserunner_opportunities, by = c(\"game_year\", \"player_id\" = \"runner_id\")) %&gt;%\n  filter(running_opportunities &gt;= 30) %&gt;%\n  mutate(\n    runner_average_value = ifelse(running_opportunities &gt; 0,\n                                  runner_runs_tot / running_opportunities,\n                                  0)\n  )\n\n## Join runner_average_value back to pa_data_final for each base.\n## First, ensure the on-base columns and game_year in pa_data_final are characters.\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    on_1b = as.character(on_1b),\n    on_2b = as.character(on_2b),\n    on_3b = as.character(on_3b),\n    game_year = as.character(game_year)\n  )\n\n# Join for 1B:\npa_data_final &lt;- pa_data_final %&gt;%\n  left_join(\n    baserunner_values %&gt;% select(game_year, player_id, runner_average_value),\n    by = c(\"game_year\", \"on_1b\" = \"player_id\")\n  ) %&gt;%\n  rename(first_base_runner_value = runner_average_value)\n\n# Join for 2B:\npa_data_final &lt;- pa_data_final %&gt;%\n  left_join(\n    baserunner_values %&gt;% select(game_year, player_id, runner_average_value),\n    by = c(\"game_year\", \"on_2b\" = \"player_id\")\n  ) %&gt;%\n  rename(second_base_runner_value = runner_average_value)\n\n# Join for 3B:\npa_data_final &lt;- pa_data_final %&gt;%\n  left_join(\n    baserunner_values %&gt;% select(game_year, player_id, runner_average_value),\n    by = c(\"game_year\", \"on_3b\" = \"player_id\")\n  ) %&gt;%\n  rename(third_base_runner_value = runner_average_value)\n\n## Replace NAs (if a base is empty) with 0 runner value.\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    first_base_runner_value   = ifelse(is.na(on_1b), 0, first_base_runner_value),\n    second_base_runner_value   = ifelse(is.na(on_2b), 0, second_base_runner_value),\n    third_base_runner_value = ifelse(is.na(on_3b), 0, third_base_runner_value)\n  )\n\n## Create a \"running_opportunities\" column in pa_data_final.\n## This counts how many bases are occupied (i.e. not NA) for that plate appearance.\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    running_opportunities = ifelse(!is.na(on_1b), 1, 0) +\n                              ifelse(!is.na(on_2b), 1, 0) +\n                              ifelse(!is.na(on_3b), 1, 0)\n  )\n\n## Compute the plate appearance's average runner value.\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    pa_runner_total_value   = first_base_runner_value + \n      second_base_runner_value + third_base_runner_value,\n    pa_runner_average_value = ifelse(running_opportunities &gt; 0,\n                                     pa_runner_total_value / running_opportunities,\n                                     0)\n  )"
  },
  {
    "objectID": "appendix/blog3-appendix.html#model-1-pitcher-behavior",
    "href": "appendix/blog3-appendix.html#model-1-pitcher-behavior",
    "title": "Appendix: Blog Post #3",
    "section": "Model #1: Pitcher Behavior",
    "text": "Model #1: Pitcher Behavior\nWe need to create a new dataframe statcast_data_baserunning, which allows us to study pitch-level Statcast data\n\n\nShow Code\n## Perform a left_join on (game_pk, at_bat_number)\nstatcast_data_baserunning &lt;- statcast_data %&gt;%\n  left_join(\n    pa_data_final %&gt;%\n      select(game_pk, at_bat_number,\n             # Choose whichever columns you need from pa_data_final:\n             pa_runner_average_value,\n             first_base_runner_value,\n             second_base_runner_value,\n             third_base_runner_value,\n             pa_runner_total_value,\n             run_diff, baserunner_state \n      ),\n    by = c(\"game_pk\", \"at_bat_number\")\n  )"
  },
  {
    "objectID": "appendix/blog2-appendix.html",
    "href": "appendix/blog2-appendix.html",
    "title": "Appendix: Blog Post #2",
    "section": "",
    "text": "First, we will read in the data and libraries.\n\n\nShow Code\nlibrary(tidyverse)\nlibrary(car)\nlibrary(pubtheme)\n\nstatcast_data = readRDS(\"data/statcast_all_years.rds\")"
  },
  {
    "objectID": "appendix/blog2-appendix.html#methods",
    "href": "appendix/blog2-appendix.html#methods",
    "title": "Appendix: Blog Post #2",
    "section": "",
    "text": "First, we will read in the data and libraries.\n\n\nShow Code\nlibrary(tidyverse)\nlibrary(car)\nlibrary(pubtheme)\n\nstatcast_data = readRDS(\"data/statcast_all_years.rds\")"
  },
  {
    "objectID": "appendix/blog2-appendix.html#model-i-does-having-a-variety-of-average-swing-characteristics-across-players-on-the-roster-help-or-hurt-scoring",
    "href": "appendix/blog2-appendix.html#model-i-does-having-a-variety-of-average-swing-characteristics-across-players-on-the-roster-help-or-hurt-scoring",
    "title": "Appendix: Blog Post #2",
    "section": "Model I: Does having a variety of average swing characteristics across players on the roster help or hurt scoring?",
    "text": "Model I: Does having a variety of average swing characteristics across players on the roster help or hurt scoring?\n\nIA: Does Variation in Swing Length or Swing Speed individually help a Team across a season?\nFirst, let‚Äôs create a unique ID for each Plate Appearance in statcast_data.\nFor each at-bat, decide if the batter is on the home_team (if inning_topbot == ‚ÄúBot‚Äù) or the away_team (if inning_topbot == ‚ÄúTop‚Äù). This assignment handles trades automatically, because the data for each game has the correct home/away teams for that date. We will also filter to only include 2023 and 2024 data, as we only have swing profile data for those years of analysis.\n\n\nShow Code\nstatcast_blog2 &lt;- statcast_data %&gt;%\n  mutate(\n    PA_id = paste(game_pk, at_bat_number, sep=\"_\"),\n    batter_team = ifelse(inning_topbot == \"Bot\", home_team, away_team)\n  ) %&gt;%\n  # Only keep 2023 and 2024\n  filter(game_year %in% c(2023, 2024))\n\n\nAt this point, a single batter can have multiple rows with different batter_team values if they switched teams mid-season. Each row corresponds to a single plate appearance.\nNow we define each combination (batter, batter_team) separately, so we only include that player‚Äôs PAs while on that team.\n\n\nShow Code\n# Each (batter, batter_team) combination with total PAs\nbatter_team_pa_count &lt;- statcast_blog2 %&gt;%\n  group_by(batter, batter_team, game_year) %&gt;%\n  distinct(PA_id) %&gt;%\n  summarise(total_PA_for_that_team = n(), .groups=\"drop\") %&gt;%\n  arrange(batter, batter_team)\n\n\nChecking players who switched teams midway through in 2024, like Justin Turner, who had 349 PAs for Toronto along with 190 PAs for Seattle, we can see that the batter_team_pa_count is about correct. We get 332 and 189 PAs in our data respectively, likely due to some missing data.\nTo get mean swing length for a player, we need to use only the rows from the times the batter was on that team. That means merging in batter_team_map so we can group by (batter, batter_team).\n\n\nShow Code\nbatter_team_swing_stats &lt;- statcast_blog2 %&gt;%\n  # Keep rows where swing_length and bat_speed are not NA\n  filter(!is.na(swing_length), !is.na(bat_speed)) %&gt;%\n  group_by(batter, batter_team) %&gt;%\n  summarise(\n    mean_swing_length = mean(swing_length, na.rm=TRUE),\n    mean_bat_speed = mean(bat_speed, na.rm=TRUE), # Will need in IB\n    sd_swing_length = sd(swing_length, na.rm=TRUE), # Will need later\n    sd_bat_speed = sd(bat_speed, na.rm=TRUE), # Will need later\n    .groups=\"drop\"\n  )"
  },
  {
    "objectID": "appendix/blog1-appendix.html",
    "href": "appendix/blog1-appendix.html",
    "title": "Appendix: Blog Post #1",
    "section": "",
    "text": "First, we loaded in our libraries and read the data, which contains almost every pitch from the 2024 season (excluding when poor data was retrieved).\n\n\nShow Code\nstatcast_data &lt;- readRDS(\"data/statcast_all_years.rds\")\n\n\nFor each plate appearance, we aggregate key variables. In this code, each plate appearance is identified by grouping on game_pk and at_bat_number, then we take the last pitch (using which.max(pitch_number)) to define final values for fields like pa_xwOBA, pa_xBA, and pa_woba. Specifically, pa_xwOBA is assigned the value from estimated_woba_using_speedangle on the last pitch, and similarly pa_xBA comes from estimated_ba_using_speedangle. We also create pa_BA as 1 if the final_event is \"single\", \"double\", \"triple\", or \"home_run\", and pa_SLG by mapping those same events to 1, 2, 3, or 4 respectively. We compute pitches_per_pa via n(), reflecting how many pitches occurred in each plate appearance. Furthermore, we define is_extra_base_hit if final_event is \"double\", \"triple\", or \"home_run\", is_walk if the final_event is \"walk\" or \"intent_walk\", and is_strikeout if the final_event is \"strikeout\" or \"strikeout_double_play\". Finally, the code calculates run_diff as the difference between bat_score and fld_score on the last pitch, capturing the score differential before the plate appearance‚Äôs outcome is officially applied.\n\n\nShow Code\npa_data &lt;- statcast_data %&gt;%\n  group_by(game_pk, at_bat_number) %&gt;%\n  summarize(\n    # Plate appearance identifiers and context from final pitch\n    game_year              = game_year[which.max(pitch_number)],\n    batter                 = batter[which.max(pitch_number)],\n    pitcher                = pitcher[which.max(pitch_number)],\n    inning                 = inning[which.max(pitch_number)],\n    inning_topbot          = inning_topbot[which.max(pitch_number)],\n    batter_handedness      = stand[which.max(pitch_number)],\n    outs_when_up           = outs_when_up[which.max(pitch_number)],\n    run_diff               = bat_score[which.max(pitch_number)] - fld_score[which.max(pitch_number)],\n    \n    # Final pitch values for this PA\n    pa_xwOBA               = estimated_woba_using_speedangle[which.max(pitch_number)],\n    pa_xSLG                = estimated_slg_using_speedangle[which.max(pitch_number)],\n    pa_xBA                 = estimated_ba_using_speedangle[which.max(pitch_number)],\n    pa_woba                = woba_value[which.max(pitch_number)],\n    on_1b                  = on_1b[which.max(pitch_number)],\n    on_2b                  = on_2b[which.max(pitch_number)],\n    on_3b                  = on_3b[which.max(pitch_number)],\n    final_event            = events[which.max(pitch_number)],\n\n    # Count pitches\n    pitches_per_pa         = n(),\n\n    .groups = \"drop\"\n  ) %&gt;%\n  arrange(game_pk, inning, inning_topbot, at_bat_number) %&gt;%\n  mutate(\n    # Basic batting stats\n    pa_BA  = if_else(final_event %in% c(\"single\", \"double\", \"triple\", \"home_run\"), 1, 0),\n    pa_SLG = case_when(\n      final_event == \"single\"   ~ 1,\n      final_event == \"double\"   ~ 2,\n      final_event == \"triple\"   ~ 3,\n      final_event == \"home_run\" ~ 4,\n      TRUE                      ~ 0\n    ),\n    is_extra_base_hit = final_event %in% c(\"double\", \"triple\", \"home_run\"),\n    is_walk           = final_event %in% c(\"walk\", \"intent_walk\"),\n    is_strikeout      = final_event %in% c(\"strikeout\", \"strikeout_double_play\")\n  )\n\n\nWe then find the next batter in the lineup and get their handedness. We can first organize the plate appearances by the game, then which team is hitting (derived from inning_topbot, and the plate appearance at_bat_number. Except for the last plate appearance for a team in a game, we assume that the protection is coming from the player hitting in the following plate appearance. For the last plate appearance for a team in a game, we make the potential_next_batter simply the batter who followed the player the previous time they came up.\nThis even works when the last hitter (or both the last and penultimate) in the game is a pinch hitter, as we can look at the second (or third) to last hitter‚Äôs previous plate appearance, then find who would be following the pinch hitter in the lineup.\nNote that this does not account for potential pinch hitters in the on-deck circle at the end of a game, pinch hitters who were in the on-deck circle at the time of the third out in an inning, and changes to a hitter in the middle of a plate appearance.\n\n\nShow Code\npa_data &lt;- pa_data %&gt;%\n  ## Order by game, half-inning, and at-bat\n  arrange(game_pk, inning_topbot, at_bat_number) %&gt;%\n  \n  ## Within each half-inning, define a naive next batter/handedness\n  group_by(game_pk, inning_topbot) %&gt;%\n  mutate(\n    naive_next_batter                 = lead(batter),\n    naive_next_batter_handedness      = lead(batter_handedness),\n    # 2-ahead references\n    naive_next_next_batter            = lead(lead(batter)),\n    naive_next_next_batter_handedness = lead(lead(batter_handedness)),\n    # previous references\n    naive_previous_batter             = lag(batter),\n    naive_previous_batter_handedness  = lag(batter_handedness),\n    # 3-ahead references\n    naive_next_next_next_batter            = lead(lead(lead(batter))),\n    naive_next_next_next_batter_handedness = lead(lead(lead(batter_handedness))),\n    # previous-previous references\n    naive_previous_previous_batter            = lag(lag(batter)),\n    naive_previous_previous_batter_handedness = lag(lag(batter_handedness))\n  ) %&gt;%\n  ungroup() %&gt;%\n  \n  ## Wipe out cross-inning naive values\n  mutate(\n    same_half_inning = lead(game_pk) == game_pk & lead(inning_topbot) == inning_topbot,\n    naive_next_batter            = if_else(same_half_inning, naive_next_batter, NA_integer_),\n    naive_next_batter_handedness = if_else(same_half_inning, naive_next_batter_handedness, NA_character_)\n  ) %&gt;%\n  \n  ## For each (game_pk, batter), fill down naive_next_batter\n  group_by(game_pk, batter) %&gt;%\n  fill(naive_next_batter, naive_next_batter_handedness, .direction = \"down\") %&gt;%\n  ungroup() %&gt;%\n  \n  ## Fallback 1 -&gt; Use naive_previous_batter groups\n  group_by(game_pk, naive_previous_batter) %&gt;%\n  # Fill down naive_next_next_batter so each row in the group knows the last seen value\n  fill(naive_next_next_batter, naive_next_next_batter_handedness, .direction = \"down\") %&gt;%\n  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      nth(naive_next_next_batter, n() - 1, default = NA_integer_),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      nth(naive_next_next_batter_handedness, n() - 1, default = NA_character_),\n      naive_next_batter_handedness\n    )\n  ) %&gt;%\n  ungroup() %&gt;%\n  \n  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter UNGROUPED\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      lag(naive_next_next_batter),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      lag(naive_next_next_batter_handedness),\n      naive_next_batter_handedness\n    )\n  ) %&gt;%\n  \n  ## Fallback 2 -&gt; Use naive_previous_previous_batter groups\n  group_by(game_pk, naive_previous_previous_batter) %&gt;%\n  # Fill down naive_next_next_batter so each row in the group knows the last seen value\n  fill(naive_next_next_next_batter, naive_next_next_next_batter_handedness, .direction = \"down\") %&gt;%\n  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      nth(naive_next_next_next_batter, n() - 2, default = NA_integer_),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      nth(naive_next_next_next_batter_handedness, n() - 2, default = NA_character_),\n      naive_next_batter_handedness\n    )\n  ) %&gt;%\n  ungroup() %&gt;%\n  \n  # If naive_next_batter is still NA, use the third-to-last row's naive_next_next_next_batter UNGROUPED\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      lag(lag(naive_next_next_next_batter)),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      lag(lag(naive_next_next_next_batter_handedness)),\n      naive_next_batter_handedness\n    )\n  ) %&gt;%\n  \n  ## Rename & drop the extras\n  rename(\n    potential_next_batter            = naive_next_batter,\n    potential_next_batter_handedness = naive_next_batter_handedness\n  ) %&gt;%\n  select(\n    -naive_next_next_batter,\n    -naive_next_next_batter_handedness,\n    -naive_previous_batter,\n    -naive_previous_batter_handedness,\n    -naive_next_next_next_batter,\n    -naive_next_next_next_batter_handedness,\n    -naive_previous_previous_batter,\n    -naive_previous_previous_batter_handedness\n  )\n\n\nLet‚Äôs also create a single baserunner state variable. We can simply check which of on_1b, on_2b, and on_3b have MLBAMIds and create strings based on that.\n\n\nShow Code\npa_data &lt;- pa_data %&gt;%\n  mutate(\n    baserunner_state = case_when(\n      !is.na(on_1b) & is.na(on_2b) & is.na(on_3b) ~ \"1B\",\n      is.na(on_1b) & !is.na(on_2b) & is.na(on_3b) ~ \"2B\",\n      is.na(on_1b) & is.na(on_2b) & !is.na(on_3b) ~ \"3B\",\n      !is.na(on_1b) & !is.na(on_2b) & is.na(on_3b) ~ \"1B-2B\",\n      !is.na(on_1b) & is.na(on_2b) & !is.na(on_3b) ~ \"1B-3B\",\n      is.na(on_1b) & !is.na(on_2b) & !is.na(on_3b) ~ \"2B-3B\",\n      !is.na(on_1b) & !is.na(on_2b) & !is.na(on_3b) ~ \"Loaded\",\n      TRUE ~ \"Empty\"\n    )\n  )\n\n\nFor the special case in which it is a tie game with 2 outs and bases loaded in the top of the ninth inning, protection will not matter. Thus, we can take out potential_next_batter in those scenarios.\n\n\nShow Code\npa_data &lt;- pa_data %&gt;%\n  mutate(\n    # If it‚Äôs bottom of the 9th+ with 2 outs, bases loaded, and the game is tied,\n    # remove the potential next batter.\n    potential_next_batter = ifelse(\n      inning_topbot == \"Bot\" & \n        inning &gt;= 9 & \n        outs_when_up == 2 & \n        baserunner_state == \"Loaded\" & \n        run_diff == 0,\n      NA,\n      potential_next_batter\n    )\n  )\n\n\n\n\nShow Code\n## Can just read in pa_data if you want to skip the above steps\n## pa_data = readRDS(\"data/pa_data.rds\")\n\n\nTo get our full-season statistics, we will create custom functions to extract Statcast data using BaseballR. We first create a function get_expected_stats_one_year that takes in a year value and min_pa value and outputs a dataframe with each player‚Äôs‚Äîthose that had the minimum plate appearances‚Äîexpected statistics for that year. We chose 200 plate appearances, which is just 40% of the number of plate appearances needed to be qualified for that year, as a player‚Äôs true value should stabilize around that many plate appearances, and we did not want to cut out too much data. We then use get_expected_stats_all_years to get expected statistics across all years of Statcast data (2015-2024).\n\n\nShow Code\nget_expected_stats_one_year &lt;- function(year, min_pa = 200) {\n  # Scrape the \"expected_statistics\" leaderboard for one season\n  # with a minimum PA (e.g. 200).\n  df &lt;- statcast_leaderboards(\n    leaderboard = \"expected_statistics\",\n    year = year,\n    min_pa = min_pa,   # 200\n    player_type = \"batter\"\n  )\n  \n  # Keep only relevant columns & rename them.\n  # The returned columns may include more, but these are typical:\n  # \"year\", \"player_id\", \"pa\", \"bip\", \"ba\", \"est_ba\", \"slg\",\n  # \"est_slg\", \"woba\", \"est_woba\", etc.\n  df &lt;- df %&gt;%\n    select(\n      year,\n      player_id,\n      pa,\n      ba,\n      est_ba,\n      slg,\n      est_slg,\n      woba,\n      est_woba\n      # if you want more columns, add them here\n    ) %&gt;%\n    rename(\n      game_year    = year,      # aligns with pa_data's \"game_year\"\n      batter_id    = player_id, # aligns with pa_data's \"batter\" ID\n      batter_PA    = pa,\n      batter_BA    = ba,\n      batter_xBA   = est_ba,\n      batter_SLG   = slg,\n      batter_xSLG  = est_slg,\n      batter_wOBA  = woba,\n      batter_xwOBA = est_woba\n    )\n  \n  return(df)\n}\n\nget_expected_stats_all_years &lt;- function(start_year, end_year, min_pa = 200) {\n  \n  # Loop over each year, scrape the leaderboard, store results\n  all_stats &lt;- lapply(seq(start_year, end_year), function(yr) {\n    message(\"Scraping year: \", yr)\n    get_expected_stats_one_year(year = yr, min_pa = min_pa)\n  })\n  \n  # Combine all into one data frame\n  all_stats_df &lt;- bind_rows(all_stats)\n  \n  return(all_stats_df)\n}\n\n\nThen, once we put all years of batting statistics into a dataframe titled batter_stats_all, we will add it to our plate appearance-level data pa_data for both the current batter of each row and the next batter. We will only keep rows for which the next batter has followed the current batter for at least 40 plate appearances. We will remove rows for which there are not complete statistics.\n\n\nShow Code\n## Get all years of batting stats from 2015-2024\nbatter_stats_all &lt;- get_expected_stats_all_years(2015, 2024, min_pa = 200)\n\n## Join with pa_data for current & next batters\npa_data_with_batter &lt;- pa_data %&gt;%\n  left_join(batter_stats_all, by = c(\"game_year\", \"batter\" = \"batter_id\"))\n\nnext_batter_stats_all &lt;- batter_stats_all %&gt;%\n  rename(\n    next_batter_PA    = batter_PA,\n    next_batter_BA    = batter_BA,\n    next_batter_xBA   = batter_xBA,\n    next_batter_SLG   = batter_SLG,\n    next_batter_xSLG  = batter_xSLG,\n    next_batter_wOBA  = batter_wOBA,\n    next_batter_xwOBA = batter_xwOBA\n  )\n\npa_data_with_both &lt;- pa_data_with_batter %&gt;%\n  left_join(next_batter_stats_all, by = c(\"game_year\", \n                                          \"potential_next_batter\" = \"batter_id\"))\n\n## Filter pairs with &gt;= 40 PAs\npa_data_with_both &lt;- pa_data_with_both %&gt;%\n  group_by(game_year, batter, potential_next_batter) %&gt;%\n  mutate(combo_count = n()) %&gt;%\n  ungroup() %&gt;%\n  filter(combo_count &gt;= 40) %&gt;%\n  select(-combo_count)\n\n## Remove rows with missing season stats\npa_data_final &lt;- pa_data_with_both %&gt;%\n  filter(\n    !is.na(batter_xwOBA) & !is.na(batter_xSLG) & !is.na(batter_xBA) &\n    !is.na(batter_wOBA) & !is.na(batter_BA) & !is.na(batter_SLG) &\n    !is.na(next_batter_xwOBA) &\n    !is.na(next_batter_xSLG) &\n    !is.na(next_batter_xBA) &\n    !is.na(next_batter_wOBA) &\n    !is.na(next_batter_BA) &\n    !is.na(next_batter_SLG)\n  )\n\n\nWe need four more columns: walk_rate (BB%), strikeout_rate (K%), xbh_rate (XBH%), and pitches_per_pa (P/PA).\nWe will get walk_rate and strikeout_rate from Fangraphs Leaderbaords using BaseballR, and find xbh_rate and pitches_per_pa manually using our pa_data dataset.\nFirst, we can get xbh_rate and pitches_per_pa manually.\n\n\nShow Code\npa_extra_metrics &lt;- pa_data %&gt;%\n  group_by(game_year, batter) %&gt;%\n  summarize(\n    xbh_rate = mean(is_extra_base_hit, na.rm = TRUE),  # extra-base hit rate\n    pitches_per_pa = mean(pitches_per_pa, na.rm = TRUE),    # pitches per plate appearance\n    .groups = \"drop\"\n  ) %&gt;%\n  mutate(game_year = factor(game_year), batter = factor(batter))\n\n## Join to add current batter's extra metrics.\npa_data_final &lt;- pa_data_final %&gt;%\n  left_join(\n    pa_extra_metrics %&gt;% \n      select(game_year, batter, xbh_rate, pitches_per_pa) %&gt;%\n      rename(\n        batter_xbh_rate    = xbh_rate,\n        batter_pitches_per_pa = pitches_per_pa\n      ),\n    by = c(\"game_year\", \"batter\")\n  )\n\n## Join to add next batter's extra metrics.\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    potential_next_batter = as.factor(potential_next_batter)\n  ) %&gt;%\n  left_join(\n    pa_extra_metrics %&gt;% \n      select(game_year, batter, xbh_rate, pitches_per_pa) %&gt;%\n      rename(\n        next_batter_xbh_rate    = xbh_rate,\n        next_batter_pitches_per_pa = pitches_per_pa\n      ),\n    by = c(\"game_year\", \"potential_next_batter\" = \"batter\")\n  )\n\n\nLet‚Äôs also get our walk_rate and strikeout_rate using BaseballR.\n\n\nShow Code\n## Function to get FanGraphs BB% and K% for qualified batters \n## from start_season to end_season (inclusive)\n\nget_fg_batter_rates &lt;- function(start_season, end_season) {\n  # Create a vector of seasons as characters\n  seasons &lt;- as.character(seq(start_season, end_season))\n  \n  # Loop over each season and scrape the batter leaderboard\n  fg_data_list &lt;- lapply(seasons, function(season) {\n    message(\"Scraping FanGraphs batter leaders for season: \", season)\n    df &lt;- fg_batter_leaders(\n      startseason = season,\n      endseason = season,\n      qual = \"y\",      # Only qualified hitters\n      ind = \"1\",       # Split seasons individually\n      pageitems = \"10000\"\n    )\n    # Select only the columns we need.\n    df %&gt;% \n      select(Season, xMLBAMID, BB_pct, K_pct)\n  })\n  \n  # Bind rows together from all seasons\n  fg_data_all &lt;- bind_rows(fg_data_list)\n  \n  # Rename Season to game_year, convert to numeric, and convert xMLBAMID to factor\n  fg_data_all &lt;- fg_data_all %&gt;%\n    rename(game_year = Season) %&gt;%\n    mutate(\n      game_year = as.numeric(game_year),\n      xMLBAMID = as.factor(xMLBAMID)\n    )\n  \n  return(fg_data_all)\n}\n\n## Get FanGraphs batter rates for all seasons 2015-2024\nfg_rates_all &lt;- get_fg_batter_rates(2015, 2024) %&gt;%\n  mutate(game_year = as.factor(game_year), xMLBAMID = as.factor(xMLBAMID))\n\n## Join the scraped FanGraphs rates into pa_data_final\n# Join current batter rates.\npa_data_final &lt;- pa_data_final %&gt;%\n  # Make batter and potential_next_batter into factors\n  mutate(\n    batter = as.factor(batter),\n    potential_next_batter = as.factor(potential_next_batter)\n  ) %&gt;%\n  left_join(\n    fg_rates_all,\n    by = c(\"game_year\", \"batter\" = \"xMLBAMID\")\n  ) %&gt;%\n  rename(\n    batter_bb_pct = BB_pct,\n    batter_k_pct  = K_pct\n  )\n\n# Join next batter rates.\npa_data_final &lt;- pa_data_final %&gt;%\n  left_join(\n    fg_rates_all,\n    by = c(\"game_year\", \"potential_next_batter\" = \"xMLBAMID\")\n  ) %&gt;%\n  rename(\n    next_batter_bb_pct = BB_pct,\n    next_batter_k_pct  = K_pct\n  )\n\n\nNext, we‚Äôll add columns for xwOBA_diff, xBA_diff, and xSLG_diff, which are the differences between the current batter‚Äôs xwOBA, xBA, and xSLG and the plate appearance‚Äôs xwOBA, xBA, and xSLG.\n\n\nShow Code\n# Calculate differences\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    xwOBA_diff = pa_xwOBA - batter_xwOBA,\n    xBA_diff   = pa_xBA - batter_xBA,\n    xSLG_diff  = pa_xSLG - batter_xSLG\n  )\n\n\nThe last thing we will do is ensure that all of the variables we expect to act non-linearly are factors for our models. Also, we will relevel the baserunner_state variable to make ‚ÄúEmpty‚Äù the reference level.\n\n\nShow Code\n# Convert certain variables to factors\npa_data_final$batter_handedness &lt;- factor(pa_data_final$batter_handedness)\npa_data_final$potential_next_batter_handedness &lt;- factor(pa_data_final$potential_next_batter_handedness)\npa_data_final$batter &lt;- factor(pa_data_final$batter)\npa_data_final$pitcher &lt;- factor(pa_data_final$pitcher)\npa_data_final$baserunner_state &lt;- factor(pa_data_final$baserunner_state)\npa_data_final$inning &lt;- factor(pa_data_final$inning)\npa_data_final$game_year &lt;- factor(pa_data_final$game_year)\n\npa_data_final$baserunner_state &lt;- relevel(pa_data_final$baserunner_state, ref = \"Empty\")\n\n\nAfter initial modeling, we‚Äôd like to add the pitcher‚Äôs handedness to our dataset. We can do this by matching the game_pk and at_bat_number of the plate appearance with the same values in the statcast_all_years dataframe. This will give us the pitcher‚Äôs handedness for each plate appearance. We‚Äôd also like to create a new variable that indicates the handedness matchup between the current batter and pitcher, as well as the potential next batter and pitcher.\n\n\nShow Code\npa_data_final$pitcher_handedness &lt;- statcast_all_years$p_throws[match(paste(pa_data_final$game_pk, pa_data_final$at_bat_number),\n                                                                 paste(statcast_all_years$game_pk, statcast_all_years$at_bat_number))]\n\n# Define factor variables with clear reference categories\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    handedness_matchup = factor(\n      paste0(batter_handedness, \"_vs_\", pitcher_handedness),\n      levels = c(\"R_vs_R\", \"L_vs_R\", \"R_vs_L\", \"L_vs_L\")\n    ),\n    next_handedness_matchup = factor(\n      paste0(potential_next_batter_handedness, \"_vs_\", pitcher_handedness),\n      levels = c(\"R_vs_R\", \"L_vs_R\", \"R_vs_L\", \"L_vs_L\")\n    )\n  )\n\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    handedness_matchup = relevel(factor(handedness_matchup), ref = \"R_vs_R\"),\n    next_handedness_matchup = relevel(factor(next_handedness_matchup), ref = \"R_vs_R\")\n  )\n\n\nHowever, when we incorporate handedness_matchup and next_handedness_matchup into the model, we get a warning that the fixed-effect model matrix is rank deficient. This is because So we know: batter_handedness, potential_next_batter_handedness, and pitcher_handedness, so handedness_matchup and next_handedness_matchup are not independent. The model can‚Äôt tell what effects belong to which matchup cleanly without creating overlap. Instead, we can create two new variables: current_matchup_advantage and next_matchup_advantage. These will be 1 if the batter‚Äôs handedness is opposite to the pitcher‚Äôs handedness, and 0 otherwise. This way, we can still capture the matchup effects without creating a rank deficiency.\n\n\nShow Code\npa_data_final &lt;- pa_data_final %&gt;%\n  mutate(\n    current_matchup_advantage = if_else(batter_handedness != pitcher_handedness, 1, 0),\n    next_matchup_advantage    = if_else(potential_next_batter_handedness != pitcher_handedness, 1, 0)\n  )\n\n\nThis is our final pa_data_final dataset that we can load in for model analysis."
  },
  {
    "objectID": "posts/blog-2-swing-profiles/index.html",
    "href": "posts/blog-2-swing-profiles/index.html",
    "title": "Blog Post #2: Swing Profiles",
    "section": "",
    "text": "Having a variety of swing speeds on a roster may correlate with expected scoring statistics for a team over a season, but a variety of swing lengths does not.\nOn a game-by-game basis, a team‚Äôs swing length consistency is correlated with better offensive production, while a team‚Äôs bat speed consistency is not.\nOn a player-by-player basis, a player‚Äôs swing consistency is correlated with better offensive production. This is likely because the best players have found their optimal swing lengths and bat speeds, and while they will slightly deviate from them to better match the pitcher, they have less reason to adjust over the entire season. Worse hitters need to continuously adjust their swings over the season in searching for their best swing type.\n\n\n\nRecent advances in Statcast technology have allowed for the direct measurement of bat speed and swing length on pitches where the batter swings. These new metrics open the door to exploring questions that were previously left to inference, scouting reports, or assumptions about mechanics.\nStatcast defines swing length as ‚ÄúThe total (sum) distance (in feet) traveled by the barrel of the bat in X/Y/Z space, from the start of bat tracking data (generally around 150 ms), up until impact point.‚Äù In general, shorter swings‚Äìthe average swing length is 7.3 feet‚Äìresult in more contact and less power, just as conventional baseball wisdom would posit.\nSwing speed is measured ‚Äúat the point six inches from the head of the bat, what is popularly called ‚Äòthe sweet-spot.‚Äô‚Äù (MLB, 2025)\nNew research has focused much on the outcomes of different swing types, pointing to the idea that although no combination of swing length and speed is necessarily correct, faster bat speeds allow for a multitude of approaches, while lower bat speeds minimize margin for error (Lambert, 2024). This new data also has allowed sabermetricians to better understand the strengths of specific players. While it is would seem obvious that Giancarlo Stanton has an incredibly long and fast swing in the naked eye test, there is now data to back it up (Passan, 2024).\nRecent analyses using MLB‚Äôs Statcast swing-tracking data have found strong statistical support for the benefits of increased swing speed, linking higher swing speeds to better quality contact without significantly higher strikeout rates (Dudzinski, 2025). While traditional baseball wisdom associates faster swings with more strikeouts, the correlation between swing speed and strikeouts was surprisingly weak. Instead, increased swing speed consistently correlated with higher average exit velocities and improved expected offensive metrics such as expected weighted on-base average (xwOBA) and expected slugging percentage (xSLG). These findings suggest hitters may improve overall performance by prioritizing bat speed, enhancing the margin for error in their swing mechanics (Dudzinski, 2025).\nSpecifically, we have become interested in the idea of swing consistency: How much do a batter‚Äôs bat speed and swing length deviate from pitch to pitch or from game to game? How do differing swing profiles on a roster correlate with run generation during a game?\n\n\n\nThis article addresses three connected but distinct angles on these new metrics:\nIndividual-Level Swing Diversity: Do stable or volatile swing metrics for a single batter over a season correlate with that batter‚Äôs offensive success, measured through wOBA or xwOBA?\nGame-Level Team Swing Diversity: Does a club whose hitters share similar or very different swing metrics on a given day see any advantage in that day‚Äôs run production?\nOur analysis aims not to prove a direct cause-and-effect relationship but rather to uncover whether correlations exist that might guide roster construction, daily lineup decisions, or player development. Given that these bat speed and swing length metrics are new, we expect some initial findings to be exploratory, setting the stage for deeper or more controlled studies in the future.\nFundamental Questions Of Our Study\n\nIndividual: Is consistency associated with higher personal performance once I factor out average skill?\nGame: On a day-to-day basis, does having a consistent or varied approach correlate with daily offensive output?\n\n\n\n\nWe will answer these questions mainly using linear regression and multiple linear regression models predicting team runs scored in a game, over a season, and predicting xwOBA over a season from an individual‚Äôs swing consistency.\n\n\n\nFor full methods and model outputs view the full appendix here.\n\n\n\n\n\nWe will want to create a weighted standard deviation-like metric for a team‚Äôs between-player swing style, either swing length or swing speed, variation. This will essentially be a weighted standard deviation of a team‚Äôs player‚Äôs average swing style for those two variables. I decide to give weight to each player by Plate Appearances, not by number of swings. This is because for a particular team, we do not want to overweight the free-swinging players just because they have more swing data. We want to consider player-team combinations, so that a player‚Äôs plate appearances for a certain team are treated separately from their plate appearances for another team, if they played for multiple teams in this season for some reason. This will account for the fact that a player might change swing characteristics upon getting to a new team.\nTo get mean swing length for a player, we need to use only the rows from the times the batter was on that team. That means merging in batter_team_map so we can group by (batter, batter_team).\n\n\nShow Code\nbatter_team_swing_stats &lt;- pitches %&gt;%\n  # Keep rows where swing_length and bat_speed are not NA\n  filter(!is.na(swing_length), !is.na(bat_speed)) %&gt;%\n  group_by(batter, batter_team) %&gt;%\n  summarise(\n    mean_swing_length = mean(swing_length, na.rm=TRUE),\n    mean_bat_speed = mean(bat_speed, na.rm=TRUE), # Will need in Question IB\n    sd_swing_length = sd(swing_length, na.rm=TRUE), # Will need later\n    sd_bat_speed = sd(bat_speed, na.rm=TRUE), # Will need later\n    .groups=\"drop\"\n  )\n\n\nLEFT OFF HERE!!!\nFor each batter-team combination, we now have the mean swing length and bat speed, along with standard deviation. We can now calculate the weighted standard deviation of swing length for each team.\nWe want to first add the total PA for each batter-team combination to the batter_team_swing_stats data frame. This will allow us to weight the standard deviation of swing length by the number of plate appearances for each player.\n\n\nShow Code\nbatter_team_swing_stats &lt;- batter_team_swing_stats %&gt;%\n  left_join(batter_team_pa_count, by=c(\"batter\", \"batter_team\"))\n\n\nWe‚Äôll define a small helper to compute weighted SD:\n\n\nShow Code\nweighted_sd &lt;- function(x, w) {\n  w_mean &lt;- sum(x * w, na.rm=TRUE) / sum(w, na.rm=TRUE)\n  w_var  &lt;- sum(w * (x - w_mean)^2, na.rm=TRUE) / sum(w, na.rm=TRUE)\n  sqrt(w_var)\n}\n\n\n\n\nShow Code\nteam_diversity &lt;- batter_team_swing_stats %&gt;%\n  group_by(batter_team) %&gt;%\n  summarise(\n    # Weighted SD of each player's mean bat_speed\n    team_sd_mean_bat_speed = weighted_sd(mean_bat_speed, total_PA_for_that_team),\n    # Weighted SD of each player's mean swing_length\n    team_sd_mean_swing_length = weighted_sd(mean_swing_length, total_PA_for_that_team),\n    .groups=\"drop\"\n  )\n\n\nWe now have the weighted standard deviation of swing length for each team. We can now check if this variation in swing length helps or hurts scoring. We will use wOBA and xWOBA as proxies for scoring. We will do these calculations manually as our dataset does not include all 2024 Plate Appearances so we will only focus on our subset of the data. We will use the woba_value and woba_denom column in pitches to calculate wOBA for each plate appearance. We will then calculate the average wOBA for each team.\nTypically, wOBA is credited once per completed PA (plate appearance). In many Statcast datasets, woba_value and woba_denom are only non-zero on the final pitch of the PA. However, to ensure we only count each PA once, we can explicitly slice the final pitch of each (game_pk, at_bat_number).\n\n\nShow Code\n# We'll define \"final pitch\" as the last pitch_number in that (game_pk, at_bat_number)\nfinal_pitches &lt;- pitches %&gt;%\n  group_by(game_pk, at_bat_number) %&gt;%\n  slice_max(order_by = pitch_number, n = 1) %&gt;%\n  ungroup()\n\n\nNow final_pitches has exactly 1 row per completed PA. This is our formula for wOBA:\nUpon inspecting the data, we can see that there are some rows for which woba_value or woba_denom are NA, so we will filter those out.\n\n\nShow Code\nfinal_pitches_clean &lt;- final_pitches %&gt;%\n  filter(!is.na(woba_denom), !is.na(woba_value))\n\n\n\n\nShow Code\nteam_woba &lt;- final_pitches_clean %&gt;%\n  group_by(batter_team) %&gt;%\n  summarise(\n    total_woba_value = sum(woba_value, na.rm=TRUE),\n    total_woba_denom = sum(woba_denom, na.rm=TRUE),\n    team_wOBA = ifelse(total_woba_denom == 0, NA,\n                       total_woba_value / total_woba_denom),\n    .groups=\"drop\"\n  ) %&gt;%\n  select(-total_woba_value, -total_woba_denom) %&gt;%\n  arrange(desc(team_wOBA))\n\n\nThis list seems to make sense and is in line with overall 2024 data. Typically, woba_denom is 1 for outcomes like walks, hit-by-pitch, or batted-ball events. For sacrifice flies or other rare events, it can vary slightly. The sum of woba_denom for a team is essentially the sum of PAs used in the wOBA formula (excluding some events like catcher interference or maybe intentionals, depending on how MLBAM codes them). So, its sum is essentially ‚Äúthe count of wOBA-relevant plate appearances‚Äù.\n\n\nShow Code\nanalysis_df &lt;- team_diversity %&gt;%\n  left_join(team_woba,  by=\"batter_team\")\n\n\nWe can also calculate xwOBA for each team. xwOBA is a more advanced metric that uses exit velocity and launch angle to estimate the expected wOBA for each batted ball. We will use the estimated_woba_using_speedangle column in pitches to calculate xwOBA for each batted-ball plate appearance, then account for walks, hit-by-pitches, etc. We will then calculate the average xwOBA for each team.\n\n\nShow Code\nfinal_pitches_xwoba &lt;- final_pitches %&gt;%\n  filter(!is.na(estimated_woba_using_speedangle)) %&gt;%\n  mutate(\n    xWOBA_value = estimated_woba_using_speedangle,\n    xWOBA_denom = 1\n  )\n\n\n\n\nShow Code\nteam_xwoba &lt;- final_pitches_xwoba %&gt;%\n  group_by(batter_team) %&gt;%\n  summarise(\n    total_xwoba_value = sum(xWOBA_value, na.rm=TRUE),\n    total_xwoba_denom = sum(xWOBA_denom, na.rm=TRUE),\n    team_xwOBA = ifelse(total_xwoba_denom == 0, NA,\n                        total_xwoba_value / total_xwoba_denom),\n    .groups=\"drop\"\n  ) %&gt;%\n  select(-total_xwoba_value, -total_xwoba_denom) %&gt;%\n  arrange(desc(team_xwOBA))\n\n\nThis also seems to make sense and is in line with overall 2024 data.\n\n\nShow Code\nanalysis_df &lt;- analysis_df %&gt;%\n  left_join(team_xwoba, by=\"batter_team\")\n\n\n\n\n\n\nShow Code\nggplot(analysis_df, aes(x=team_sd_mean_bat_speed, y=team_wOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Speed Diversity vs. Team wOBA\",\n    x=\"Team SD of Mean Bat Speed\",\n    y=\"Team wOBA\"\n  )+\n  theme_pub()+\n  ## Add trendline\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\nLet‚Äôs create a linear model to see if there is a significant relationship between team swing speed diversity and team wOBA.\n\n\nShow Code\nlm_woba &lt;- lm(team_wOBA ~ team_sd_mean_bat_speed, data=analysis_df)\nsummary(lm_woba)\n\n\nIn this linear model, we get a negative Adjusted R-squared, signalling that there‚Äôs almost no linear relationship‚Äîin other words, once the penalty for adding a predictor is applied, the model explains less variance than just using the mean. The p-value is 0.341, which is insignificant at the 0.05 level. This suggests that there is no significant relationship between team swing speed diversity and team wOBA.\nLet‚Äôs also check the relationship between team swing speed diversity and team xwOBA.\n\n\nShow Code\nggplot(analysis_df, aes(x=team_sd_mean_bat_speed, y=team_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Speed Diversity vs. Team xwOBA\",\n    x=\"Team SD of Mean Bat Speed\",\n    y=\"Team xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\n\n\nShow Code\nlm_xwoba &lt;- lm(team_xwOBA ~ team_sd_mean_bat_speed, data=analysis_df)\nsummary(lm_xwoba)\n\n\nThe Adjusted R-Squared for this model is positive, and the p-value of team-level bat speed diversity has gone down to 0.177. It is possible that with more data from other seasons, we would be able to see more signficiant relationships between team-level bat speed diversity and team xwOBA.\nHowever, at this point, it is worth noting that our data is pointing to the possibility of a relationship, even if it is small, between team-level bat speed diversity and team xwOBA. This is worth more exploration.\nLet‚Äôs do the same for swing length.\n\n\n\n\n\nShow Code\nggplot(analysis_df, aes(x=team_sd_mean_swing_length, y=team_wOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Length Diversity vs. Team wOBA\",\n    x=\"Team SD of Mean Swing Length\",\n    y=\"Team wOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\n\n\nShow Code\nlm_woba &lt;- lm(team_wOBA ~ team_sd_mean_swing_length, data=analysis_df)\nsummary(lm_woba)\n\n\nThe Adjusted R-squared for swing length is also negative, and the p-value is 0.823, which is insignificant at the 0.05 level. This suggests that there is no significant relationship between team swing length diversity and team wOBA.\nLet‚Äôs also check the relationship between team swing length diversity and team xwOBA.\n\n\nShow Code\nggplot(analysis_df, aes(x=team_sd_mean_swing_length, y=team_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Length Diversity vs. Team xwOBA\",\n    x=\"Team SD of Mean Swing Length\",\n    y=\"Team xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\n\n\nShow Code\nlm_xwoba &lt;- lm(team_xwOBA ~ team_sd_mean_swing_length, data=analysis_df)\nsummary(lm_xwoba)\n\n\nAgain, our Adjusted R-Squared is negative, and the p-value of the team-level swing length diversity is 0.367. This suggests that there is no significant relationship between team swing length diversity and team xwOBA.\nIn conclusion, we have found that there is no significant relationship between team swing length diversity and team wOBA or xwOBA. This suggests that having a variety of average swing length characteristics across players on the roster does not help or hurt scoring.\nIt is worth noting that our xwOBA data seems to point towards stronger relationships than our wOBA data. In theory, xwOBA is a more trustworthy measure of offensive production, because it looks to eliminate the noise of defense and luck. Sometimes including both together‚Äîor creating a combined 2D measure‚Äîcan reveal patterns not evident in either metric separately.\nPerhaps the simplest approach is to include both predictors in the same linear model as a multiple regression model.\n\n\n\n\n\n\nIf team_sd_mean_swing_length was ‚Äúuseless‚Äù by itself, it could still contribute additional explanatory power in the presence of team_sd_mean_bat_speed. For example, maybe a team with both high bat‚Äêspeed diversity and high swing‚Äêlength diversity has synergy (or a deficiency).\n\n\nShow Code\n# Using wOBA\nmod_multi &lt;- lm(team_wOBA ~ team_sd_mean_bat_speed + team_sd_mean_swing_length,\n                data = analysis_df)\nsummary(mod_multi)\n# Using xWOBA\nmod_multi &lt;- lm(team_xwOBA ~ team_sd_mean_bat_speed + team_sd_mean_swing_length,\n                data = analysis_df)\nsummary(mod_multi)\n\n\nThe Adjusted R-Squared for both models are negative, suggesting that while team-level bat speed variation may help explain between-team variation in xWOBA, a combined model with swing length is not providing any explanation for the variation in xWOBA or wOBA. In both models, the p-values for both predictors are also insignificant at the 0.05 level.\nIt is worth noting that other models with interaction and transformed predictors were considered, though nothing yielded a realistic and suitable result.\nGiven that all of this data analysis was done on 30 data points (30 teams), we would like to consider a team‚Äôs wOBA and xWOBA for each game.\nTakeaway #1: Having a variety of swing speeds on a roster could correlate with expected scoring statistics for a team over a season, but a variety of swing lengths does not.\n\n\n\n\nIn this model, we can incorporate situational or day‚Äêto‚Äêday changes in the team‚Äôs lineup (maybe a star was resting, or they traded for a new hitter mid‚Äêseason). We will want to compute each team‚Äôs in‚Äêgame diversity of swing speed and swing length weighted by plate appearances, then comparing that to the team‚Äôs in‚Äêgame wOBA and xwOBA.\nFirst, we group by (game_pk, batter_team, batter) to compute the mean and median for each player in that game. We also count how many plate appearances that batter had in that game.\n\n\nShow Code\npitches = read.csv(\"data/statcast_data.csv\")\n\npitches &lt;- pitches %&gt;%\n  mutate(\n    PA_id = paste(game_pk, at_bat_number, sep=\"_\"),\n    batter_team = ifelse(inning_topbot == \"Bot\", home_team, away_team)\n  )\n\nplayer_game_allPA &lt;- pitches %&gt;%\n  group_by(game_pk, batter, batter_team) %&gt;%\n  summarise(\n    total_pa_game = n_distinct(PA_id),    # all PAs in that game for that batter\n    .groups = \"drop\"\n  )\n\n# Subset to actual swings\nbatter_game_swings &lt;- pitches %&gt;%\n  filter(!is.na(bat_speed), !is.na(swing_length)) %&gt;%\n  group_by(game_pk, batter, batter_team) %&gt;%\n  summarise(\n    # mean & median for the swings that occurred\n    game_median_bat_speed    = median(bat_speed, na.rm=TRUE),\n    game_median_swing_length = median(swing_length, na.rm=TRUE),\n    .groups=\"drop\"\n  )\n\n\nFinally, we do a left_join so that every (game, batter, team) from player_game_allPA is preserved‚Äîeven if the player never swung:\n\n\nShow Code\nbatter_game_stats &lt;- player_game_allPA %&gt;%\n  left_join(batter_game_swings,\n            by = c(\"game_pk\", \"batter\", \"batter_team\"))\n\n\nSome batters (especially if they only had one PA) might have 0 swings and thus NA data for the swing columns. That is okay, as they will not effect our weighted standard deviations.\nNow, let‚Äôs get our team-level game-by-game diversity of swing speed and swing length. We will use the same weighted standard deviation formula as before, but this time we will use the game_mean_bat_speed and game_mean_swing_length columns.\n\n\nShow Code\nteam_game_diversity &lt;- batter_game_stats %&gt;%\n  group_by(game_pk, batter_team) %&gt;%\n  summarise(\n    # Weighted SD of each player's median (bat_speed)\n    game_sd_median_bat_speed = weighted_sd(game_median_bat_speed, total_pa_game),\n\n    # Weighted SD of each player's median (swing_length)\n    game_sd_median_swing_length = weighted_sd(game_median_swing_length, total_pa_game),\n    \n    .groups = \"drop\"\n  )\n\n\nNow each row in team_game_diversity is a single (game_pk, batter_team) with four different ‚Äúdiversity‚Äù metrics (two based on mean, two based on median).\nNext, we will compute game-level xWOBA and wOBA for each team. We will use the same formula as before, but this time we will use the woba_value and woba_denom columns in pitches to calculate wOBA for each plate appearance. We will then calculate the average wOBA for each team.\n\n\nShow Code\ngame_woba &lt;- final_pitches_clean %&gt;%\n  group_by(game_pk, batter_team) %&gt;%\n  summarise(\n    total_woba_val   = sum(woba_value, na.rm=TRUE),\n    total_woba_denom = sum(woba_denom, na.rm=TRUE),\n    game_wOBA = ifelse(total_woba_denom == 0, NA,\n                       total_woba_val / total_woba_denom),\n    .groups=\"drop\"\n  ) %&gt;%\n  select(game_pk, batter_team, game_wOBA)\n\ngame_xwoba &lt;- final_pitches_xwoba %&gt;%\n  group_by(game_pk, batter_team) %&gt;%\n  summarise(\n    total_xwoba_value   = sum(xWOBA_value, na.rm=TRUE),\n    total_xwoba_denom = sum(xWOBA_denom, na.rm=TRUE),\n    game_xwOBA = ifelse(total_xwoba_denom == 0, NA,\n                        total_xwoba_value / total_xwoba_denom),\n    .groups=\"drop\"\n  ) %&gt;%\n  select(game_pk, batter_team, game_xwOBA)\n\n\nNow, combine into an analysis dataframe:\n\n\nShow Code\nanalysis_game_df &lt;- team_game_diversity %&gt;%\n  left_join(game_woba, by=c(\"game_pk\", \"batter_team\"))\n\nanalysis_game_df &lt;- analysis_game_df %&gt;%\n  left_join(game_xwoba, by=c(\"game_pk\",\"batter_team\"))\n\n\nLet‚Äôs make our models for swing length:\n\n\nShow Code\n# Median-based statistics\nmedian_woba_swing_length_model &lt;- lm(game_wOBA ~ game_sd_median_swing_length,\n                    data=analysis_game_df)\nsummary(median_woba_swing_length_model)\n\nmedian_xwoba_swing_length_model &lt;- lm(game_xwOBA ~ game_sd_median_swing_length,\n                    data=analysis_game_df)\nsummary(median_xwoba_swing_length_model)\n\n\nWe tried out both mean and median-based models to ensure that outliers in the data were not influencing individual player‚Äôs swing data. However, the mean-based and median-based models are showing similar results. Thus, we are going to graph just median-based results, as they are much more signficiant. These four models are all interesting though, with significant p-values for all coefficients of team swing length diversity, and positive Adjusted R-Squared values, even if incredibly small, for all models.\nThe coefficients for team swing length diversity are all negative, suggesting that on a game-by-game basis, a more consistent swing length is correlated with better offensive production. The p-values are all significant at the 0.05 level, suggesting that there is a significant relationship between team swing length diversity and team wOBA and xwOBA. The Adjusted R-Squared values are all positive, suggesting that the models explain some variance in team wOBA and xwOBA.\nThis finding is interesting, as it could point to a number of things: - Consistent team-wide swing length approaches might be best for scoring - Our team-by-team data might simply have not had enough sample size to find significant correlations\nOne possible explanation: The teams with the best scouting and analytics can prepare their players similarly for a particular game, allowing them to capitalize on the opponents‚Äô weaknesses or particular ballpark-related advantages.\nLet‚Äôs make our models for bat speed:\n\n\nShow Code\n# Median-based statistics\nmedian_woba_bat_speed_model &lt;- lm(game_wOBA ~ game_sd_median_bat_speed,\n                    data=analysis_game_df)\nsummary(median_woba_bat_speed_model)\n\nmedian_xwoba_bat_speed_model &lt;- lm(game_xwOBA ~ game_sd_median_bat_speed,\n                    data=analysis_game_df)\nsummary(median_xwoba_bat_speed_model)\n\n\nIn all models except 1, we got both a negative Adjusted R-Squared and an insignifcant sign of the coefficient. In our model of game-level team bat speed diversity with wOBA, we got a positive Adjusted R-Squared, but the p-value of the coefficient is insignificant at the 0.05 level, and it does not line up with the model using xWOBA, and thus, I will ignore it as likely due to random chance. This suggests that on a game-by-game basis, consistency in a team‚Äôs bat speed does not correlate positively or negatively with increased scoring.\nThis inversion from our potential correlations in team-level bat speed diversity and team xwOBA is interesting.\nOne possible explanation: Throughout a season, a team that has a variety of bat speeds can more easily adapt to the many pitchers they face. In one particular game, a team‚Äôs variety of bat speeds does not prove useful when they may only face two or three pitchers, provided that the starter pitches for a large portion of the game.\nLet‚Äôs graph these scenarios, using the median variation values and xWOBA:\n\n\nShow Code\nggplot(analysis_game_df, aes(x=game_sd_median_swing_length, y=game_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Length Diversity vs. Team xwOBA\",\n    x=\"Game SD of Median Swing Length\",\n    y=\"Game xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\nggplot(analysis_game_df, aes(x=game_sd_median_bat_speed, y=game_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Speed Diversity vs. Team xwOBA\",\n    x=\"Game SD of Median Bat Speed\",\n    y=\"Game xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\nTakeaway #2: On a game-by-game basis, a team‚Äôs swing length consistency is correlated with better offensive production, while a team‚Äôs bat speed consistency is not.\nThinking about Takeaways 1 and 2 together, it is possible that a team‚Äôs swing length consistency in a particular game points to the idea that they have prepared for a particular set of pitchers well and are able to achieve similar swing lengths to best capitalize on the attributes of the opposing pitchers or of the ballpark. However, over an entire season, it could be advantageous to have a variety of swing speeds on a roster to be able to attack the wide variety of pitchers faced, while optimal swing lengths average out over a long season and many pitchers. It is possible that swing lengths are easier to fluctuate on a per-game basis, but swing speeds are more difficult to change, thus a variety is needed on a roster.\n\n\nLet‚Äôs also try one multivariate model to see if we can find a relationship between swing style consistency and xwOBA.\n\n\nShow Code\nmod_multi &lt;- lm(game_xwOBA ~ game_sd_median_bat_speed + game_sd_median_swing_length,\n                data = analysis_game_df)\nsummary(mod_multi)\n\n\nIn this model, both bat speed and swing length are significant at the 0.05 level, and the Adjusted R-Squared is positive. This suggests that there is a significant relationship between team swing length and bat speed consistency and team xwOBA on a game-by-game basis.\nThis suggests that, holding swing length diversity constant, having a range of bat speeds within the lineup may help on a game-by-game basis. It could allow the team to adapt to differing pitch velocities and styles from the opposing pitchers.\nMeanwhile, holding bat speed diversity constant, a more consistent (less diverse) swing length appears beneficial. If everyone‚Äôs length is dialed in for that day‚Äôs pitcher(s), the team might more efficiently square up pitches or stay in the optimal ‚Äúcontact window.‚Äù\nOn a single‚Äêgame basis, these results indicate that a consistent swing length is linked to better offensive output, while some diversity in bat speed can be helpful. This aligns with the idea that hitters can unify their swing lengths to match that day‚Äôs pitchers and still bring different swing speeds to handle velocity changes or relief pitchers.\nOne possible explanation: For a particular game, a team‚Äôs swing length helps them better adjust for ballpark dimensions or aspects of the weather/environment, but a team‚Äôs bat speed diversity helps them adjust to the variety of pitchers they face.\n\n\n\n\nNow, we‚Äôd like to ask whether on a player-by-player basis, does a player‚Äôs swing consistency during a season correlate with success at the plate? We will use the same weighted standard deviation formula as before, but this time we will use the player‚Äôs mean swing length and bat speed for the season. Asked another way: Does having a consistent swing over a season correlate with a particular player generating offense.\n\n\nShow Code\npitches &lt;- pitches %&gt;%\n  mutate(\n    PA_id = paste(game_pk, at_bat_number, sep=\"_\"),\n    batter_team = ifelse(inning_topbot == \"Bot\", home_team, away_team)\n  )\n\nplayer_swing_consistency &lt;- pitches %&gt;%\n  filter(!is.na(swing_length), !is.na(bat_speed)) %&gt;%\n  group_by(batter) %&gt;%\n  summarise(\n    # Season-long means\n    mean_swing_length = mean(swing_length, na.rm=TRUE),\n    mean_bat_speed    = mean(bat_speed, na.rm=TRUE),\n    # Season-long standard deviations\n    sd_swing_length = sd(swing_length, na.rm=TRUE),\n    sd_bat_speed    = sd(bat_speed, na.rm=TRUE),\n    .groups = \"drop\"\n  )\n\n## Take out players with NA standard deviation\nplayer_swing_consistency &lt;- player_swing_consistency %&gt;%\n  filter(!is.na(sd_swing_length), !is.na(sd_bat_speed))\n\n\nThis gives us one row per batter, capturing that player‚Äôs overall pitch-to-pitch variation in swing metrics across the entire season.\nNow, let‚Äôs calculate xWOBA for all players over the season.\n\n\nShow Code\n# We'll define \"final pitch\" as the last pitch_number in that (game_pk, at_bat_number)\nfinal_pitches &lt;- pitches %&gt;%\n  group_by(game_pk, at_bat_number) %&gt;%\n  slice_max(order_by = pitch_number, n = 1) %&gt;%\n  ungroup()\n\nfinal_pitches_xwoba &lt;- final_pitches %&gt;%\n  filter(!is.na(estimated_woba_using_speedangle)) %&gt;%\n  mutate(\n    xWOBA_value = estimated_woba_using_speedangle,\n    xWOBA_denom = 1\n  )\n\nplayer_xwoba &lt;- final_pitches_xwoba %&gt;%\n  group_by(batter) %&gt;%\n  summarise(\n    total_xwoba_value = sum(xWOBA_value, na.rm=TRUE),\n    total_xwoba_denom = sum(xWOBA_denom, na.rm=TRUE),\n    player_xwOBA = ifelse(total_xwoba_denom == 0, NA,\n                          total_xwoba_value / total_xwoba_denom),\n    .groups=\"drop\"\n  ) %&gt;%\n  select(batter, player_xwOBA)\n\n\nNow, combine into an analysis dataframe:\n\n\nShow Code\nplayer_analysis_df &lt;- player_swing_consistency %&gt;%\n  left_join(player_xwoba, by=\"batter\")\n\n\nLet‚Äôs graph these scenarios, using the median variation values and xWOBA:\n\n\nShow Code\nggplot(player_analysis_df, aes(x=sd_swing_length, y=player_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Player Swing Length Consistency vs. Player xwOBA\",\n    x=\"Player SD of Swing Length\",\n    y=\"Player xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\nggplot(player_analysis_df, aes(x=sd_bat_speed, y=player_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Player Bat Speed Consistency vs. Player xwOBA\",\n    x=\"Player SD of Bat Speed\",\n    y=\"Player xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\nLet‚Äôs also create linear models to see if there is a significant relationship between player swing consistency and player xwOBA.\n\n\nShow Code\nmodel_sd_swing_length &lt;- lm(player_xwOBA ~ mean_swing_length + sd_swing_length, data=player_analysis_df)\nsummary(model_sd_swing_length)\n\nmodel_sd_bat_speed &lt;- lm(player_xwOBA ~ mean_bat_speed + sd_bat_speed, data=player_analysis_df)\nsummary(model_sd_bat_speed)\n\n\nIn both models, the Adjusted R-Squared is positive, and the p-value of the coefficient is significant at the 0.05 level. This suggests that there is a significant relationship between player swing consistency and player xwOBA for both swing length and bat speed. The coefficients are negative, suggesting that a more consistent swing length and bat speed is correlated with better offensive production. This likely points to the idea that the best hitters have found optimal swing lengths and bat speeds, and while they will likely slightly deviate from them to better match the pitcher, they have less reason to adjust over the entire season. Worse hitters need to continuously adjust their swings over the season in searching for their best swing type.\n\n\nLet‚Äôs also try one multivariate model to see if we can find a relationship between player swing consistency and xwOBA.\n\n\nShow Code\nmod_multi &lt;- lm(player_xwOBA ~ mean_swing_length + mean_bat_speed + sd_swing_length + sd_bat_speed,\n                data = player_analysis_df)\nsummary(mod_multi)\n\nlibrary(car)\nvif(mod_multi)\n\n## Show collinearity between predictors\ncor(player_analysis_df$sd_swing_length, player_analysis_df$sd_bat_speed)\ncor(player_analysis_df$mean_swing_length, player_analysis_df$mean_bat_speed)\ncor(player_analysis_df$mean_swing_length, player_analysis_df$sd_swing_length)\ncor(player_analysis_df$mean_bat_speed, player_analysis_df$sd_bat_speed)\n\n\nAlthough our VIF values are all less than 5, suggesting that multicollinearity is likely not a problem and just a result of using real imperfect data, we can try to create a ‚Äúmechanical variability‚Äù combined component using Principal Components Analysis to combine the two predictors into one.\n\n\nShow Code\n# Step 1: Standardize variables\nplayer_analysis_df &lt;- player_analysis_df %&gt;%\n  mutate(\n    sd_swing_length_scaled = scale(sd_swing_length),\n    sd_bat_speed_scaled = scale(sd_bat_speed)\n  )\n\n# Step 2: Perform PCA\npca_model &lt;- prcomp(player_analysis_df[, c(\"sd_swing_length_scaled\", \"sd_bat_speed_scaled\")],\n                    center = TRUE, scale. = TRUE)\n\n# Step 3: Add first principal component to the dataset\nplayer_analysis_df &lt;- player_analysis_df %&gt;%\n  mutate(mechanical_variability = pca_model$x[, 1])\n\n# Check PCA results\nsummary(pca_model)\n\n\n\n\nShow Code\nmodel &lt;- lm(player_xwOBA ~ mean_swing_length + mean_bat_speed + mechanical_variability,\n            data = player_analysis_df)\nsummary(model)\n\nvif(model)\n\n\nOur VIFs are again under 5, signalling that this is a good model.\nTakeaway #3: On a player-by-player basis, a player‚Äôs swing consistency is correlated with better offensive production. This is likely because the best players have found their optimal swing lengths and bat speeds, and while they will slightly deviate from them to better match the pitcher, they have less reason to adjust over the entire season. Worse hitters need to continuously adjust their swings over the season in searching for their best swing type.\n\n\n\n\n\n\n\n\nDudzinski,¬†R. (2025, January 30). The data is in from MLB‚Äî swing hard, just in case you hit it. Medium. https://medium.com/@robbiedudz34/the-data-is-in-from-mlb-swing-hard-just-in-case-you-hit-it-220cae1af5ca\nFast-swing rate. (n.d.). MLB.com. https://www.mlb.com/glossary/statcast/fast-swing-rate\nLambert,¬†J. (2024, August 1). Using MLB bat tracking data to better understand swings. Driveline Baseball. https://www.drivelinebaseball.com/2024/07/using-mlb-bat-tracking-data-to-better-understand-swings/?srsltid=AfmBOopwi5JuXS1YWSWq4ny_NNrcHio0S1pASMeH0vXtOY1mZug93TOx\nPassan,¬†J. (2024, May 13). Passan: The five biggest takeaways from Statcast‚Äôs swing-tracking data. ESPN.com. https://www.espn.com/mlb/story/_/id/40120458/mlb-statcast-bat-tracking-data-giancarlo-stanton-luis-arraez\nSwing length. (n.d.). MLB.com. https://www.mlb.com/glossary/statcast/swing-length"
  },
  {
    "objectID": "posts/blog-2-swing-profiles/index.html#introduction-to-swing-profile-data",
    "href": "posts/blog-2-swing-profiles/index.html#introduction-to-swing-profile-data",
    "title": "Blog Post #2: Swing Profiles",
    "section": "",
    "text": "Recent advances in Statcast technology have allowed for the direct measurement of bat speed and swing length on pitches where the batter swings. These new metrics open the door to exploring questions that were previously left to inference, scouting reports, or assumptions about mechanics.\nStatcast defines swing length as ‚ÄúThe total (sum) distance (in feet) traveled by the barrel of the bat in X/Y/Z space, from the start of bat tracking data (generally around 150 ms), up until impact point.‚Äù In general, shorter swings‚Äìthe average swing length is 7.3 feet‚Äìresult in more contact and less power, just as conventional baseball wisdom would posit.\nSwing speed is measured ‚Äúat the point six inches from the head of the bat, what is popularly called ‚Äòthe sweet-spot.‚Äô‚Äù (MLB, 2025)\nNew research has focused much on the outcomes of different swing types, pointing to the idea that although no combination of swing length and speed is necessarily correct, faster bat speeds allow for a multitude of approaches, while lower bat speeds minimize margin for error (Lambert, 2024). This new data also has allowed sabermetricians to better understand the strengths of specific players. While it is would seem obvious that Giancarlo Stanton has an incredibly long and fast swing in the naked eye test, there is now data to back it up (Passan, 2024).\nRecent analyses using MLB‚Äôs Statcast swing-tracking data have found strong statistical support for the benefits of increased swing speed, linking higher swing speeds to better quality contact without significantly higher strikeout rates (Dudzinski, 2025). While traditional baseball wisdom associates faster swings with more strikeouts, the correlation between swing speed and strikeouts was surprisingly weak. Instead, increased swing speed consistently correlated with higher average exit velocities and improved expected offensive metrics such as expected weighted on-base average (xwOBA) and expected slugging percentage (xSLG). These findings suggest hitters may improve overall performance by prioritizing bat speed, enhancing the margin for error in their swing mechanics (Dudzinski, 2025).\nSpecifically, we have become interested in the idea of swing consistency: How much do a batter‚Äôs bat speed and swing length deviate from pitch to pitch or from game to game? How do differing swing profiles on a roster correlate with run generation during a game?"
  },
  {
    "objectID": "posts/blog-2-swing-profiles/index.html#aim",
    "href": "posts/blog-2-swing-profiles/index.html#aim",
    "title": "Blog Post #2: Swing Profiles",
    "section": "",
    "text": "This article addresses three connected but distinct angles on these new metrics:\nIndividual-Level Swing Diversity: Do stable or volatile swing metrics for a single batter over a season correlate with that batter‚Äôs offensive success, measured through wOBA or xwOBA?\nGame-Level Team Swing Diversity: Does a club whose hitters share similar or very different swing metrics on a given day see any advantage in that day‚Äôs run production?\nOur analysis aims not to prove a direct cause-and-effect relationship but rather to uncover whether correlations exist that might guide roster construction, daily lineup decisions, or player development. Given that these bat speed and swing length metrics are new, we expect some initial findings to be exploratory, setting the stage for deeper or more controlled studies in the future.\nFundamental Questions Of Our Study\n\nIndividual: Is consistency associated with higher personal performance once I factor out average skill?\nGame: On a day-to-day basis, does having a consistent or varied approach correlate with daily offensive output?"
  },
  {
    "objectID": "posts/blog-2-swing-profiles/index.html#setup",
    "href": "posts/blog-2-swing-profiles/index.html#setup",
    "title": "Blog Post #2: Swing Profiles",
    "section": "",
    "text": "We will answer these questions mainly using linear regression and multiple linear regression models predicting team runs scored in a game, over a season, and predicting xwOBA over a season from an individual‚Äôs swing consistency."
  },
  {
    "objectID": "posts/blog-2-swing-profiles/index.html#methods",
    "href": "posts/blog-2-swing-profiles/index.html#methods",
    "title": "Blog Post #2: Swing Profiles",
    "section": "",
    "text": "For full methods and model outputs view the full appendix here."
  },
  {
    "objectID": "posts/blog-2-swing-profiles/index.html#model-i-does-having-a-variety-of-average-swing-characteristics-across-players-on-the-roster-help-or-hurt-scoring",
    "href": "posts/blog-2-swing-profiles/index.html#model-i-does-having-a-variety-of-average-swing-characteristics-across-players-on-the-roster-help-or-hurt-scoring",
    "title": "Blog Post #2: Swing Profiles",
    "section": "",
    "text": "We will want to create a weighted standard deviation-like metric for a team‚Äôs between-player swing style, either swing length or swing speed, variation. This will essentially be a weighted standard deviation of a team‚Äôs player‚Äôs average swing style for those two variables. I decide to give weight to each player by Plate Appearances, not by number of swings. This is because for a particular team, we do not want to overweight the free-swinging players just because they have more swing data. We want to consider player-team combinations, so that a player‚Äôs plate appearances for a certain team are treated separately from their plate appearances for another team, if they played for multiple teams in this season for some reason. This will account for the fact that a player might change swing characteristics upon getting to a new team.\nTo get mean swing length for a player, we need to use only the rows from the times the batter was on that team. That means merging in batter_team_map so we can group by (batter, batter_team).\n\n\nShow Code\nbatter_team_swing_stats &lt;- pitches %&gt;%\n  # Keep rows where swing_length and bat_speed are not NA\n  filter(!is.na(swing_length), !is.na(bat_speed)) %&gt;%\n  group_by(batter, batter_team) %&gt;%\n  summarise(\n    mean_swing_length = mean(swing_length, na.rm=TRUE),\n    mean_bat_speed = mean(bat_speed, na.rm=TRUE), # Will need in Question IB\n    sd_swing_length = sd(swing_length, na.rm=TRUE), # Will need later\n    sd_bat_speed = sd(bat_speed, na.rm=TRUE), # Will need later\n    .groups=\"drop\"\n  )\n\n\nLEFT OFF HERE!!!\nFor each batter-team combination, we now have the mean swing length and bat speed, along with standard deviation. We can now calculate the weighted standard deviation of swing length for each team.\nWe want to first add the total PA for each batter-team combination to the batter_team_swing_stats data frame. This will allow us to weight the standard deviation of swing length by the number of plate appearances for each player.\n\n\nShow Code\nbatter_team_swing_stats &lt;- batter_team_swing_stats %&gt;%\n  left_join(batter_team_pa_count, by=c(\"batter\", \"batter_team\"))\n\n\nWe‚Äôll define a small helper to compute weighted SD:\n\n\nShow Code\nweighted_sd &lt;- function(x, w) {\n  w_mean &lt;- sum(x * w, na.rm=TRUE) / sum(w, na.rm=TRUE)\n  w_var  &lt;- sum(w * (x - w_mean)^2, na.rm=TRUE) / sum(w, na.rm=TRUE)\n  sqrt(w_var)\n}\n\n\n\n\nShow Code\nteam_diversity &lt;- batter_team_swing_stats %&gt;%\n  group_by(batter_team) %&gt;%\n  summarise(\n    # Weighted SD of each player's mean bat_speed\n    team_sd_mean_bat_speed = weighted_sd(mean_bat_speed, total_PA_for_that_team),\n    # Weighted SD of each player's mean swing_length\n    team_sd_mean_swing_length = weighted_sd(mean_swing_length, total_PA_for_that_team),\n    .groups=\"drop\"\n  )\n\n\nWe now have the weighted standard deviation of swing length for each team. We can now check if this variation in swing length helps or hurts scoring. We will use wOBA and xWOBA as proxies for scoring. We will do these calculations manually as our dataset does not include all 2024 Plate Appearances so we will only focus on our subset of the data. We will use the woba_value and woba_denom column in pitches to calculate wOBA for each plate appearance. We will then calculate the average wOBA for each team.\nTypically, wOBA is credited once per completed PA (plate appearance). In many Statcast datasets, woba_value and woba_denom are only non-zero on the final pitch of the PA. However, to ensure we only count each PA once, we can explicitly slice the final pitch of each (game_pk, at_bat_number).\n\n\nShow Code\n# We'll define \"final pitch\" as the last pitch_number in that (game_pk, at_bat_number)\nfinal_pitches &lt;- pitches %&gt;%\n  group_by(game_pk, at_bat_number) %&gt;%\n  slice_max(order_by = pitch_number, n = 1) %&gt;%\n  ungroup()\n\n\nNow final_pitches has exactly 1 row per completed PA. This is our formula for wOBA:\nUpon inspecting the data, we can see that there are some rows for which woba_value or woba_denom are NA, so we will filter those out.\n\n\nShow Code\nfinal_pitches_clean &lt;- final_pitches %&gt;%\n  filter(!is.na(woba_denom), !is.na(woba_value))\n\n\n\n\nShow Code\nteam_woba &lt;- final_pitches_clean %&gt;%\n  group_by(batter_team) %&gt;%\n  summarise(\n    total_woba_value = sum(woba_value, na.rm=TRUE),\n    total_woba_denom = sum(woba_denom, na.rm=TRUE),\n    team_wOBA = ifelse(total_woba_denom == 0, NA,\n                       total_woba_value / total_woba_denom),\n    .groups=\"drop\"\n  ) %&gt;%\n  select(-total_woba_value, -total_woba_denom) %&gt;%\n  arrange(desc(team_wOBA))\n\n\nThis list seems to make sense and is in line with overall 2024 data. Typically, woba_denom is 1 for outcomes like walks, hit-by-pitch, or batted-ball events. For sacrifice flies or other rare events, it can vary slightly. The sum of woba_denom for a team is essentially the sum of PAs used in the wOBA formula (excluding some events like catcher interference or maybe intentionals, depending on how MLBAM codes them). So, its sum is essentially ‚Äúthe count of wOBA-relevant plate appearances‚Äù.\n\n\nShow Code\nanalysis_df &lt;- team_diversity %&gt;%\n  left_join(team_woba,  by=\"batter_team\")\n\n\nWe can also calculate xwOBA for each team. xwOBA is a more advanced metric that uses exit velocity and launch angle to estimate the expected wOBA for each batted ball. We will use the estimated_woba_using_speedangle column in pitches to calculate xwOBA for each batted-ball plate appearance, then account for walks, hit-by-pitches, etc. We will then calculate the average xwOBA for each team.\n\n\nShow Code\nfinal_pitches_xwoba &lt;- final_pitches %&gt;%\n  filter(!is.na(estimated_woba_using_speedangle)) %&gt;%\n  mutate(\n    xWOBA_value = estimated_woba_using_speedangle,\n    xWOBA_denom = 1\n  )\n\n\n\n\nShow Code\nteam_xwoba &lt;- final_pitches_xwoba %&gt;%\n  group_by(batter_team) %&gt;%\n  summarise(\n    total_xwoba_value = sum(xWOBA_value, na.rm=TRUE),\n    total_xwoba_denom = sum(xWOBA_denom, na.rm=TRUE),\n    team_xwOBA = ifelse(total_xwoba_denom == 0, NA,\n                        total_xwoba_value / total_xwoba_denom),\n    .groups=\"drop\"\n  ) %&gt;%\n  select(-total_xwoba_value, -total_xwoba_denom) %&gt;%\n  arrange(desc(team_xwOBA))\n\n\nThis also seems to make sense and is in line with overall 2024 data.\n\n\nShow Code\nanalysis_df &lt;- analysis_df %&gt;%\n  left_join(team_xwoba, by=\"batter_team\")\n\n\n\n\n\n\nShow Code\nggplot(analysis_df, aes(x=team_sd_mean_bat_speed, y=team_wOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Speed Diversity vs. Team wOBA\",\n    x=\"Team SD of Mean Bat Speed\",\n    y=\"Team wOBA\"\n  )+\n  theme_pub()+\n  ## Add trendline\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\nLet‚Äôs create a linear model to see if there is a significant relationship between team swing speed diversity and team wOBA.\n\n\nShow Code\nlm_woba &lt;- lm(team_wOBA ~ team_sd_mean_bat_speed, data=analysis_df)\nsummary(lm_woba)\n\n\nIn this linear model, we get a negative Adjusted R-squared, signalling that there‚Äôs almost no linear relationship‚Äîin other words, once the penalty for adding a predictor is applied, the model explains less variance than just using the mean. The p-value is 0.341, which is insignificant at the 0.05 level. This suggests that there is no significant relationship between team swing speed diversity and team wOBA.\nLet‚Äôs also check the relationship between team swing speed diversity and team xwOBA.\n\n\nShow Code\nggplot(analysis_df, aes(x=team_sd_mean_bat_speed, y=team_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Speed Diversity vs. Team xwOBA\",\n    x=\"Team SD of Mean Bat Speed\",\n    y=\"Team xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\n\n\nShow Code\nlm_xwoba &lt;- lm(team_xwOBA ~ team_sd_mean_bat_speed, data=analysis_df)\nsummary(lm_xwoba)\n\n\nThe Adjusted R-Squared for this model is positive, and the p-value of team-level bat speed diversity has gone down to 0.177. It is possible that with more data from other seasons, we would be able to see more signficiant relationships between team-level bat speed diversity and team xwOBA.\nHowever, at this point, it is worth noting that our data is pointing to the possibility of a relationship, even if it is small, between team-level bat speed diversity and team xwOBA. This is worth more exploration.\nLet‚Äôs do the same for swing length.\n\n\n\n\n\nShow Code\nggplot(analysis_df, aes(x=team_sd_mean_swing_length, y=team_wOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Length Diversity vs. Team wOBA\",\n    x=\"Team SD of Mean Swing Length\",\n    y=\"Team wOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\n\n\nShow Code\nlm_woba &lt;- lm(team_wOBA ~ team_sd_mean_swing_length, data=analysis_df)\nsummary(lm_woba)\n\n\nThe Adjusted R-squared for swing length is also negative, and the p-value is 0.823, which is insignificant at the 0.05 level. This suggests that there is no significant relationship between team swing length diversity and team wOBA.\nLet‚Äôs also check the relationship between team swing length diversity and team xwOBA.\n\n\nShow Code\nggplot(analysis_df, aes(x=team_sd_mean_swing_length, y=team_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Length Diversity vs. Team xwOBA\",\n    x=\"Team SD of Mean Swing Length\",\n    y=\"Team xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\n\n\nShow Code\nlm_xwoba &lt;- lm(team_xwOBA ~ team_sd_mean_swing_length, data=analysis_df)\nsummary(lm_xwoba)\n\n\nAgain, our Adjusted R-Squared is negative, and the p-value of the team-level swing length diversity is 0.367. This suggests that there is no significant relationship between team swing length diversity and team xwOBA.\nIn conclusion, we have found that there is no significant relationship between team swing length diversity and team wOBA or xwOBA. This suggests that having a variety of average swing length characteristics across players on the roster does not help or hurt scoring.\nIt is worth noting that our xwOBA data seems to point towards stronger relationships than our wOBA data. In theory, xwOBA is a more trustworthy measure of offensive production, because it looks to eliminate the noise of defense and luck. Sometimes including both together‚Äîor creating a combined 2D measure‚Äîcan reveal patterns not evident in either metric separately.\nPerhaps the simplest approach is to include both predictors in the same linear model as a multiple regression model.\n\n\n\n\n\n\nIf team_sd_mean_swing_length was ‚Äúuseless‚Äù by itself, it could still contribute additional explanatory power in the presence of team_sd_mean_bat_speed. For example, maybe a team with both high bat‚Äêspeed diversity and high swing‚Äêlength diversity has synergy (or a deficiency).\n\n\nShow Code\n# Using wOBA\nmod_multi &lt;- lm(team_wOBA ~ team_sd_mean_bat_speed + team_sd_mean_swing_length,\n                data = analysis_df)\nsummary(mod_multi)\n# Using xWOBA\nmod_multi &lt;- lm(team_xwOBA ~ team_sd_mean_bat_speed + team_sd_mean_swing_length,\n                data = analysis_df)\nsummary(mod_multi)\n\n\nThe Adjusted R-Squared for both models are negative, suggesting that while team-level bat speed variation may help explain between-team variation in xWOBA, a combined model with swing length is not providing any explanation for the variation in xWOBA or wOBA. In both models, the p-values for both predictors are also insignificant at the 0.05 level.\nIt is worth noting that other models with interaction and transformed predictors were considered, though nothing yielded a realistic and suitable result.\nGiven that all of this data analysis was done on 30 data points (30 teams), we would like to consider a team‚Äôs wOBA and xWOBA for each game.\nTakeaway #1: Having a variety of swing speeds on a roster could correlate with expected scoring statistics for a team over a season, but a variety of swing lengths does not.\n\n\n\n\nIn this model, we can incorporate situational or day‚Äêto‚Äêday changes in the team‚Äôs lineup (maybe a star was resting, or they traded for a new hitter mid‚Äêseason). We will want to compute each team‚Äôs in‚Äêgame diversity of swing speed and swing length weighted by plate appearances, then comparing that to the team‚Äôs in‚Äêgame wOBA and xwOBA.\nFirst, we group by (game_pk, batter_team, batter) to compute the mean and median for each player in that game. We also count how many plate appearances that batter had in that game.\n\n\nShow Code\npitches = read.csv(\"data/statcast_data.csv\")\n\npitches &lt;- pitches %&gt;%\n  mutate(\n    PA_id = paste(game_pk, at_bat_number, sep=\"_\"),\n    batter_team = ifelse(inning_topbot == \"Bot\", home_team, away_team)\n  )\n\nplayer_game_allPA &lt;- pitches %&gt;%\n  group_by(game_pk, batter, batter_team) %&gt;%\n  summarise(\n    total_pa_game = n_distinct(PA_id),    # all PAs in that game for that batter\n    .groups = \"drop\"\n  )\n\n# Subset to actual swings\nbatter_game_swings &lt;- pitches %&gt;%\n  filter(!is.na(bat_speed), !is.na(swing_length)) %&gt;%\n  group_by(game_pk, batter, batter_team) %&gt;%\n  summarise(\n    # mean & median for the swings that occurred\n    game_median_bat_speed    = median(bat_speed, na.rm=TRUE),\n    game_median_swing_length = median(swing_length, na.rm=TRUE),\n    .groups=\"drop\"\n  )\n\n\nFinally, we do a left_join so that every (game, batter, team) from player_game_allPA is preserved‚Äîeven if the player never swung:\n\n\nShow Code\nbatter_game_stats &lt;- player_game_allPA %&gt;%\n  left_join(batter_game_swings,\n            by = c(\"game_pk\", \"batter\", \"batter_team\"))\n\n\nSome batters (especially if they only had one PA) might have 0 swings and thus NA data for the swing columns. That is okay, as they will not effect our weighted standard deviations.\nNow, let‚Äôs get our team-level game-by-game diversity of swing speed and swing length. We will use the same weighted standard deviation formula as before, but this time we will use the game_mean_bat_speed and game_mean_swing_length columns.\n\n\nShow Code\nteam_game_diversity &lt;- batter_game_stats %&gt;%\n  group_by(game_pk, batter_team) %&gt;%\n  summarise(\n    # Weighted SD of each player's median (bat_speed)\n    game_sd_median_bat_speed = weighted_sd(game_median_bat_speed, total_pa_game),\n\n    # Weighted SD of each player's median (swing_length)\n    game_sd_median_swing_length = weighted_sd(game_median_swing_length, total_pa_game),\n    \n    .groups = \"drop\"\n  )\n\n\nNow each row in team_game_diversity is a single (game_pk, batter_team) with four different ‚Äúdiversity‚Äù metrics (two based on mean, two based on median).\nNext, we will compute game-level xWOBA and wOBA for each team. We will use the same formula as before, but this time we will use the woba_value and woba_denom columns in pitches to calculate wOBA for each plate appearance. We will then calculate the average wOBA for each team.\n\n\nShow Code\ngame_woba &lt;- final_pitches_clean %&gt;%\n  group_by(game_pk, batter_team) %&gt;%\n  summarise(\n    total_woba_val   = sum(woba_value, na.rm=TRUE),\n    total_woba_denom = sum(woba_denom, na.rm=TRUE),\n    game_wOBA = ifelse(total_woba_denom == 0, NA,\n                       total_woba_val / total_woba_denom),\n    .groups=\"drop\"\n  ) %&gt;%\n  select(game_pk, batter_team, game_wOBA)\n\ngame_xwoba &lt;- final_pitches_xwoba %&gt;%\n  group_by(game_pk, batter_team) %&gt;%\n  summarise(\n    total_xwoba_value   = sum(xWOBA_value, na.rm=TRUE),\n    total_xwoba_denom = sum(xWOBA_denom, na.rm=TRUE),\n    game_xwOBA = ifelse(total_xwoba_denom == 0, NA,\n                        total_xwoba_value / total_xwoba_denom),\n    .groups=\"drop\"\n  ) %&gt;%\n  select(game_pk, batter_team, game_xwOBA)\n\n\nNow, combine into an analysis dataframe:\n\n\nShow Code\nanalysis_game_df &lt;- team_game_diversity %&gt;%\n  left_join(game_woba, by=c(\"game_pk\", \"batter_team\"))\n\nanalysis_game_df &lt;- analysis_game_df %&gt;%\n  left_join(game_xwoba, by=c(\"game_pk\",\"batter_team\"))\n\n\nLet‚Äôs make our models for swing length:\n\n\nShow Code\n# Median-based statistics\nmedian_woba_swing_length_model &lt;- lm(game_wOBA ~ game_sd_median_swing_length,\n                    data=analysis_game_df)\nsummary(median_woba_swing_length_model)\n\nmedian_xwoba_swing_length_model &lt;- lm(game_xwOBA ~ game_sd_median_swing_length,\n                    data=analysis_game_df)\nsummary(median_xwoba_swing_length_model)\n\n\nWe tried out both mean and median-based models to ensure that outliers in the data were not influencing individual player‚Äôs swing data. However, the mean-based and median-based models are showing similar results. Thus, we are going to graph just median-based results, as they are much more signficiant. These four models are all interesting though, with significant p-values for all coefficients of team swing length diversity, and positive Adjusted R-Squared values, even if incredibly small, for all models.\nThe coefficients for team swing length diversity are all negative, suggesting that on a game-by-game basis, a more consistent swing length is correlated with better offensive production. The p-values are all significant at the 0.05 level, suggesting that there is a significant relationship between team swing length diversity and team wOBA and xwOBA. The Adjusted R-Squared values are all positive, suggesting that the models explain some variance in team wOBA and xwOBA.\nThis finding is interesting, as it could point to a number of things: - Consistent team-wide swing length approaches might be best for scoring - Our team-by-team data might simply have not had enough sample size to find significant correlations\nOne possible explanation: The teams with the best scouting and analytics can prepare their players similarly for a particular game, allowing them to capitalize on the opponents‚Äô weaknesses or particular ballpark-related advantages.\nLet‚Äôs make our models for bat speed:\n\n\nShow Code\n# Median-based statistics\nmedian_woba_bat_speed_model &lt;- lm(game_wOBA ~ game_sd_median_bat_speed,\n                    data=analysis_game_df)\nsummary(median_woba_bat_speed_model)\n\nmedian_xwoba_bat_speed_model &lt;- lm(game_xwOBA ~ game_sd_median_bat_speed,\n                    data=analysis_game_df)\nsummary(median_xwoba_bat_speed_model)\n\n\nIn all models except 1, we got both a negative Adjusted R-Squared and an insignifcant sign of the coefficient. In our model of game-level team bat speed diversity with wOBA, we got a positive Adjusted R-Squared, but the p-value of the coefficient is insignificant at the 0.05 level, and it does not line up with the model using xWOBA, and thus, I will ignore it as likely due to random chance. This suggests that on a game-by-game basis, consistency in a team‚Äôs bat speed does not correlate positively or negatively with increased scoring.\nThis inversion from our potential correlations in team-level bat speed diversity and team xwOBA is interesting.\nOne possible explanation: Throughout a season, a team that has a variety of bat speeds can more easily adapt to the many pitchers they face. In one particular game, a team‚Äôs variety of bat speeds does not prove useful when they may only face two or three pitchers, provided that the starter pitches for a large portion of the game.\nLet‚Äôs graph these scenarios, using the median variation values and xWOBA:\n\n\nShow Code\nggplot(analysis_game_df, aes(x=game_sd_median_swing_length, y=game_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Length Diversity vs. Team xwOBA\",\n    x=\"Game SD of Median Swing Length\",\n    y=\"Game xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\nggplot(analysis_game_df, aes(x=game_sd_median_bat_speed, y=game_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Team Swing Speed Diversity vs. Team xwOBA\",\n    x=\"Game SD of Median Bat Speed\",\n    y=\"Game xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\nTakeaway #2: On a game-by-game basis, a team‚Äôs swing length consistency is correlated with better offensive production, while a team‚Äôs bat speed consistency is not.\nThinking about Takeaways 1 and 2 together, it is possible that a team‚Äôs swing length consistency in a particular game points to the idea that they have prepared for a particular set of pitchers well and are able to achieve similar swing lengths to best capitalize on the attributes of the opposing pitchers or of the ballpark. However, over an entire season, it could be advantageous to have a variety of swing speeds on a roster to be able to attack the wide variety of pitchers faced, while optimal swing lengths average out over a long season and many pitchers. It is possible that swing lengths are easier to fluctuate on a per-game basis, but swing speeds are more difficult to change, thus a variety is needed on a roster.\n\n\nLet‚Äôs also try one multivariate model to see if we can find a relationship between swing style consistency and xwOBA.\n\n\nShow Code\nmod_multi &lt;- lm(game_xwOBA ~ game_sd_median_bat_speed + game_sd_median_swing_length,\n                data = analysis_game_df)\nsummary(mod_multi)\n\n\nIn this model, both bat speed and swing length are significant at the 0.05 level, and the Adjusted R-Squared is positive. This suggests that there is a significant relationship between team swing length and bat speed consistency and team xwOBA on a game-by-game basis.\nThis suggests that, holding swing length diversity constant, having a range of bat speeds within the lineup may help on a game-by-game basis. It could allow the team to adapt to differing pitch velocities and styles from the opposing pitchers.\nMeanwhile, holding bat speed diversity constant, a more consistent (less diverse) swing length appears beneficial. If everyone‚Äôs length is dialed in for that day‚Äôs pitcher(s), the team might more efficiently square up pitches or stay in the optimal ‚Äúcontact window.‚Äù\nOn a single‚Äêgame basis, these results indicate that a consistent swing length is linked to better offensive output, while some diversity in bat speed can be helpful. This aligns with the idea that hitters can unify their swing lengths to match that day‚Äôs pitchers and still bring different swing speeds to handle velocity changes or relief pitchers.\nOne possible explanation: For a particular game, a team‚Äôs swing length helps them better adjust for ballpark dimensions or aspects of the weather/environment, but a team‚Äôs bat speed diversity helps them adjust to the variety of pitchers they face.\n\n\n\n\nNow, we‚Äôd like to ask whether on a player-by-player basis, does a player‚Äôs swing consistency during a season correlate with success at the plate? We will use the same weighted standard deviation formula as before, but this time we will use the player‚Äôs mean swing length and bat speed for the season. Asked another way: Does having a consistent swing over a season correlate with a particular player generating offense.\n\n\nShow Code\npitches &lt;- pitches %&gt;%\n  mutate(\n    PA_id = paste(game_pk, at_bat_number, sep=\"_\"),\n    batter_team = ifelse(inning_topbot == \"Bot\", home_team, away_team)\n  )\n\nplayer_swing_consistency &lt;- pitches %&gt;%\n  filter(!is.na(swing_length), !is.na(bat_speed)) %&gt;%\n  group_by(batter) %&gt;%\n  summarise(\n    # Season-long means\n    mean_swing_length = mean(swing_length, na.rm=TRUE),\n    mean_bat_speed    = mean(bat_speed, na.rm=TRUE),\n    # Season-long standard deviations\n    sd_swing_length = sd(swing_length, na.rm=TRUE),\n    sd_bat_speed    = sd(bat_speed, na.rm=TRUE),\n    .groups = \"drop\"\n  )\n\n## Take out players with NA standard deviation\nplayer_swing_consistency &lt;- player_swing_consistency %&gt;%\n  filter(!is.na(sd_swing_length), !is.na(sd_bat_speed))\n\n\nThis gives us one row per batter, capturing that player‚Äôs overall pitch-to-pitch variation in swing metrics across the entire season.\nNow, let‚Äôs calculate xWOBA for all players over the season.\n\n\nShow Code\n# We'll define \"final pitch\" as the last pitch_number in that (game_pk, at_bat_number)\nfinal_pitches &lt;- pitches %&gt;%\n  group_by(game_pk, at_bat_number) %&gt;%\n  slice_max(order_by = pitch_number, n = 1) %&gt;%\n  ungroup()\n\nfinal_pitches_xwoba &lt;- final_pitches %&gt;%\n  filter(!is.na(estimated_woba_using_speedangle)) %&gt;%\n  mutate(\n    xWOBA_value = estimated_woba_using_speedangle,\n    xWOBA_denom = 1\n  )\n\nplayer_xwoba &lt;- final_pitches_xwoba %&gt;%\n  group_by(batter) %&gt;%\n  summarise(\n    total_xwoba_value = sum(xWOBA_value, na.rm=TRUE),\n    total_xwoba_denom = sum(xWOBA_denom, na.rm=TRUE),\n    player_xwOBA = ifelse(total_xwoba_denom == 0, NA,\n                          total_xwoba_value / total_xwoba_denom),\n    .groups=\"drop\"\n  ) %&gt;%\n  select(batter, player_xwOBA)\n\n\nNow, combine into an analysis dataframe:\n\n\nShow Code\nplayer_analysis_df &lt;- player_swing_consistency %&gt;%\n  left_join(player_xwoba, by=\"batter\")\n\n\nLet‚Äôs graph these scenarios, using the median variation values and xWOBA:\n\n\nShow Code\nggplot(player_analysis_df, aes(x=sd_swing_length, y=player_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Player Swing Length Consistency vs. Player xwOBA\",\n    x=\"Player SD of Swing Length\",\n    y=\"Player xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\nggplot(player_analysis_df, aes(x=sd_bat_speed, y=player_xwOBA)) +\n  geom_point() +\n  labs(\n    title=\"Player Bat Speed Consistency vs. Player xwOBA\",\n    x=\"Player SD of Bat Speed\",\n    y=\"Player xwOBA\"\n  )+\n  theme_pub()+\n  geom_smooth(method=\"lm\", se=TRUE)\n\n\nLet‚Äôs also create linear models to see if there is a significant relationship between player swing consistency and player xwOBA.\n\n\nShow Code\nmodel_sd_swing_length &lt;- lm(player_xwOBA ~ mean_swing_length + sd_swing_length, data=player_analysis_df)\nsummary(model_sd_swing_length)\n\nmodel_sd_bat_speed &lt;- lm(player_xwOBA ~ mean_bat_speed + sd_bat_speed, data=player_analysis_df)\nsummary(model_sd_bat_speed)\n\n\nIn both models, the Adjusted R-Squared is positive, and the p-value of the coefficient is significant at the 0.05 level. This suggests that there is a significant relationship between player swing consistency and player xwOBA for both swing length and bat speed. The coefficients are negative, suggesting that a more consistent swing length and bat speed is correlated with better offensive production. This likely points to the idea that the best hitters have found optimal swing lengths and bat speeds, and while they will likely slightly deviate from them to better match the pitcher, they have less reason to adjust over the entire season. Worse hitters need to continuously adjust their swings over the season in searching for their best swing type.\n\n\nLet‚Äôs also try one multivariate model to see if we can find a relationship between player swing consistency and xwOBA.\n\n\nShow Code\nmod_multi &lt;- lm(player_xwOBA ~ mean_swing_length + mean_bat_speed + sd_swing_length + sd_bat_speed,\n                data = player_analysis_df)\nsummary(mod_multi)\n\nlibrary(car)\nvif(mod_multi)\n\n## Show collinearity between predictors\ncor(player_analysis_df$sd_swing_length, player_analysis_df$sd_bat_speed)\ncor(player_analysis_df$mean_swing_length, player_analysis_df$mean_bat_speed)\ncor(player_analysis_df$mean_swing_length, player_analysis_df$sd_swing_length)\ncor(player_analysis_df$mean_bat_speed, player_analysis_df$sd_bat_speed)\n\n\nAlthough our VIF values are all less than 5, suggesting that multicollinearity is likely not a problem and just a result of using real imperfect data, we can try to create a ‚Äúmechanical variability‚Äù combined component using Principal Components Analysis to combine the two predictors into one.\n\n\nShow Code\n# Step 1: Standardize variables\nplayer_analysis_df &lt;- player_analysis_df %&gt;%\n  mutate(\n    sd_swing_length_scaled = scale(sd_swing_length),\n    sd_bat_speed_scaled = scale(sd_bat_speed)\n  )\n\n# Step 2: Perform PCA\npca_model &lt;- prcomp(player_analysis_df[, c(\"sd_swing_length_scaled\", \"sd_bat_speed_scaled\")],\n                    center = TRUE, scale. = TRUE)\n\n# Step 3: Add first principal component to the dataset\nplayer_analysis_df &lt;- player_analysis_df %&gt;%\n  mutate(mechanical_variability = pca_model$x[, 1])\n\n# Check PCA results\nsummary(pca_model)\n\n\n\n\nShow Code\nmodel &lt;- lm(player_xwOBA ~ mean_swing_length + mean_bat_speed + mechanical_variability,\n            data = player_analysis_df)\nsummary(model)\n\nvif(model)\n\n\nOur VIFs are again under 5, signalling that this is a good model.\nTakeaway #3: On a player-by-player basis, a player‚Äôs swing consistency is correlated with better offensive production. This is likely because the best players have found their optimal swing lengths and bat speeds, and while they will slightly deviate from them to better match the pitcher, they have less reason to adjust over the entire season. Worse hitters need to continuously adjust their swings over the season in searching for their best swing type."
  },
  {
    "objectID": "posts/blog-2-swing-profiles/index.html#references",
    "href": "posts/blog-2-swing-profiles/index.html#references",
    "title": "Blog Post #2: Swing Profiles",
    "section": "",
    "text": "Dudzinski,¬†R. (2025, January 30). The data is in from MLB‚Äî swing hard, just in case you hit it. Medium. https://medium.com/@robbiedudz34/the-data-is-in-from-mlb-swing-hard-just-in-case-you-hit-it-220cae1af5ca\nFast-swing rate. (n.d.). MLB.com. https://www.mlb.com/glossary/statcast/fast-swing-rate\nLambert,¬†J. (2024, August 1). Using MLB bat tracking data to better understand swings. Driveline Baseball. https://www.drivelinebaseball.com/2024/07/using-mlb-bat-tracking-data-to-better-understand-swings/?srsltid=AfmBOopwi5JuXS1YWSWq4ny_NNrcHio0S1pASMeH0vXtOY1mZug93TOx\nPassan,¬†J. (2024, May 13). Passan: The five biggest takeaways from Statcast‚Äôs swing-tracking data. ESPN.com. https://www.espn.com/mlb/story/_/id/40120458/mlb-statcast-bat-tracking-data-giancarlo-stanton-luis-arraez\nSwing length. (n.d.). MLB.com. https://www.mlb.com/glossary/statcast/swing-length"
  },
  {
    "objectID": "posts/blog-5-lineup-simulation/index.html#introduction",
    "href": "posts/blog-5-lineup-simulation/index.html#introduction",
    "title": "Blog Post #5: Lineup Simulations",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "posts/blog-5-lineup-simulation/index.html#aim",
    "href": "posts/blog-5-lineup-simulation/index.html#aim",
    "title": "Blog Post #5: Lineup Simulations",
    "section": "Aim",
    "text": "Aim"
  },
  {
    "objectID": "posts/blog-5-lineup-simulation/index.html#setup",
    "href": "posts/blog-5-lineup-simulation/index.html#setup",
    "title": "Blog Post #5: Lineup Simulations",
    "section": "Setup",
    "text": "Setup"
  },
  {
    "objectID": "posts/blog-5-lineup-simulation/index.html#methods",
    "href": "posts/blog-5-lineup-simulation/index.html#methods",
    "title": "Blog Post #5: Lineup Simulations",
    "section": "Methods",
    "text": "Methods"
  },
  {
    "objectID": "posts/blog-5-lineup-simulation/index.html#analysis",
    "href": "posts/blog-5-lineup-simulation/index.html#analysis",
    "title": "Blog Post #5: Lineup Simulations",
    "section": "Analysis",
    "text": "Analysis"
  },
  {
    "objectID": "posts/blog-5-lineup-simulation/index.html#visualizations",
    "href": "posts/blog-5-lineup-simulation/index.html#visualizations",
    "title": "Blog Post #5: Lineup Simulations",
    "section": "Visualizations",
    "text": "Visualizations"
  },
  {
    "objectID": "posts/blog-5-lineup-simulation/index.html#discussion",
    "href": "posts/blog-5-lineup-simulation/index.html#discussion",
    "title": "Blog Post #5: Lineup Simulations",
    "section": "Discussion",
    "text": "Discussion"
  },
  {
    "objectID": "posts/blog-5-lineup-simulation/index.html#references",
    "href": "posts/blog-5-lineup-simulation/index.html#references",
    "title": "Blog Post #5: Lineup Simulations",
    "section": "References",
    "text": "References"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to Lance‚Äôs Lineups ‚öæ",
    "section": "",
    "text": "I‚Äôm Lance Brady, a senior at Yale University majoring in Statistics & Data Science.\nFor my senior thesis, I‚Äôm exploring baseball lineup optimization using data-driven methods.\nHere are some of my articles and thoughts on lineup optimization!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBlog Post #5: Lineup Simulations\n\n\n\n\n\n\nsimulation\n\n\nlineups\n\n\nstatcast\n\n\n\n\n\n\n\n\n\nApr 16, 2025\n\n\nLance Brady\n\n\n\n\n\n\n\n\n\n\n\n\nBlog Post #4: Quantitative Analysis of Protection\n\n\n\n\n\n\nanalysis\n\n\nlineups\n\n\nstatcast\n\n\n\n\n\n\n\n\n\nApr 16, 2025\n\n\nLance Brady\n\n\n\n\n\n\n\n\n\n\n\n\nBlog Post #3: Baserunning\n\n\n\n\n\n\nbaserunning\n\n\nlineups\n\n\nstatcast\n\n\n\n\n\n\n\n\n\nMar 5, 2025\n\n\nLance Brady\n\n\n\n\n\n\n\n\n\n\n\n\nBlog Post #2: Swing Profiles\n\n\n\n\n\n\nswing profiles\n\n\nlineups\n\n\nstatcast\n\n\n\n\n\n\n\n\n\nFeb 26, 2025\n\n\nLance Brady\n\n\n\n\n\n\n\n\n\n\n\n\nBlog Post #1: Lineup Protection or Lineup Penalty?\n\n\n\n\n\n\nlineup protection\n\n\nlineups\n\n\nstatcast\n\n\n\n\n\n\n\n\n\nFeb 18, 2025\n\n\nLance Brady\n\n\n\n\n\n\nNo matching items"
  }
]