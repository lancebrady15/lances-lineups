---
title: "Blog Post #1: Lineup Protection"
author: "Lance Brady"
date: "2025-02-18"
categories: [lineup protection, lineups, statcast]
format: html
editor: visual
image: blog1.jpg
---

## Introduction to Lineup Protection

Batting order optimization is a heavily studied aspect of baseball decision-making, where teams construct lineups to maximize run production. Most studies in this area assume that hitters in the lineup are independent of one another. However, the concept of lineup protection—the idea that a hitter’s performance is influenced by the quality of the hitter after them—remains debated within the sabermetrics community, most often not believed in by it; it has not been supported by previous statistical studies. Although batting order decisions may offer only marginal advantages in expected runs, in an era where every competitive edge counts, even subtle effects like lineup protection deserve closer examination. The theory behind lineup protection is that a hitter with a good hitter behind them will be harder to pitch around because pitchers won't want to face the guy after him either, particularly with more runners on base. Thus, walks would decrease, and that would mean more fastballs, strikes, and pitches over the plate, essentially increasing the probability for productive hitting, specifically extra-base hits (doubles, triples, and homeruns).

There are two main ways to study lineup protection:

**Pitcher-Centric Analysis:** Examining how pitchers alter their approach based on the quality next hitter. Previous research using 30 hitter pairs since the advent of Statcast suggested that protected hitters see an average of 0.25% more strikes compared to league average, and 0.07% more pitches down the middle of the zone. This would lead to 6 additional strikes and 2 additional pitches down the middle over a season. This study was extremely limited, however, and did not account for situations without protection, only used 30 pairs of hitters, and only compared the strike percentage a protected hitter received to the league average of that year, not to the strike percentage they had in other non-protected plate appearances. If lineup protection were to exist, teams should avoid wasting lineup protection on free swingers (putting free swingers before "protectors") so that the protection is not wasted on hitters who would swing at a higher rate anyway (The Paraball Notes, 2024). Quantitatively, the hitter who bats behind you SHOULD impact the pitches you see, because the run expectancy of certain plays occurring (like walks) would change based on who the following batter is (Weinberg, 2013). Evidence of certain pairs often seems to point to the opposite, with a 2012 evaluation of players hitting after Andrew McCutchen, Ryan Braun, and Joey Votto showing no evidence that pitchers were pitching them differently based on the protection they had (Cameron, 2012).

Hall of Famer Miguel Cabrera attributed part of his power struggles early in the 2019 season to a lack of lineup protection, essentially calling out productive-yet-not-spectacular hitter behind him, Niko Goodrum, saying, "In the past... I got a big bat behind me. You see the way guys pitch me? that explains everything." His manager responded by saying his statement was "crazy." Data revealed that he wasn't getting particularly fewer fastballs, strikes, or good pitches to hit in general, and that in his particular case, there wasn't evidence for lineup protection (Stavenhagen, 2019).

**Hitter Outcome Analysis:** Investigating whether the quality of the next hitter influences the current hitter’s performance. Pre-Pitch F/X research found that pitchers who know that a good hitter is up next will "pitch around" the current hitter, resulting in significantly more walks, and moderately more strikeouts. However, it found that when it comes to putting the ball in play, there was no significant impact (Tango, 2006). Much of the sabermetric community says that lineup protection is a myth, and that a player's production is almost solely determined by their own skills; luck and random variation also play a small role (Ambrosino, 2011). A 2008 study found that with a small magnitude, the quality of the on-deck hitter negatively impacts the preceding hitter (Bradbury, 2008).

However, a study in 2011 using Retrosheet play-by-play data from 2002-2009 MLB seasons found that power numbers did have significant differences in situations of potential lineup protection. This study argues that previous evidence of lineup protection was not uncovered because endogeneity bias introduced by managers selectively choosing their lineups. For a player's own performance, they likely are hitting better than their own season averages when they are near the top of the lineup (they have more protection) because they are already doing well at that time for a number of reasons. A good hitter who, for whatever reason, is hitting poorly will be put at the bottom of the lineup (and have less protection), but likely hit well at that spot, and thus, we would observe better hitting with less protection. Thus, protection and performance numbers become tangled in unobservable ways.

Using injuries to a batter’s “protector” as a quasi-random natural experiment, this study finds that batters who have stronger protection (i.e., a higher OPS hitter behind them) produce significantly more power. Specifically, a 100-point increase in the protector’s OPS correlates with a 9.7% rise in extra-base hits, and the effect is especially pronounced for third hitters (a 26% increase). The results also suggest that when left unprotected, batters draw more walks—particularly intentional walks, as previous literature has supported (Phillips, 2011). It also found that hits in general remained unchanged with protection or not, suggesting that batters are not simply putting the ball into play fewer times, but having less powerful, and thus, productive, contact. However, this study simply made claims about the distribution of outcomes and not about overall offensive production. Protected hitters got fewer walks and more extra-base hits, which act in opposing manners. Our study will use Expected Weighted On-Base Average, an offensive statistic that correlates directly with a player's overall contribution to run production from the plate, to tackle this gap in research.

Most other previous literature of hitter outcome analysis has been rather anecdotal, focusing on specific players and how they fare with protection. Using over 3000 Plate Appearances from Pete Alonso's career before his 2024 season, we can see higher slugging percentages with better hitters behind him, along with being 11% more likely to homer. With worse protection, he is more likely to walk, although his strikeout rates go against previous research and actually decrease with poor hitters behind him (Britton, 2024). Other research takes specific teams and analyzes whether the topic of lineup protection even applies and whether it serves a purpose in that roster's decision-making. When the Diamondbacks acquired Mark Trumbo in 2014, writers brought up the fact that even though Trumbo's power threat could serve to protect Paul Goldschmidt, Trumbo may not even be much better than other Diamondbacks hitters who could replace him in terms of offensive threat in general (Wiser, 2014). In 2015, Billy Hamilton pointed to a different sort of offensive advantage owing to the hitter behind him–knowing Joey Votto was hitting after him, an incredibly selective hitter often with long counts, allowed Hamilton to be patient and wait for the right pitch to steal on. In this situation, with a small sample size, the threat of Votto was preventing opposing pitchers from throwing fastballs with Hamilton on base, allowing Hamilton to get better base-stealing opportunities (Petriello, 2015).

It is worth noting that many within baseball discuss lineup protection with certainty. Alonso had pushed for J.D. Martinez to join and hit behind him for the Mets in 2024, hoping it would help his offensive statistics. Interviews with several within the game in 2015 resulted in a plethora of answers, from Joe Girardi saying lineup protection was most significant in lefty-righty matchups, Madison Bumgarner saying he doesn't pay attention to the on-deck circle, Tim Hudson saying that it's "foolish if you don't look at the next hitter," and multiple other pitchers saying it is a factor in their decision-making, especially later in the game (Laurila, 2016).

It is also worth noting that these anecdotal examinations are subject to sample size constraints and extremely limited in their ability to observe lineup protection on a large scale in Major League Baseball. This article aims to tackle that problem.

## Aim

This article aims to provide further insights into lineup protection using pitch-by-pitch data Statcast data from the 2015 to 2024 Major League Baseball seasons, focusing on analyzing hitter outcomes. While literature is mixed and often negative on the existence of lineup protection, it often uses anecdotal evidence, and a more thorough investigation is necessary, especially one using the more advanced expected statistics we now have available.

## Setup

We would like our independent variables to be the following:

-   Current pitcher random effects

-   Current hitter's handedness and underlying quality (xwOBA)

-   Next hitter's handedness and underlying quality (xwOBA)

-   Base-out state

-   Inning

-   Run differential

Previous studies have looked at protection as a binary independent variable, but that is a narrow view on lineup protection. Lineup protection must be considered as a continuous variable because some players will protect more than others.

Our outcome variable for our first model will be that plate appearance's xwOBA, which will essentially give us the quality of that plate appearance based on the independent variables. We would then like to see what factor the quality of the next batter has in the outcome.

We will use a mixed-effects linear model to account for the random effects of pitchers and batters. Our models are described in detail below.

## Methods

First, we loaded in our libraries and read the data, which contains almost every pitch from the 2024 season (excluding when poor data was retrieved).

```{r}
#| echo: false
#| output: false

library(tidyverse)
library(lme4)
library(lmerTest)
library(ggeffects)
library(car)
library(pubtheme)
library(baseballr)
```

```{r}
statcast_data <- readRDS("data/statcast_all_years.rds")
```

For each plate appearance, we aggregate key variables. In this code, each plate appearance is identified by grouping on `game_pk` and `at_bat_number`, then we take the last pitch (using `which.max(pitch_number)`) to define final values for fields like `pa_xwOBA`, `pa_xBA`, and `pa_woba`. Specifically, `pa_xwOBA` is assigned the value from `estimated_woba_using_speedangle` on the last pitch, and similarly `pa_xBA` comes from `estimated_ba_using_speedangle`. We also create `pa_BA` as `1` if the `final_event` is `"single"`, `"double"`, `"triple"`, or `"home_run"`, and `pa_SLG` by mapping those same events to `1`, `2`, `3`, or `4` respectively. We compute `pitches_per_pa` via `n()`, reflecting how many pitches occurred in each plate appearance. Furthermore, we define `is_extra_base_hit` if `final_event` is `"double"`, `"triple"`, or `"home_run"`, `is_walk` if the `final_event` is `"walk"` or `"intent_walk"`, and `is_strikeout` if the `final_event` is `"strikeout"` or `"strikeout_double_play"`. Finally, the code calculates `run_diff` as the difference between `bat_score` and `fld_score` on the last pitch, capturing the score differential before the plate appearance’s outcome is officially applied.

```{r}
pa_data <- statcast_data %>%
  group_by(game_pk, at_bat_number) %>%
  summarize(
    # Plate appearance identifiers and context from final pitch
    game_year              = game_year[which.max(pitch_number)],
    batter                 = batter[which.max(pitch_number)],
    pitcher                = pitcher[which.max(pitch_number)],
    inning                 = inning[which.max(pitch_number)],
    inning_topbot          = inning_topbot[which.max(pitch_number)],
    batter_handedness      = stand[which.max(pitch_number)],
    outs_when_up           = outs_when_up[which.max(pitch_number)],
    run_diff               = bat_score[which.max(pitch_number)] - fld_score[which.max(pitch_number)],
    
    # Final pitch values for this PA
    pa_xwOBA               = estimated_woba_using_speedangle[which.max(pitch_number)],
    pa_xSLG                = estimated_slg_using_speedangle[which.max(pitch_number)],
    pa_xBA                 = estimated_ba_using_speedangle[which.max(pitch_number)],
    pa_woba                = woba_value[which.max(pitch_number)],
    on_1b                  = on_1b[which.max(pitch_number)],
    on_2b                  = on_2b[which.max(pitch_number)],
    on_3b                  = on_3b[which.max(pitch_number)],
    final_event            = events[which.max(pitch_number)],

    # Count pitches
    pitches_per_pa         = n(),

    .groups = "drop"
  ) %>%
  arrange(game_pk, inning, inning_topbot, at_bat_number) %>%
  mutate(
    # Basic batting stats
    pa_BA  = if_else(final_event %in% c("single", "double", "triple", "home_run"), 1, 0),
    pa_SLG = case_when(
      final_event == "single"   ~ 1,
      final_event == "double"   ~ 2,
      final_event == "triple"   ~ 3,
      final_event == "home_run" ~ 4,
      TRUE                      ~ 0
    ),
    is_extra_base_hit = final_event %in% c("double", "triple", "home_run"),
    is_walk           = final_event %in% c("walk", "intent_walk"),
    is_strikeout      = final_event %in% c("strikeout", "strikeout_double_play")
  )

```

We then find the next batter in the lineup and get their handedness. We can first organize the plate appearances by the game, then which team is hitting (derived from `inning_topbot`, and the plate appearance `at_bat_number`. Except for the last plate appearance for a team in a game, we assume that the protection is coming from the player hitting in the following plate appearance. For the last plate appearance for a team in a game, we make the `potential_next_batter` simply the batter who followed the player the previous time they came up.

This even works when the last hitter (or both the last and penultimate) in the game is a pinch hitter, as we can look at the second (or third) to last hitter's previous plate appearance, then find who would be following the pinch hitter in the lineup.

Note that this does not account for potential pinch hitters in the on-deck circle at the end of a game, pinch hitters who were in the on-deck circle at the time of the third out in an inning, and changes to a hitter in the middle of a plate appearance.

```{r}
pa_data <- pa_data %>%
  ## Order by game, half-inning, and at-bat
  arrange(game_pk, inning_topbot, at_bat_number) %>%
  
  ## Within each half-inning, define a naive next batter/handedness
  group_by(game_pk, inning_topbot) %>%
  mutate(
    naive_next_batter                 = lead(batter),
    naive_next_batter_handedness      = lead(batter_handedness),
    # 2-ahead references
    naive_next_next_batter            = lead(lead(batter)),
    naive_next_next_batter_handedness = lead(lead(batter_handedness)),
    # previous references
    naive_previous_batter             = lag(batter),
    naive_previous_batter_handedness  = lag(batter_handedness),
    # 3-ahead references
    naive_next_next_next_batter            = lead(lead(lead(batter))),
    naive_next_next_next_batter_handedness = lead(lead(lead(batter_handedness))),
    # previous-previous references
    naive_previous_previous_batter            = lag(lag(batter)),
    naive_previous_previous_batter_handedness = lag(lag(batter_handedness))
  ) %>%
  ungroup() %>%
  
  ## Wipe out cross-inning naive values
  mutate(
    same_half_inning = lead(game_pk) == game_pk & lead(inning_topbot) == inning_topbot,
    naive_next_batter            = if_else(same_half_inning, naive_next_batter, NA_integer_),
    naive_next_batter_handedness = if_else(same_half_inning, naive_next_batter_handedness, NA_character_)
  ) %>%
  
  ## For each (game_pk, batter), fill down naive_next_batter
  group_by(game_pk, batter) %>%
  fill(naive_next_batter, naive_next_batter_handedness, .direction = "down") %>%
  ungroup() %>%
  
  ## Fallback 1 -> Use naive_previous_batter groups
  group_by(game_pk, naive_previous_batter) %>%
  # Fill down naive_next_next_batter so each row in the group knows the last seen value
  fill(naive_next_next_batter, naive_next_next_batter_handedness, .direction = "down") %>%
  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter
  mutate(
    naive_next_batter = if_else(
      is.na(naive_next_batter),
      nth(naive_next_next_batter, n() - 1, default = NA_integer_),
      naive_next_batter
    ),
    naive_next_batter_handedness = if_else(
      is.na(naive_next_batter_handedness),
      nth(naive_next_next_batter_handedness, n() - 1, default = NA_character_),
      naive_next_batter_handedness
    )
  ) %>%
  ungroup() %>%
  
  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter UNGROUPED
  mutate(
    naive_next_batter = if_else(
      is.na(naive_next_batter),
      lag(naive_next_next_batter),
      naive_next_batter
    ),
    naive_next_batter_handedness = if_else(
      is.na(naive_next_batter_handedness),
      lag(naive_next_next_batter_handedness),
      naive_next_batter_handedness
    )
  ) %>%
  
  ## Fallback 2 -> Use naive_previous_previous_batter groups
  group_by(game_pk, naive_previous_previous_batter) %>%
  # Fill down naive_next_next_batter so each row in the group knows the last seen value
  fill(naive_next_next_next_batter, naive_next_next_next_batter_handedness, .direction = "down") %>%
  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter
  mutate(
    naive_next_batter = if_else(
      is.na(naive_next_batter),
      nth(naive_next_next_next_batter, n() - 2, default = NA_integer_),
      naive_next_batter
    ),
    naive_next_batter_handedness = if_else(
      is.na(naive_next_batter_handedness),
      nth(naive_next_next_next_batter_handedness, n() - 2, default = NA_character_),
      naive_next_batter_handedness
    )
  ) %>%
  ungroup() %>%
  
  # If naive_next_batter is still NA, use the third-to-last row's naive_next_next_next_batter UNGROUPED
  mutate(
    naive_next_batter = if_else(
      is.na(naive_next_batter),
      lag(lag(naive_next_next_next_batter)),
      naive_next_batter
    ),
    naive_next_batter_handedness = if_else(
      is.na(naive_next_batter_handedness),
      lag(lag(naive_next_next_next_batter_handedness)),
      naive_next_batter_handedness
    )
  ) %>%
  
  ## Rename & drop the extras
  rename(
    potential_next_batter            = naive_next_batter,
    potential_next_batter_handedness = naive_next_batter_handedness
  ) %>%
  select(
    -naive_next_next_batter,
    -naive_next_next_batter_handedness,
    -naive_previous_batter,
    -naive_previous_batter_handedness,
    -naive_next_next_next_batter,
    -naive_next_next_next_batter_handedness,
    -naive_previous_previous_batter,
    -naive_previous_previous_batter_handedness
  )
```

Let's also create a single baserunner state variable. We can simply check which of `on_1b`, `on_2b`, and `on_3b` have MLBAMIds and create strings based on that.

```{r}
pa_data <- pa_data %>%
  mutate(
    baserunner_state = case_when(
      !is.na(on_1b) & is.na(on_2b) & is.na(on_3b) ~ "1B",
      is.na(on_1b) & !is.na(on_2b) & is.na(on_3b) ~ "2B",
      is.na(on_1b) & is.na(on_2b) & !is.na(on_3b) ~ "3B",
      !is.na(on_1b) & !is.na(on_2b) & is.na(on_3b) ~ "1B-2B",
      !is.na(on_1b) & is.na(on_2b) & !is.na(on_3b) ~ "1B-3B",
      is.na(on_1b) & !is.na(on_2b) & !is.na(on_3b) ~ "2B-3B",
      !is.na(on_1b) & !is.na(on_2b) & !is.na(on_3b) ~ "Loaded",
      TRUE ~ "Empty"
    )
  )
```

For the special case in which it is a tie game with 2 outs and bases loaded in the top of the ninth inning, protection will not matter. Thus, we can take out `potential_next_batter` in those scenarios.

```{r}
pa_data <- pa_data %>%
  mutate(
    # If it’s bottom of the 9th+ with 2 outs, bases loaded, and the game is tied,
    # remove the potential next batter.
    potential_next_batter = ifelse(
      inning_topbot == "Bot" & 
        inning >= 9 & 
        outs_when_up == 2 & 
        baserunner_state == "Loaded" & 
        run_diff == 0,
      NA,
      potential_next_batter
    )
  )
```

```{r}
pa_data = readRDS("data/pa_data.rds")
```

To get our full-season statistics, we will create custom functions to extract Statcast data using BaseballR. We first create a function `get_expected_stats_one_year` that takes in a `year` value and `min_pa` value and outputs a dataframe with each player's—those that had the minimum plate appearances—expected statistics for that year. We chose 200 plate appearances, which is just 40% of the number of plate appearances needed to be qualified for that year, as a player's true value should stabilize around that many plate appearances, and we did not want to cut out too much data. We then use `get_expected_stats_all_years` to get expected statistics across all years of Statcast data (2015-2024).

```{r}
get_expected_stats_one_year <- function(year, min_pa = 200) {
  # Scrape the "expected_statistics" leaderboard for one season
  # with a minimum PA (e.g. 200).
  df <- statcast_leaderboards(
    leaderboard = "expected_statistics",
    year = year,
    min_pa = min_pa,   # 200
    player_type = "batter"
  )
  
  # Keep only relevant columns & rename them.
  # The returned columns may include more, but these are typical:
  # "year", "player_id", "pa", "bip", "ba", "est_ba", "slg",
  # "est_slg", "woba", "est_woba", etc.
  df <- df %>%
    select(
      year,
      player_id,
      pa,
      ba,
      est_ba,
      slg,
      est_slg,
      woba,
      est_woba
      # if you want more columns, add them here
    ) %>%
    rename(
      game_year    = year,      # aligns with pa_data's "game_year"
      batter_id    = player_id, # aligns with pa_data's "batter" ID
      batter_PA    = pa,
      batter_BA    = ba,
      batter_xBA   = est_ba,
      batter_SLG   = slg,
      batter_xSLG  = est_slg,
      batter_wOBA  = woba,
      batter_xwOBA = est_woba
    )
  
  return(df)
}

get_expected_stats_all_years <- function(start_year, end_year, min_pa = 200) {
  
  # Loop over each year, scrape the leaderboard, store results
  all_stats <- lapply(seq(start_year, end_year), function(yr) {
    message("Scraping year: ", yr)
    get_expected_stats_one_year(year = yr, min_pa = min_pa)
  })
  
  # Combine all into one data frame
  all_stats_df <- bind_rows(all_stats)
  
  return(all_stats_df)
}
```

Then, once we put all years of batting statistics into a dataframe titled `batter_stats_all`, we will add it to our plate appearance-level data `pa_data` for both the current batter of each row and the next batter. We will only keep rows for which the next batter has followed the current batter for at least 40 plate appearances. We will remove rows for which there are not complete statistics.

```{r}
## Get all years of batting stats from 2015-2024
batter_stats_all <- get_expected_stats_all_years(2015, 2024, min_pa = 200)

## Join with pa_data for current & next batters
pa_data_with_batter <- pa_data %>%
  left_join(batter_stats_all, by = c("game_year", "batter" = "batter_id"))

next_batter_stats_all <- batter_stats_all %>%
  rename(
    next_batter_PA    = batter_PA,
    next_batter_BA    = batter_BA,
    next_batter_xBA   = batter_xBA,
    next_batter_SLG   = batter_SLG,
    next_batter_xSLG  = batter_xSLG,
    next_batter_wOBA  = batter_wOBA,
    next_batter_xwOBA = batter_xwOBA
  )

pa_data_with_both <- pa_data_with_batter %>%
  left_join(next_batter_stats_all, by = c("game_year", 
                                          "potential_next_batter" = "batter_id"))

## Filter pairs with >= 40 PAs
pa_data_with_both <- pa_data_with_both %>%
  group_by(game_year, batter, potential_next_batter) %>%
  mutate(combo_count = n()) %>%
  ungroup() %>%
  filter(combo_count >= 40) %>%
  select(-combo_count)

## Remove rows with missing season stats
pa_data_final <- pa_data_with_both %>%
  filter(
    !is.na(batter_xwOBA) & !is.na(batter_xSLG) & !is.na(batter_xBA) &
    !is.na(batter_wOBA) & !is.na(batter_BA) & !is.na(batter_SLG) &
    !is.na(next_batter_xwOBA) &
    !is.na(next_batter_xSLG) &
    !is.na(next_batter_xBA) &
    !is.na(next_batter_wOBA) &
    !is.na(next_batter_BA) &
    !is.na(next_batter_SLG)
  )
```

```{r}
saveRDS(pa_data_final, "data/pa_data_final.rds")

# Load the data
pa_data_final <- readRDS("data/pa_data_final.rds")
```

We need four more columns: `walk_rate` (BB%), `strikeout_rate` (K%), `xbh_rate` (XBH%), and `pitches_per_pa` (P/PA).

We will get `walk_rate` and `strikeout_rate` from Fangraphs Leaderbaords using BaseballR, and find `xbh_rate` and `pitches_per_pa` manually using our `pa_data` dataset.

First, we can get `xbh_rate` and `pitches_per_pa` manually.

```{r}
pa_extra_metrics <- pa_data %>%
  group_by(game_year, batter) %>%
  summarize(
    xbh_rate = mean(is_extra_base_hit, na.rm = TRUE),  # extra-base hit rate
    pitches_per_pa = mean(pitches_per_pa, na.rm = TRUE),    # pitches per plate appearance
    .groups = "drop"
  )

## Join to add current batter's extra metrics.
pa_data_final <- pa_data_final %>%
  left_join(
    pa_extra_metrics %>% 
      select(game_year, batter, xbh_rate, pitches_per_pa) %>%
      rename(
        batter_xbh_rate    = xbh_rate,
        batter_pitches_per_pa = pitches_per_pa
      ),
    by = c("game_year", "batter")
  )

## Join to add next batter's extra metrics.
pa_data_final <- pa_data_final %>%
  left_join(
    pa_extra_metrics %>% 
      select(game_year, batter, xbh_rate, pitches_per_pa) %>%
      rename(
        next_batter_xbh_rate    = xbh_rate,
        next_batter_pitches_per_pa = pitches_per_pa
      ),
    by = c("game_year", "potential_next_batter" = "batter")
  )
```

Let's also get our `walk_rate` and `strikeout_rate` using BaseballR.

```{r}
## Function to get FanGraphs BB% and K% for qualified batters 
## from start_season to end_season (inclusive)

get_fg_batter_rates <- function(start_season, end_season) {
  # Create a vector of seasons as characters
  seasons <- as.character(seq(start_season, end_season))
  
  # Loop over each season and scrape the batter leaderboard
  fg_data_list <- lapply(seasons, function(season) {
    message("Scraping FanGraphs batter leaders for season: ", season)
    df <- fg_batter_leaders(
      startseason = season,
      endseason = season,
      qual = "y",      # Only qualified hitters
      ind = "1",       # Split seasons individually
      pageitems = "10000"
    )
    # Select only the columns we need.
    df %>% 
      select(Season, xMLBAMID, BB_pct, K_pct)
  })
  
  # Bind rows together from all seasons
  fg_data_all <- bind_rows(fg_data_list)
  
  # Rename Season to game_year, convert to numeric, and convert xMLBAMID to factor
  fg_data_all <- fg_data_all %>%
    rename(game_year = Season) %>%
    mutate(
      game_year = as.numeric(game_year),
      xMLBAMID = as.factor(xMLBAMID)
    )
  
  return(fg_data_all)
}

## Get FanGraphs batter rates for all seasons 2015-2024
fg_rates_all <- get_fg_batter_rates(2015, 2024)

## Join the scraped FanGraphs rates into pa_data_final
# Join current batter rates.
pa_data_final <- pa_data_final %>%
  left_join(
    fg_rates_all,
    by = c("game_year", "batter" = "xMLBAMID")
  ) %>%
  rename(
    batter_bb_pct = BB_pct,
    batter_k_pct  = K_pct
  )

pa_data_final <- pa_data_final %>%
  mutate(
    potential_next_batter = as.factor(potential_next_batter)
  )

# Join next batter rates.
pa_data_final <- pa_data_final %>%
  left_join(
    fg_rates_all,
    by = c("game_year", "potential_next_batter" = "xMLBAMID")
  ) %>%
  rename(
    next_batter_bb_pct = BB_pct,
    next_batter_k_pct  = K_pct
  )
```

Next, we'll add columns for `xwOBA_diff`, `xBA_diff`, and `xSLG_diff`, which are the differences between the current batter's xwOBA, xBA, and xSLG and the plate appearance's xwOBA, xBA, and xSLG.

```{r}
# Calculate differences
pa_data_final <- pa_data_final %>%
  mutate(
    xwOBA_diff = pa_xwOBA - batter_xwOBA,
    xBA_diff   = pa_xBA - batter_xBA,
    xSLG_diff  = pa_xSLG - batter_xSLG
  )

test = pa_data_final %>%
  # Fill NAs with 0 in pa_xwOBA
  mutate(
    pa_xwOBA = ifelse(is.na(pa_xwOBA), 0, pa_xwOBA),
    # Fill NAs with 0 in xwOBA_diff
    xwOBA_diff = ifelse(is.na(xwOBA_diff), 0, xwOBA_diff)
  )
```

```{r}
# Save the final data frame
saveRDS(pa_data_final, "data/pa_data_final.rds")
```

The last thing we will do is ensure that all of the variables we expect to act non-linearly are factors for our models.

```{r}
# Convert certain variables to factors
pa_data_final$batter_handedness <- factor(pa_data_final$batter_handedness)
pa_data_final$potential_next_batter_handedness <- factor(pa_data_final$potential_next_batter_handedness)
pa_data_final$batter <- factor(pa_data_final$batter)
pa_data_final$pitcher <- factor(pa_data_final$pitcher)
pa_data_final$baserunner_state <- factor(pa_data_final$baserunner_state)
pa_data_final$inning <- factor(pa_data_final$inning)
pa_data_final$outs_when_up <- factor(pa_data_final$outs_when_up)
```

Let's now do our first model

## Model #1: Mixed Effects Linear Model of Plate Appearances

### I. Overall Offensive Value: wOBA and xWOBA

First, let's look at residuals from season-long averages for each plate appearance.

```{r}
m_protection_1 <- lmer(
  xwOBA_diff ~ next_batter_xwOBA + 
    batter_handedness + potential_next_batter_handedness +
    baserunner_state + outs_when_up + run_diff +
    (1 | pitcher) + (1 | batter),
  data = pa_data_final
)

summary(m_protection_1)
```

Before we look at our model summary, let's check the assumptions of our model.

```{r}
# Check for normality of residuals
qqnorm(resid(m_protection_1))

# Check for homoscedasticity
plot(fitted(m_protection_1), resid(m_protection_1))

# Check for multicollinearity
vif(m_protection_1)
```

This first model shows us that `next_batter_xwOBA` certainly does have a small, but signficant impact on the result of the current plate appearance, with a p-value below 0.05. The coefficeint is negative, however, indicating that having a better next batter correlates with worse overall offensive outcomes for hitters.

It is worth noting that we got a singularity with regards to the random effect `(1 | batter)`. This indicates that the model already has the effect of the batter baked into the model through the `xwOBA_diff` outcome variable, which is derived from `pa_xwOBA` and `batter_xwOBA`. So, we know that almost all of the variance between batters can be accounted for by their season-long `batter_xwOBA`. Thus, our next model takes a slightly different approach, estimating the xwOBA of each plate appearance directly. We expect the coefficient of `batter_xwOBA` to be 1, as we are predicting the xwOBA of a player's plate appearance using their average xwOBA from the year.

```{r}
m_protection_2 <- lmer(
  pa_xwOBA ~ batter_xwOBA + next_batter_xwOBA + 
    batter_handedness + potential_next_batter_handedness +
    baserunner_state + outs_when_up + run_diff +
    (1 | pitcher),
  data = pa_data_final
)

summary(m_protection_2)
```

As expected, our `batter_xwOBA` coefficient is near 1 at 1.011, and our `next_batter_xwOBA` coefficient is signficant and negative at -0.02409. 

**Takeaway:** If your next batter’s season-long xwOBA is 0.100 higher than average (e.g., .350 vs. .250), your own plate appearance xwOBA is predicted to be about 0.0024 points lower – a drop of around 0.8% relative to a typical .300 xwOBA.

### II. Ability for Contact: BA and xBA

```{r}
pa_data_xba <- pa_data_final %>%
  mutate(pa_xBA = ifelse(is.na(pa_xBA) & pa_xwOBA == 0, 0, pa_xBA)) %>%
  filter(!is.na(pa_xBA) & !is.na(batter_xBA) & !is.na(next_batter_xBA))

m_protection_xBA <- lmer(
  pa_xBA ~ batter_xBA + next_batter_xwOBA + 
    batter_handedness + potential_next_batter_handedness +
    baserunner_state + outs_when_up + run_diff +
    (1 | pitcher),
  data = pa_data_xba
)

summary(m_protection_xBA)
```

This model examines how a plate appearance’s batting average metric (pa_xBA) depends on the batter’s season-long average (batter_xBA), the following hitter’s season-long expected wOBA (next_batter_xwOBA), and various other contextual factors. The large positive coefficient on batter_xBA (~0.979) reaffirms that the best predictor of a single PA’s batting outcome is the batter’s own established average. Meanwhile, having a higher next_batter_xwOBA (coefficient ~-0.0207) shows a small but statistically significant negative association, indicating the current hitter’s pa_xBA may drop a bit when a stronger hitter is on deck. Some baserunner states (e.g., runner on 3B) slightly increase pa_xBA, others (like runner on 2B alone) decrease it, and having more outs also lowers pa_xBA. The random effect for pitcher is relatively small, suggesting pitchers differ slightly in ways not captured by the fixed effects.

**Takeaway:** If the next batter’s xwOBA goes up by 0.100, we estimate a ~-0.002 reduction in pa_xBA per plate appearance—over 500 plate appearances, that amounts to about 1 fewer hit compared to otherwise.

## Discussion

This study, although rather simple, tackles some of the problems with sabermetrics' view of lineup protection. By accounting for different game situations, we find that the skill of the next batter does have a statistically significant impact on the offensive outcomes of the current one. While small, this will have significant implications for player evaluation and valuation, as we are establishing dependencies between players that have not been accounted for in the past. 

## References

Ambrosino, D. (2011, November 30). *Orders of protection*. The Hardball Times. <https://tht.fangraphs.com/orders-of-protection/>

Bradbury, J. C., & Drinen, D. J. (2007). Pigou at the plate. *Journal of Sports Economics*, *9*(2), 211-224. <https://doi.org/10.1177/1527002507300178>

Britton, T. (2024, April 26). J.D. Martinez will be Pete Alonso’s protection in Mets lineup. Does that matter? *The New York Times*. <https://www.nytimes.com/athletic/5443604/2024/04/26/mets-pete-alonso-jd-martinez-lineup/>

Cameron, D. (2012, May 25). *Cameron: McCutchen disproves lineup protection*. ESPN.com. <https://insider.espn.com/mlb/insider/story/_/id/7970598/andrew-mccutchen-another-example-why-lineup-protection-myth-mlb>

How to quantify lineup protection in baseball — The Paraball notes. (2024, April 9). *The Paraball Notes*. <https://www.paraballnotes.com/blog/how-to-quantify-lineup-protection-in-baseball>

Laurila, D. (2016, July 14). *Player’s view: Does lineup protection exist?* FanGraphs Baseball. <https://blogs.fangraphs.com/players-view-does-lineup-protection-exist/>

Petriello, M. (2015, April 13). *Billy Hamilton’s reverse lineup protection*. FanGraphs Baseball. <https://blogs.fangraphs.com/billy-hamiltons-reverse-lineup-protection/>

Phillips, D. C. (2011). You're hurting my game: Lineup protection and injuries in Major League Baseball. *Journal of Quantitative Analysis in Sports*, *7*(3). <https://doi.org/10.2202/1559-0410.1296>

Stavenhagen, C. (2019, May 7). The (latest) numbers behind Miguel Cabrera’s remarks on lineup protection. *The New York Times*. <https://www.nytimes.com/athletic/965467/2019/05/07/the-latest-numbers-behind-miguel-cabreras-remarks-on-lineup-protection/>

Tango, T. (2006, April 7). *Pitching around batters*. The Hardball Times. <https://tht.fangraphs.com/pitching-around-batters/>

Weinberg, N. (2013, January 1). *Lineup protection: Fact or fiction?* New English D. <https://newenglishd.com/2013/01/01/lineup-protection-fact-or-fiction/>

Wiser, J. (2014, February 19). *Let’s talk about lineup protection*. Inside the 'Zona. <https://insidethezona.com/2014/02/lets-talk-lineup-protection/>
