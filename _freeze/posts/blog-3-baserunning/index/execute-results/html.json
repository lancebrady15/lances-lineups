{
  "hash": "54c649a0f7c3ffda0a7486c5a439dd90",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Blog #3: Baserunning\"\nauthor: \"Lance Brady\"\ndate: \"2025-03-05\"\ncategories: [swing profiles, lineups, statcast]\nformat: html\neditor: visual\nimage: blog3.jpg\n---\n\n\n\n## Takeaways\n\n1.  A\n\n## Introduction to Baserunning\n\nAs Statcast expands the data they are able to collect and parse through, one big innovation is the creation of \"Baserunning Runs,\" which aims to estimate the number of runs a player is creating through baserunning alone. Statcast defines it as follows:\n\n\"A Statcast metric designed to express the overall value of a baserunner, measured in runs created (or lost) via stealing bases and taking extra bases on the basepaths. Each steal opportunity is assigned a probability of being successful or not, based on the pitcher and catcher the basestealer is running against. Each successful or failed steal attempt is assigned a run value, with a stolen base or advance via a balk worth +0.2 runs for the baserunner and a caught stealing or pickoff worth -0.45 runs. For non-steal baserunning plays, an estimated success probability is generated for each opportunity using inputs that include runner speed, outfielder throwing arm, runner position on the basepaths and outfielder distance from both the ball and the bases. That can be translated to a run value based on whether the runner successfully takes the extra base, is thrown out or does not attempt to advance (holds).\"\n\nA player's speed is only as useful as they make it, so lineup construction analysis, which often references the need for speed at the top and bottom of the order, would benefit from using this advanced data. Managers no longer have to use sprint speed to proxy a player's value on the basepaths, they can use a player's true baserunning value.\n\nIt is worth noting that the MLB opted for bigger bases in 2023 to increase action on the basepaths. This means that although Statcast has baserunning data going back to 2016, we will focus on just the 2023 and 2024 seasons to make our analysis more applicable to future seasons.\n\n## Aim\n\nThis article aims to answer a couple of questions about the role baserunning has in lineup construction. We'd like to answer the following research questions, which focus on distinct parts of baserunner effects within the game:\n\n1.  Does having a perceived “speed threat” on base lead to measurable changes in the pitcher’s approach (e.g., pitch selection, pitch location, pickoff frequency), and can that impact subsequent hitters’ performances?\n2.  What is the optimal positioning of baserunning value within a lineup? Is it better to cluster speedy players consecutively (for multiple stolen bases or first-to-third attempts in an inning) or to spread them out to maximize the impact in different segments of the lineup?\n3.  Since 2023, how well have managers optimized their team's speed in their lineups?\n\n## Setup\n\nTo answer Question #1, we will need two datasets: Statcast pitch-by-pitch data for all of 2023/2024 and\n\n## Methods\n\nFirst, we loaded in our libraries and read the data, which contains almost every pitch from the 2023 and 2024 seasons (excluding when poor data was retrieved).\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstatcast_data = read.csv(\"data/statcast_data.csv\")\nbaserunning_data = read.csv(\"data/baserunning_data.csv\")\n```\n:::\n\n\n\nNext, we want to create a \"speed value\" for each player in our base_running data. We will use `runner_runs_tot` from `baserunning_data` to create a new column, `speed_value`, which will be the number of runs a player generated through baserunning divided by the number of opportunities they had to generate those runs. `runner_runs_tot` is the number of runs a player generated through baserunning.\n\nDO ANALYSIS OF NUMBER OF OPPORTUNITIES FOR EACH PLAYER. This is more representative of their true baserunning threat than just the number of total baserunning runs they generated. \n\nNow, let's create a lookup table for each player with their speed value.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaserunning_lookup <- setNames(baserunning_data$runner_runs_tot,\n                               baserunning_data$player_id)\n```\n:::\n\n\n\nNext, we will create a custom function to sum the baserunning value on base for each pitch. This function will take in the base occupancy and the lookup table we just created and return the sum of the baserunning value for each player on base.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Custom function to calculate total speed on base, ensuring all runners have data\nget_total_speed_on_base <- function(on1b, on2b, on3b, baserunning_lookup) {\n  \n  # Convert IDs to character to match lookup names\n  runner_ids <- as.character(c(on1b, on2b, on3b))\n  \n  # Check if all runners are in the lookup\n  if (all(!is.na(runner_ids)) && all(runner_ids %in% names(baserunning_lookup))) {\n    \n    # Sum up `runner_runs_tot` for all runners on base\n    total_speed <- sum(baserunning_lookup[runner_ids], na.rm = TRUE)\n    return(total_speed)\n    \n  } else {\n    return(NA)  # Mark as NA if any runner is missing in baserunning_lookup\n  }\n}\n\n# Apply function to calculate total speed on base for each pitch, filtering valid cases\nstatcast_data <- statcast_data %>%\n  rowwise() %>%\n  mutate(\n    total_speed_on_base = get_total_speed_on_base(\n      on_1b, on_2b, on_3b, baserunning_lookup\n    )\n  ) %>%\n  ungroup() %>%\n  filter(!is.na(total_speed_on_base))\n\n# Check summary\nsummary(statcast_data$total_speed_on_base)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-11.3825  -0.8749   1.9522   2.2307   5.3972  17.4554 \n```\n\n\n:::\n:::\n\n\n\n## Model 1: Pitcher Behavior\n### Pitch Velocity with Speed on Base\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_vel <- lmer(\n  release_speed ~ total_speed_on_base + factor(balls) + factor(strikes) + (1 + total_speed_on_base | pitcher),\n  data = statcast_data\n)\n\nsummary(model_vel)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: \nrelease_speed ~ total_speed_on_base + factor(balls) + factor(strikes) +  \n    (1 + total_speed_on_base | pitcher)\n   Data: statcast_data\n\nREML criterion at convergence: 18011.2\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-3.5809 -0.7468  0.1345  0.7500  2.4033 \n\nRandom effects:\n Groups   Name                Variance Std.Dev. Corr \n pitcher  (Intercept)         12.13254 3.4832        \n          total_speed_on_base  0.04979 0.2231   -0.39\n Residual                     22.94663 4.7903        \nNumber of obs: 2919, groups:  pitcher, 372\n\nFixed effects:\n                      Estimate Std. Error         df t value Pr(>|t|)    \n(Intercept)          8.966e+01  2.562e-01  5.277e+02 350.002  < 2e-16 ***\ntotal_speed_on_base -2.229e-03  3.168e-02  1.348e+02  -0.070 0.944003    \nfactor(balls)1       6.057e-02  2.294e-01  2.760e+03   0.264 0.791785    \nfactor(balls)2       9.957e-01  2.980e-01  2.787e+03   3.341 0.000845 ***\nfactor(balls)3       3.028e+00  3.956e-01  2.786e+03   7.654 2.67e-14 ***\nfactor(strikes)1     1.150e-01  2.292e-01  2.701e+03   0.502 0.615918    \nfactor(strikes)2    -9.891e-01  2.572e-01  2.790e+03  -3.846 0.000123 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            (Intr) ttl___ fctr(b)1 fctr(b)2 fct()3 fctr(s)1\nttl_spd_n_b -0.334                                         \nfctr(blls)1 -0.226 -0.006                                  \nfctr(blls)2 -0.139 -0.024  0.384                           \nfctr(blls)3 -0.094 -0.001  0.312    0.327                  \nfctr(strk)1 -0.298 -0.006 -0.170   -0.179   -0.166         \nfctr(strk)2 -0.222 -0.009 -0.264   -0.349   -0.344  0.474  \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n### Pitch Selection with Speed on Base\n## Model #1: \n\n## Visualizations\n\n## Discussion\n\n## References\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}