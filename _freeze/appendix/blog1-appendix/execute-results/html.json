{
  "hash": "e1f9d4f5a1acb2ca6a864220296290b9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Appendix: Blog Post #1\"\nauthor: \"Lance Brady\"\ndate: \"2025-02-18\"\ncategories: [lineup protection, lineups, statcast]\nformat: html\neditor: visual\nimage: blog1.jpg\nexecute:\n  eval: false\n---\n\n\n\nFirst, we loaded in our libraries and read the data, which contains almost every pitch from the 2024 season (excluding when poor data was retrieved).\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstatcast_data <- readRDS(\"data/statcast_all_years.rds\")\n```\n:::\n\n\n\nFor each plate appearance, we aggregate key variables. In this code, each plate appearance is identified by grouping on `game_pk` and `at_bat_number`, then we take the last pitch (using `which.max(pitch_number)`) to define final values for fields like `pa_xwOBA`, `pa_xBA`, and `pa_woba`. Specifically, `pa_xwOBA` is assigned the value from `estimated_woba_using_speedangle` on the last pitch, and similarly `pa_xBA` comes from `estimated_ba_using_speedangle`. We also create `pa_BA` as `1` if the `final_event` is `\"single\"`, `\"double\"`, `\"triple\"`, or `\"home_run\"`, and `pa_SLG` by mapping those same events to `1`, `2`, `3`, or `4` respectively. We compute `pitches_per_pa` via `n()`, reflecting how many pitches occurred in each plate appearance. Furthermore, we define `is_extra_base_hit` if `final_event` is `\"double\"`, `\"triple\"`, or `\"home_run\"`, `is_walk` if the `final_event` is `\"walk\"` or `\"intent_walk\"`, and `is_strikeout` if the `final_event` is `\"strikeout\"` or `\"strikeout_double_play\"`. Finally, the code calculates `run_diff` as the difference between `bat_score` and `fld_score` on the last pitch, capturing the score differential before the plate appearanceâ€™s outcome is officially applied.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data <- statcast_data %>%\n  group_by(game_pk, at_bat_number) %>%\n  summarize(\n    # Plate appearance identifiers and context from final pitch\n    game_year              = game_year[which.max(pitch_number)],\n    batter                 = batter[which.max(pitch_number)],\n    pitcher                = pitcher[which.max(pitch_number)],\n    inning                 = inning[which.max(pitch_number)],\n    inning_topbot          = inning_topbot[which.max(pitch_number)],\n    batter_handedness      = stand[which.max(pitch_number)],\n    outs_when_up           = outs_when_up[which.max(pitch_number)],\n    run_diff               = bat_score[which.max(pitch_number)] - fld_score[which.max(pitch_number)],\n    \n    # Final pitch values for this PA\n    pa_xwOBA               = estimated_woba_using_speedangle[which.max(pitch_number)],\n    pa_xSLG                = estimated_slg_using_speedangle[which.max(pitch_number)],\n    pa_xBA                 = estimated_ba_using_speedangle[which.max(pitch_number)],\n    pa_woba                = woba_value[which.max(pitch_number)],\n    on_1b                  = on_1b[which.max(pitch_number)],\n    on_2b                  = on_2b[which.max(pitch_number)],\n    on_3b                  = on_3b[which.max(pitch_number)],\n    final_event            = events[which.max(pitch_number)],\n\n    # Count pitches\n    pitches_per_pa         = n(),\n\n    .groups = \"drop\"\n  ) %>%\n  arrange(game_pk, inning, inning_topbot, at_bat_number) %>%\n  mutate(\n    # Basic batting stats\n    pa_BA  = if_else(final_event %in% c(\"single\", \"double\", \"triple\", \"home_run\"), 1, 0),\n    pa_SLG = case_when(\n      final_event == \"single\"   ~ 1,\n      final_event == \"double\"   ~ 2,\n      final_event == \"triple\"   ~ 3,\n      final_event == \"home_run\" ~ 4,\n      TRUE                      ~ 0\n    ),\n    is_extra_base_hit = final_event %in% c(\"double\", \"triple\", \"home_run\"),\n    is_walk           = final_event %in% c(\"walk\", \"intent_walk\"),\n    is_strikeout      = final_event %in% c(\"strikeout\", \"strikeout_double_play\")\n  )\n```\n:::\n\n\n\nWe then find the next batter in the lineup and get their handedness. We can first organize the plate appearances by the game, then which team is hitting (derived from `inning_topbot`, and the plate appearance `at_bat_number`. Except for the last plate appearance for a team in a game, we assume that the protection is coming from the player hitting in the following plate appearance. For the last plate appearance for a team in a game, we make the `potential_next_batter` simply the batter who followed the player the previous time they came up.\n\nThis even works when the last hitter (or both the last and penultimate) in the game is a pinch hitter, as we can look at the second (or third) to last hitter's previous plate appearance, then find who would be following the pinch hitter in the lineup.\n\nNote that this does not account for potential pinch hitters in the on-deck circle at the end of a game, pinch hitters who were in the on-deck circle at the time of the third out in an inning, and changes to a hitter in the middle of a plate appearance.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data <- pa_data %>%\n  ## Order by game, half-inning, and at-bat\n  arrange(game_pk, inning_topbot, at_bat_number) %>%\n  \n  ## Within each half-inning, define a naive next batter/handedness\n  group_by(game_pk, inning_topbot) %>%\n  mutate(\n    naive_next_batter                 = lead(batter),\n    naive_next_batter_handedness      = lead(batter_handedness),\n    # 2-ahead references\n    naive_next_next_batter            = lead(lead(batter)),\n    naive_next_next_batter_handedness = lead(lead(batter_handedness)),\n    # previous references\n    naive_previous_batter             = lag(batter),\n    naive_previous_batter_handedness  = lag(batter_handedness),\n    # 3-ahead references\n    naive_next_next_next_batter            = lead(lead(lead(batter))),\n    naive_next_next_next_batter_handedness = lead(lead(lead(batter_handedness))),\n    # previous-previous references\n    naive_previous_previous_batter            = lag(lag(batter)),\n    naive_previous_previous_batter_handedness = lag(lag(batter_handedness))\n  ) %>%\n  ungroup() %>%\n  \n  ## Wipe out cross-inning naive values\n  mutate(\n    same_half_inning = lead(game_pk) == game_pk & lead(inning_topbot) == inning_topbot,\n    naive_next_batter            = if_else(same_half_inning, naive_next_batter, NA_integer_),\n    naive_next_batter_handedness = if_else(same_half_inning, naive_next_batter_handedness, NA_character_)\n  ) %>%\n  \n  ## For each (game_pk, batter), fill down naive_next_batter\n  group_by(game_pk, batter) %>%\n  fill(naive_next_batter, naive_next_batter_handedness, .direction = \"down\") %>%\n  ungroup() %>%\n  \n  ## Fallback 1 -> Use naive_previous_batter groups\n  group_by(game_pk, naive_previous_batter) %>%\n  # Fill down naive_next_next_batter so each row in the group knows the last seen value\n  fill(naive_next_next_batter, naive_next_next_batter_handedness, .direction = \"down\") %>%\n  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      nth(naive_next_next_batter, n() - 1, default = NA_integer_),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      nth(naive_next_next_batter_handedness, n() - 1, default = NA_character_),\n      naive_next_batter_handedness\n    )\n  ) %>%\n  ungroup() %>%\n  \n  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter UNGROUPED\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      lag(naive_next_next_batter),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      lag(naive_next_next_batter_handedness),\n      naive_next_batter_handedness\n    )\n  ) %>%\n  \n  ## Fallback 2 -> Use naive_previous_previous_batter groups\n  group_by(game_pk, naive_previous_previous_batter) %>%\n  # Fill down naive_next_next_batter so each row in the group knows the last seen value\n  fill(naive_next_next_next_batter, naive_next_next_next_batter_handedness, .direction = \"down\") %>%\n  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      nth(naive_next_next_next_batter, n() - 2, default = NA_integer_),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      nth(naive_next_next_next_batter_handedness, n() - 2, default = NA_character_),\n      naive_next_batter_handedness\n    )\n  ) %>%\n  ungroup() %>%\n  \n  # If naive_next_batter is still NA, use the third-to-last row's naive_next_next_next_batter UNGROUPED\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      lag(lag(naive_next_next_next_batter)),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      lag(lag(naive_next_next_next_batter_handedness)),\n      naive_next_batter_handedness\n    )\n  ) %>%\n  \n  ## Rename & drop the extras\n  rename(\n    potential_next_batter            = naive_next_batter,\n    potential_next_batter_handedness = naive_next_batter_handedness\n  ) %>%\n  select(\n    -naive_next_next_batter,\n    -naive_next_next_batter_handedness,\n    -naive_previous_batter,\n    -naive_previous_batter_handedness,\n    -naive_next_next_next_batter,\n    -naive_next_next_next_batter_handedness,\n    -naive_previous_previous_batter,\n    -naive_previous_previous_batter_handedness\n  )\n```\n:::\n\n\n\nLet's also create a single baserunner state variable. We can simply check which of `on_1b`, `on_2b`, and `on_3b` have MLBAMIds and create strings based on that.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data <- pa_data %>%\n  mutate(\n    baserunner_state = case_when(\n      !is.na(on_1b) & is.na(on_2b) & is.na(on_3b) ~ \"1B\",\n      is.na(on_1b) & !is.na(on_2b) & is.na(on_3b) ~ \"2B\",\n      is.na(on_1b) & is.na(on_2b) & !is.na(on_3b) ~ \"3B\",\n      !is.na(on_1b) & !is.na(on_2b) & is.na(on_3b) ~ \"1B-2B\",\n      !is.na(on_1b) & is.na(on_2b) & !is.na(on_3b) ~ \"1B-3B\",\n      is.na(on_1b) & !is.na(on_2b) & !is.na(on_3b) ~ \"2B-3B\",\n      !is.na(on_1b) & !is.na(on_2b) & !is.na(on_3b) ~ \"Loaded\",\n      TRUE ~ \"Empty\"\n    )\n  )\n```\n:::\n\n\n\nFor the special case in which it is a tie game with 2 outs and bases loaded in the top of the ninth inning, protection will not matter. Thus, we can take out `potential_next_batter` in those scenarios.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data <- pa_data %>%\n  mutate(\n    # If itâ€™s bottom of the 9th+ with 2 outs, bases loaded, and the game is tied,\n    # remove the potential next batter.\n    potential_next_batter = ifelse(\n      inning_topbot == \"Bot\" & \n        inning >= 9 & \n        outs_when_up == 2 & \n        baserunner_state == \"Loaded\" & \n        run_diff == 0,\n      NA,\n      potential_next_batter\n    )\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Can just read in pa_data if you want to skip the above steps\n## pa_data = readRDS(\"data/pa_data.rds\")\n```\n:::\n\n\n\nTo get our full-season statistics, we will create custom functions to extract Statcast data using BaseballR. We first create a function `get_expected_stats_one_year` that takes in a `year` value and `min_pa` value and outputs a dataframe with each player'sâ€”those that had the minimum plate appearancesâ€”expected statistics for that year. We chose 200 plate appearances, which is just 40% of the number of plate appearances needed to be qualified for that year, as a player's true value should stabilize around that many plate appearances, and we did not want to cut out too much data. We then use `get_expected_stats_all_years` to get expected statistics across all years of Statcast data (2015-2024).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_expected_stats_one_year <- function(year, min_pa = 200) {\n  # Scrape the \"expected_statistics\" leaderboard for one season\n  # with a minimum PA (e.g. 200).\n  df <- statcast_leaderboards(\n    leaderboard = \"expected_statistics\",\n    year = year,\n    min_pa = min_pa,   # 200\n    player_type = \"batter\"\n  )\n  \n  # Keep only relevant columns & rename them.\n  # The returned columns may include more, but these are typical:\n  # \"year\", \"player_id\", \"pa\", \"bip\", \"ba\", \"est_ba\", \"slg\",\n  # \"est_slg\", \"woba\", \"est_woba\", etc.\n  df <- df %>%\n    select(\n      year,\n      player_id,\n      pa,\n      ba,\n      est_ba,\n      slg,\n      est_slg,\n      woba,\n      est_woba\n      # if you want more columns, add them here\n    ) %>%\n    rename(\n      game_year    = year,      # aligns with pa_data's \"game_year\"\n      batter_id    = player_id, # aligns with pa_data's \"batter\" ID\n      batter_PA    = pa,\n      batter_BA    = ba,\n      batter_xBA   = est_ba,\n      batter_SLG   = slg,\n      batter_xSLG  = est_slg,\n      batter_wOBA  = woba,\n      batter_xwOBA = est_woba\n    )\n  \n  return(df)\n}\n\nget_expected_stats_all_years <- function(start_year, end_year, min_pa = 200) {\n  \n  # Loop over each year, scrape the leaderboard, store results\n  all_stats <- lapply(seq(start_year, end_year), function(yr) {\n    message(\"Scraping year: \", yr)\n    get_expected_stats_one_year(year = yr, min_pa = min_pa)\n  })\n  \n  # Combine all into one data frame\n  all_stats_df <- bind_rows(all_stats)\n  \n  return(all_stats_df)\n}\n```\n:::\n\n\n\nThen, once we put all years of batting statistics into a dataframe titled `batter_stats_all`, we will add it to our plate appearance-level data `pa_data` for both the current batter of each row and the next batter. We will only keep rows for which the next batter has followed the current batter for at least 40 plate appearances. We will remove rows for which there are not complete statistics.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Get all years of batting stats from 2015-2024\nbatter_stats_all <- get_expected_stats_all_years(2015, 2024, min_pa = 200)\n\n## Join with pa_data for current & next batters\npa_data_with_batter <- pa_data %>%\n  left_join(batter_stats_all, by = c(\"game_year\", \"batter\" = \"batter_id\"))\n\nnext_batter_stats_all <- batter_stats_all %>%\n  rename(\n    next_batter_PA    = batter_PA,\n    next_batter_BA    = batter_BA,\n    next_batter_xBA   = batter_xBA,\n    next_batter_SLG   = batter_SLG,\n    next_batter_xSLG  = batter_xSLG,\n    next_batter_wOBA  = batter_wOBA,\n    next_batter_xwOBA = batter_xwOBA\n  )\n\npa_data_with_both <- pa_data_with_batter %>%\n  left_join(next_batter_stats_all, by = c(\"game_year\", \n                                          \"potential_next_batter\" = \"batter_id\"))\n\n## Filter pairs with >= 40 PAs\npa_data_with_both <- pa_data_with_both %>%\n  group_by(game_year, batter, potential_next_batter) %>%\n  mutate(combo_count = n()) %>%\n  ungroup() %>%\n  filter(combo_count >= 40) %>%\n  select(-combo_count)\n\n## Remove rows with missing season stats\npa_data_final <- pa_data_with_both %>%\n  filter(\n    !is.na(batter_xwOBA) & !is.na(batter_xSLG) & !is.na(batter_xBA) &\n    !is.na(batter_wOBA) & !is.na(batter_BA) & !is.na(batter_SLG) &\n    !is.na(next_batter_xwOBA) &\n    !is.na(next_batter_xSLG) &\n    !is.na(next_batter_xBA) &\n    !is.na(next_batter_wOBA) &\n    !is.na(next_batter_BA) &\n    !is.na(next_batter_SLG)\n  )\n```\n:::\n\n\n\nWe need four more columns: `walk_rate` (BB%), `strikeout_rate` (K%), `xbh_rate` (XBH%), and `pitches_per_pa` (P/PA).\n\nWe will get `walk_rate` and `strikeout_rate` from Fangraphs Leaderbaords using BaseballR, and find `xbh_rate` and `pitches_per_pa` manually using our `pa_data` dataset.\n\nFirst, we can get `xbh_rate` and `pitches_per_pa` manually.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_extra_metrics <- pa_data %>%\n  group_by(game_year, batter) %>%\n  summarize(\n    xbh_rate = mean(is_extra_base_hit, na.rm = TRUE),  # extra-base hit rate\n    pitches_per_pa = mean(pitches_per_pa, na.rm = TRUE),    # pitches per plate appearance\n    .groups = \"drop\"\n  ) %>%\n  mutate(game_year = factor(game_year), batter = factor(batter))\n\n## Join to add current batter's extra metrics.\npa_data_final <- pa_data_final %>%\n  left_join(\n    pa_extra_metrics %>% \n      select(game_year, batter, xbh_rate, pitches_per_pa) %>%\n      rename(\n        batter_xbh_rate    = xbh_rate,\n        batter_pitches_per_pa = pitches_per_pa\n      ),\n    by = c(\"game_year\", \"batter\")\n  )\n\n## Join to add next batter's extra metrics.\npa_data_final <- pa_data_final %>%\n  mutate(\n    potential_next_batter = as.factor(potential_next_batter)\n  ) %>%\n  left_join(\n    pa_extra_metrics %>% \n      select(game_year, batter, xbh_rate, pitches_per_pa) %>%\n      rename(\n        next_batter_xbh_rate    = xbh_rate,\n        next_batter_pitches_per_pa = pitches_per_pa\n      ),\n    by = c(\"game_year\", \"potential_next_batter\" = \"batter\")\n  )\n```\n:::\n\n\n\nLet's also get our `walk_rate` and `strikeout_rate` using BaseballR.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Function to get FanGraphs BB% and K% for qualified batters \n## from start_season to end_season (inclusive)\n\nget_fg_batter_rates <- function(start_season, end_season) {\n  # Create a vector of seasons as characters\n  seasons <- as.character(seq(start_season, end_season))\n  \n  # Loop over each season and scrape the batter leaderboard\n  fg_data_list <- lapply(seasons, function(season) {\n    message(\"Scraping FanGraphs batter leaders for season: \", season)\n    df <- fg_batter_leaders(\n      startseason = season,\n      endseason = season,\n      qual = \"y\",      # Only qualified hitters\n      ind = \"1\",       # Split seasons individually\n      pageitems = \"10000\"\n    )\n    # Select only the columns we need.\n    df %>% \n      select(Season, xMLBAMID, BB_pct, K_pct)\n  })\n  \n  # Bind rows together from all seasons\n  fg_data_all <- bind_rows(fg_data_list)\n  \n  # Rename Season to game_year, convert to numeric, and convert xMLBAMID to factor\n  fg_data_all <- fg_data_all %>%\n    rename(game_year = Season) %>%\n    mutate(\n      game_year = as.numeric(game_year),\n      xMLBAMID = as.factor(xMLBAMID)\n    )\n  \n  return(fg_data_all)\n}\n\n## Get FanGraphs batter rates for all seasons 2015-2024\nfg_rates_all <- get_fg_batter_rates(2015, 2024) %>%\n  mutate(game_year = as.factor(game_year), xMLBAMID = as.factor(xMLBAMID))\n\n## Join the scraped FanGraphs rates into pa_data_final\n# Join current batter rates.\npa_data_final <- pa_data_final %>%\n  # Make batter and potential_next_batter into factors\n  mutate(\n    batter = as.factor(batter),\n    potential_next_batter = as.factor(potential_next_batter)\n  ) %>%\n  left_join(\n    fg_rates_all,\n    by = c(\"game_year\", \"batter\" = \"xMLBAMID\")\n  ) %>%\n  rename(\n    batter_bb_pct = BB_pct,\n    batter_k_pct  = K_pct\n  )\n\n# Join next batter rates.\npa_data_final <- pa_data_final %>%\n  left_join(\n    fg_rates_all,\n    by = c(\"game_year\", \"potential_next_batter\" = \"xMLBAMID\")\n  ) %>%\n  rename(\n    next_batter_bb_pct = BB_pct,\n    next_batter_k_pct  = K_pct\n  )\n```\n:::\n\n\n\nNext, we'll add columns for `xwOBA_diff`, `xBA_diff`, and `xSLG_diff`, which are the differences between the current batter's xwOBA, xBA, and xSLG and the plate appearance's xwOBA, xBA, and xSLG.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate differences\npa_data_final <- pa_data_final %>%\n  mutate(\n    xwOBA_diff = pa_xwOBA - batter_xwOBA,\n    xBA_diff   = pa_xBA - batter_xBA,\n    xSLG_diff  = pa_xSLG - batter_xSLG\n  )\n```\n:::\n\n\n\nThe last thing we will do is ensure that all of the variables we expect to act non-linearly are factors for our models. Also, we will relevel the `baserunner_state` variable to make \"Empty\" the reference level.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert certain variables to factors\npa_data_final$batter_handedness <- factor(pa_data_final$batter_handedness)\npa_data_final$potential_next_batter_handedness <- factor(pa_data_final$potential_next_batter_handedness)\npa_data_final$batter <- factor(pa_data_final$batter)\npa_data_final$pitcher <- factor(pa_data_final$pitcher)\npa_data_final$baserunner_state <- factor(pa_data_final$baserunner_state)\npa_data_final$inning <- factor(pa_data_final$inning)\npa_data_final$game_year <- factor(pa_data_final$game_year)\n\npa_data_final$baserunner_state <- relevel(pa_data_final$baserunner_state, ref = \"Empty\")\n```\n:::\n\n\n\nAfter initial modeling, we'd like to add the pitcher's handedness to our dataset. We can do this by matching the `game_pk` and `at_bat_number` of the plate appearance with the same values in the `statcast_all_years` dataframe. This will give us the pitcher's handedness for each plate appearance. We'd also like to create a new variable that indicates the handedness matchup between the current batter and pitcher, as well as the potential next batter and pitcher.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data_final$pitcher_handedness <- statcast_all_years$p_throws[match(paste(pa_data_final$game_pk, pa_data_final$at_bat_number),\n                                                                 paste(statcast_all_years$game_pk, statcast_all_years$at_bat_number))]\n\n# Define factor variables with clear reference categories\npa_data_final <- pa_data_final %>%\n  mutate(\n    handedness_matchup = factor(\n      paste0(batter_handedness, \"_vs_\", pitcher_handedness),\n      levels = c(\"R_vs_R\", \"L_vs_R\", \"R_vs_L\", \"L_vs_L\")\n    ),\n    next_handedness_matchup = factor(\n      paste0(potential_next_batter_handedness, \"_vs_\", pitcher_handedness),\n      levels = c(\"R_vs_R\", \"L_vs_R\", \"R_vs_L\", \"L_vs_L\")\n    )\n  )\n\npa_data_final <- pa_data_final %>%\n  mutate(\n    handedness_matchup = relevel(factor(handedness_matchup), ref = \"R_vs_R\"),\n    next_handedness_matchup = relevel(factor(next_handedness_matchup), ref = \"R_vs_R\")\n  )\n```\n:::\n\n\n\nHowever, when we incorporate `handedness_matchup` and `next_handedness_matchup` into the model, we get a warning that the fixed-effect model matrix is rank deficient. This is because So we know: `batter_handedness`, `potential_next_batter_handedness`, and `pitcher_handedness`, so `handedness_matchup` and `next_handedness_matchup` are not independent. The model can't tell what effects belong to which matchup cleanly without creating overlap. Instead, we can create two new variables: `current_matchup_advantage` and `next_matchup_advantage`. These will be `1` if the batter's handedness is opposite to the pitcher's handedness, and `0` otherwise. This way, we can still capture the matchup effects without creating a rank deficiency.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data_final <- pa_data_final %>%\n  mutate(\n    current_matchup_advantage = if_else(batter_handedness != pitcher_handedness, 1, 0),\n    next_matchup_advantage    = if_else(potential_next_batter_handedness != pitcher_handedness, 1, 0)\n  )\n```\n:::\n\n\n\nWe will want to filter `pa_data_final` one more time so that each pitcher has at least 30 plate appearances in a given year. This is to ensure that we have enough data to make reliable estimates for each pitcher, but in our models, Bayesian shrinkage will ensure that no pitcher with a small sample size will have inflated random effects anyway.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count number of plate appearances per pitcher per year\npitcher_counts <- pa_data_final %>%\n  group_by(pitcher, game_year) %>%\n  summarize(n_pa = n(), .groups = \"drop\") %>%\n  filter(n_pa >= 30)\n\n# Filter dataset to just those pitchers\npa_data_final <- pa_data_final %>%\n  mutate(pitcher_year = interaction(pitcher, game_year)) %>%\n  filter(pitcher_year %in% interaction(pitcher_counts$pitcher, pitcher_counts$game_year))\n\npa_data_final = pa_data_final %>%\n  mutate(batter_year = interaction(batter, game_year))\n```\n:::\n\n\n\nThis is the final `pa_data_final` we will use for modeling.\n\n## Models/Outputs\n\nThis is `m_protection_1`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_protection_1 <- feols(\n  pa_xwOBA ~ next_batter_xwOBA + current_matchup_advantage + \n    next_matchup_advantage + baserunner_state + outs_when_up + run_diff | \n    batter_year + pitcher_year,  # Fixed effects\n  data = pa_data_final\n)\n\nsummary(m_protection_1)\n```\n:::\n\n\n\nAnd to find if the coefficient for `batter_xwOBA` is signficantly different than 1, we do the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoefs <- summary(m_protection_1)$coefficients\nbeta_hat <- coefs[\"batter_xwOBA\", \"Estimate\"]\nse <- coefs[\"batter_xwOBA\", \"Std. Error\"]\ndf <- coefs[\"batter_xwOBA\", \"df\"]\n\nt_stat <- (beta_hat - 1) / se\np_val <- 2 * (1 - pt(abs(t_stat), df))\n\ncat(\"t =\", round(t_stat, 4), \"\\n\")\ncat(\"df =\", round(df, 1), \"\\n\")\ncat(\"p =\", round(p_val, 4), \"\\n\")\n```\n:::\n\n\n\nAnd `m_protection_2`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_protection_2 <- feols(\n  xwOBA_diff ~ next_batter_xwOBA + current_matchup_advantage + \n    next_matchup_advantage + baserunner_state + outs_when_up + run_diff | \n    pitcher_year,  # Fixed effects\n  data = pa_data_final\n)\n\nsummary(m_protection_2)\n```\n:::\n\n\n\nNext, let's generate Model 3, `m_protection_slope`, which includes a random slope for `next_batter_xwOBA`. To do this, we will further restrict pitcher counts to be at least 100 Plate Appearances, so that we can more reliably trust the random slope estimates.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count number of plate appearances per pitcher per year\npitcher_counts <- pa_data_final %>%\n  group_by(pitcher, game_year) %>%\n  summarize(n_pa = n(), .groups = \"drop\") %>%\n  filter(n_pa >= 100)\n\n# Filter dataset to just those pitchers\npa_filtered <- pa_data_final %>%\n  mutate(pitcher_year = interaction(pitcher, game_year)) %>%\n  filter(pitcher_year %in% interaction(pitcher_counts$pitcher, pitcher_counts$game_year))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nm_protection_slope <- lmer(\n  pa_xwOBA ~ batter_xwOBA + next_batter_xwOBA +\n    current_matchup_advantage + next_matchup_advantage +\n    baserunner_state + outs_when_up + run_diff +\n    (1 + next_batter_xwOBA || pitcher_year),  # uncorrelated random effects\n  data = pa_filtered\n)\n\nsummary(m_protection_slope)\n```\n:::\n\n\n\nAnd this is the creation of our HTML table for our outputs:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef_map <- list(\n  \"(Intercept)\" = \"Intercept\",\n  \"batter_xwOBA\" = \"Batter xwOBA\",\n  \"next_batter_xwOBA\" = \"Next Batter xwOBA\",\n  \"current_matchup_advantage\" = \"Current Matchup\",\n  \"next_matchup_advantage\" = \"Next Matchup\",\n  \"baserunner_state1B\" = \"1B\",\n  \"baserunner_state1B-2B\" = \"1B-2B\",\n  \"baserunner_state1B-3B\" = \"1B-3B\",\n  \"baserunner_state2B\" = \"2B\",\n  \"baserunner_state2B-3B\" = \"2B-3B\",\n  \"baserunner_state3B\" = \"3B\",\n  \"baserunner_stateLoaded\" = \"Loaded\",\n  \"outs_when_up\" = \"Outs\",\n  \"run_diff\" = \"Run Diff\"\n)\n\n\nm_protection_1_2_3_output = htmlreg(\n  list(m_protection_1, m_protection_2, m_protection_slope),\n  custom.coef.map = coef_map,\n  custom.model.names = c(\"Model 1: FE xwOBA\", \"Model 2: xwOBA Diff\", \"Model 3: RE Slope\"),\n  stars = c(0.05, 0.01, 0.001),\n  digits = 4,\n  caption = \"Comparison of Mixed Effects Models\",\n  inline.css = TRUE\n)\n\n# Post-process using base R compatible piping\nm_protection_1_2_3_output <- m_protection_1_2_3_output |>\n  (\\(x) gsub(\"pitcher_year\\\\.1 next_batter_xwOBA\", \"PitcherYear Ã— Next Batter xwOBA\", x))() |>\n  (\\(x) gsub(\"pitcher_year\", \"PitcherYear\", x))() |>\n  (\\(x) gsub(\"batter_year\", \"BatterYear\", x))()\n\nwriteLines(m_protection_1_2_3_output, \"outputs/m_protection_1_2_3_output.html\")\n```\n:::\n\n\n\nNow, let's inspect the random slopes from Model 3, `m_protection_slope`. We will first get year-over-year correlations to see if the random slopes are consistent across years. We will do this by first extracting the random effects from the model, then separating the pitcher and year from the row names. We will then loop through each year pair and calculate the correlation between the random slopes for that year pair.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Extract and prepare random slope data\nre_df <- ranef(m_protection_slope)$pitcher_year %>%\n  as.data.frame() %>%\n  rownames_to_column(var = \"pitcher_year\") %>%\n  separate(pitcher_year, into = c(\"pitcher\", \"year\"), sep = \"\\\\.\", convert = TRUE)\n\n## Initialize result list\nyoy_results <- list()\n\n## Get list of unique years\nyears <- sort(unique(re_df$year))\n\n## Loop through year pairs, skipping 2020-related transitions\nfor (i in 1:(length(years) - 1)) {\n  y1 <- years[i]\n  y2 <- years[i + 1]\n  \n  # Skip 2019-2020 and 2020-2021\n  if (y1 == 2019 && y2 == 2020) next\n  if (y1 == 2020 && y2 == 2021) next\n  \n  df_pair <- re_df %>%\n    filter(year %in% c(y1, y2)) %>%\n    select(pitcher, year, next_batter_xwOBA) %>%\n    pivot_wider(names_from = year, values_from = next_batter_xwOBA, names_prefix = \"xwOBA_\") %>%\n    drop_na()\n  \n  cor_val <- cor(df_pair[[paste0(\"xwOBA_\", y1)]], df_pair[[paste0(\"xwOBA_\", y2)]])\n  \n  yoy_results[[paste0(y1, \" to \", y2)]] <- list(\n    from = y1,\n    to = y2,\n    correlation = cor_val,\n    n_shared_pitchers = nrow(df_pair)\n  )\n}\n\n## Add a 2019 to 2021 jump (skip 2020)\ndf_2019_2021 <- re_df %>%\n  filter(year %in% c(2019, 2021)) %>%\n  select(pitcher, year, next_batter_xwOBA) %>%\n  pivot_wider(names_from = year, values_from = next_batter_xwOBA, names_prefix = \"xwOBA_\") %>%\n  drop_na()\n\ncor_2019_2021 <- cor(df_2019_2021$xwOBA_2019, df_2019_2021$xwOBA_2021)\n\nyoy_results[[\"2019 to 2021\"]] <- list(\n  from = 2019,\n  to = 2021,\n  correlation = cor_2019_2021,\n  n_shared_pitchers = nrow(df_2019_2021)\n)\n\n## Convert to dataframe\nyoy_df <- bind_rows(yoy_results, .id = \"year_pair\")\n\n## Clean and order labels\nyoy_df <- yoy_df %>%\n  mutate(\n    year_label = factor(year_pair, levels = year_pair[order(from)]),\n    z = atanh(correlation),  # Fisher z-transform\n    se = 1 / sqrt(n_shared_pitchers - 3),\n    z_low = z - 1.96 * se,\n    z_high = z + 1.96 * se,\n    ci_lower = tanh(z_low),\n    ci_upper = tanh(z_high)\n  )\n\n## Plot with CI and cleaner styling\nyoy_graph <- ggplot(yoy_df, aes(x = year_label, y = correlation)) +\n  geom_col(fill = \"#003087\") +  # Yankee Blue\n  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0.2, color = \"black\") +\n  geom_text(aes(label = round(correlation, 3)), vjust = 1.5, color = \"white\", size = 4) +\n  scale_y_continuous(limits = c(0, 1), expand = expansion(mult = c(0, 0.05))) +\n  labs(\n    title = \"Year-over-Year Correlation of\\nRandom Slopes (Next Batter xwOBA)\",\n    x = \"Year Pair\",\n    y = \"Correlation\"\n  ) +\n  theme_pub() +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.title = element_text(size = 14, face = \"bold\"),\n    axis.text = element_text(size = 11),\n    axis.title = element_text(size = 12)\n  )\n\n# Save Graph to Outputs\nggsave(\"outputs/yoy_correlation_plot.png\", plot = yoy_graph, width = 8, height = 5)\n```\n:::\n\n\n\nWe can also graph just the 2023-2024 pairing as an example.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Prepare re_23_24\nre_23_24 <- re_df %>%\n  filter(year %in% c(2023, 2024)) %>%\n  select(pitcher, year, next_batter_xwOBA) %>%\n  pivot_wider(names_from = year, values_from = next_batter_xwOBA, names_prefix = \"xwOBA_\") %>%\n  drop_na()\n\n# 2. Load Chadwick data to get pitcher names\nbase_url <- \"https://raw.githubusercontent.com/chadwickbureau/register/master/data/\"\nsuffixes <- c(0:9, letters[1:6])\nfile_urls <- paste0(base_url, \"people-\", suffixes, \".csv\")\n\npeople <- map_dfr(file_urls, ~ read_csv(.x, col_types = cols(.default = \"c\")))\n\npeople_clean <- people %>%\n  select(key_mlbam, name_first, name_last) %>%\n  mutate(key_mlbam = as.integer(key_mlbam))\n\n# 3. Merge names into re_23_24\n# Join pitcher names to the 2023â€“2024 data\nre_23_24_named <- re_23_24 %>%\n  left_join(people_clean, by = c(\"pitcher\" = \"key_mlbam\")) %>%\n  mutate(\n    label = paste0(\n      name_first, \" \", name_last, \"<br>\",\n      \"2023: \", round(xwOBA_2023, 4), \"<br>\",\n      \"2024: \", round(xwOBA_2024, 4), \"<br>\",\n      \"MLBAM ID: \", pitcher\n    )\n  )\n\n# Fit the linear model\nmodel <- lm(xwOBA_2024 ~ xwOBA_2023, data = re_23_24_named)\n\n# Create prediction data\nx_vals <- seq(min(re_23_24_named$xwOBA_2023), max(re_23_24_named$xwOBA_2023), length.out = 100)\npreds <- predict(model, newdata = data.frame(xwOBA_2023 = x_vals), interval = \"confidence\")\n\npred_df <- data.frame(\n  xwOBA_2023 = x_vals,\n  fit = preds[, \"fit\"],\n  lwr = preds[, \"lwr\"],\n  upr = preds[, \"upr\"]\n)\n\n# Base ggplot with updated color scheme\ngg_base <- ggplot(re_23_24_named, aes(x = xwOBA_2023, y = xwOBA_2024, text = label)) +\n  geom_point(alpha = 0.75, color = \"#003087\", size = 2) +  # navy points\n  geom_ribbon(data = pred_df, aes(x = xwOBA_2023, ymin = lwr, ymax = upr),\n              inherit.aes = FALSE, fill = \"#F7879A\", alpha = 0.3) +  # soft ribbon\n  geom_line(data = pred_df, aes(x = xwOBA_2023, y = fit),\n            inherit.aes = FALSE, color = \"#e63946\", linewidth = 1.1) +  # steel blue line\n  labs(\n    title = \"Pitcher Susceptibility to Lineup Protection (2023 vs. 2024)\",\n    subtitle = paste0(\"r = \", round(cor(re_23_24_named$xwOBA_2023, re_23_24_named$xwOBA_2024), 3)),\n    x = \"Random Slope on Next Batter xwOBA (2023)\",\n    y = \"Random Slope on Next Batter xwOBA (2024)\"\n  ) +\n  theme_pub() +\n  theme(\n    plot.title = element_text(size = 14, face = \"bold\"),\n    plot.subtitle = element_text(size = 11),\n    axis.title = element_text(size = 12),\n    axis.text = element_text(size = 11)\n  )\n\n#  Convert to plotly\nplotly_graph <- ggplotly(gg_base, tooltip = \"text\") %>%\n  layout(\n    title = list(\n      text = paste0(\"Pitcher Susceptibility to Lineup Protection (2023 vs. 2024)<br><sup>r = \", \n                    round(cor(re_23_24_named$xwOBA_2023, re_23_24_named$xwOBA_2024), 3), \"</sup>\"),\n      font = list(size = 18, family = \"Arial\", color = \"black\")\n    ),\n    xaxis = list(title = list(text = \"Random Slope on Next Batter xwOBA (2023)\", font = list(size = 14, family = \"Arial\", color = \"grey\"))),\n    yaxis = list(title = list(text = \"Random Slope on Next Batter xwOBA (2024)\", font = list(size = 14, family = \"Arial\", color = \"grey\"))),\n    font = list(family = \"Arial\", size = 12, color = \"black\")\n  )\n```\n:::\n\n\n\nWe'd also like to test for see if our correlations are all significantly greater than 0.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_correlations <- function(cor_df) {\n  cor_df %>%\n    mutate(\n      t_stat = correlation * sqrt(n_shared_pitchers - 2) / sqrt(1 - correlation^2),\n      df = n_shared_pitchers - 2,\n      p_value = pt(t_stat, df = df, lower.tail = FALSE),  # one-sided test: greater than 0\n      significant = ifelse(p_value < 0.05, \"Yes\", \"No\")\n    ) %>%\n    select(year_pair, correlation, t_stat, df, p_value)\n}\n\ncor_test_results <- test_correlations(yoy_df)\nprint(cor_test_results)\n```\n:::\n\n\n\nLet's save it as an HTML table.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare the data\ncor_test_results_clean <- cor_test_results %>%\n  mutate(\n    correlation = round(correlation, 3),\n    t_stat = round(t_stat, 2),\n    p_value = signif(p_value, 3)\n  ) %>%\n  mutate(from = as.numeric(sub(\"^(\\\\d{4}).*\", \"\\\\1\", year_pair))) %>%\n  arrange(from) %>%\n  select(-from)\n\n# Create the table\ngt_table <- cor_test_results_clean %>%\n  gt() %>%\n  tab_header(\n    title = md(\"**One-Sided t-Tests for Year-over-Year Correlation of Random Slopes**\"),\n    subtitle = md(\"Each test evaluates whether the correlation between random slopes for a given year pair is significantly greater than 0.\")\n  ) %>%\n  cols_label(\n    year_pair = \"Year Pair\",\n    correlation = \"Correlation\",\n    t_stat = \"t Statistic\",\n    df = \"Degrees of Freedom\",\n    p_value = \"p-value\"\n  ) %>%\n  fmt_number(columns = c(correlation, p_value), decimals = 3) %>%\n  fmt_number(columns = t_stat, decimals = 2) %>%\n  tab_options(\n    table.font.names = \"Times\",\n    table.font.size = 12,\n    heading.title.font.size = 14,\n    heading.subtitle.font.size = 12,\n    table.align = \"center\",\n    data_row.padding = px(6),\n    column_labels.font.weight = \"bold\"\n  )\n\n# Save as HTML\ngtsave(gt_table, \"outputs/correlation_t_tests.html\")\n```\n:::\n\n\n\nNext, we want to compute top/bottom 10 lists for the random slopes for each pitcher from 2015-2024.\n\nFirst, we will create a dataframe with the random slopes for each pitcher and year.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npitcher_pa_counts <- pa_data_final %>%\n  group_by(pitcher, game_year) %>%\n  summarize(pa_count = n(), .groups = \"drop\")\n```\n:::\n\n\n\nNext, we can merge in random efffects data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nre_df_weighted <- re_df %>%\n  mutate(pitcher = factor(pitcher), year = factor(year)) %>%\n  left_join(pitcher_pa_counts, by = c(\"pitcher\", \"year\" = \"game_year\")) %>%\n  filter(!is.na(pa_count))  # drop missing matches just in case\n```\n:::\n\n\n\nNow, we can calculate the weighted slope for each pitcher. We will use the `weighted.mean` function to get the weighted average of the random slopes, using the plate appearance counts as weights.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeople_clean = people_clean %>%\n  mutate(key_mlbam = factor(key_mlbam))\npitcher_sensitivity_weighted <- re_df_weighted %>%\n  group_by(pitcher) %>%\n  summarize(\n    weighted_slope = weighted.mean(next_batter_xwOBA, pa_count, na.rm = TRUE),\n    total_pa = sum(pa_count, na.rm = TRUE),\n    n_years = n()\n  ) %>%\n  left_join(people_clean, by = c(\"pitcher\" = \"key_mlbam\")) %>%\n  mutate(name = paste(name_first, name_last)) %>%\n  select(name, pitcher, weighted_slope, total_pa, n_years)\n```\n:::\n\n\n\nNow, we can get the top and bottom 10 pitchers by weighted slope.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npitcher_sensitivity_weighted <- pitcher_sensitivity_weighted %>%\n  filter(total_pa >= 200)\n\ntop_10_weighted <- pitcher_sensitivity_weighted %>%\n  arrange(desc(weighted_slope)) %>% \n  slice(1:10)\n\nbottom_10_weighted <- pitcher_sensitivity_weighted %>%\n  arrange(weighted_slope) %>% \n  slice(1:10)\n```\n:::\n\n\n\nWe can also do this just for 2024:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ensure the join worked and filter for 2024\nre_df_2024_weighted <- re_df %>%\n  mutate(pitcher = factor(pitcher), year = factor(year)) %>%\n  left_join(pitcher_pa_counts, by = c(\"pitcher\", \"year\" = \"game_year\")) %>%\n  filter(year == 2024, !is.na(pa_count))\n\n# Compute weighted average slope per pitcher (though for 2024 there is only one slope per pitcher)\n# So we just keep relevant columns and sort\ntop_bottom_2024 <- re_df_2024_weighted %>%\n  select(pitcher, pa_count, next_batter_xwOBA) %>%\n  arrange(desc(next_batter_xwOBA))  # descending order for positive sensitivities\n\n# Top 10 most positively affected pitchers\ntop_10 <- top_bottom_2024 %>% slice(1:10) %>%\n  left_join(people_clean, by = c(\"pitcher\" = \"key_mlbam\")) %>%\n  select(name_first, name_last, pitcher, next_batter_xwOBA, pa_count)\n\n# Bottom 10 most negatively affected pitchers\nbottom_10 <- top_bottom_2024 %>% arrange(next_batter_xwOBA) %>% slice(1:10) %>%\n  left_join(people_clean, by = c(\"pitcher\" = \"key_mlbam\")) %>%\n  select(name_first, name_last, pitcher, next_batter_xwOBA, pa_count)\n\n\n# Top 10 negatively affected pitchers\ntop_10_re_table <- top_10 %>%\n  gt() %>%\n  tab_header(\n    title = md(\"**Top 10 Pitchers Negatively Affected by Lineup Protection (2024)**\"),\n    subtitle = md(\"Ranked by Random Slope on Next Batter xwOBA\")\n  ) %>%\n  cols_label(\n    name_first = \"First Name\",\n    name_last = \"Last Name\",\n    pitcher = \"MLBAM ID\",\n    next_batter_xwOBA = \"Random Slope\",\n    pa_count = \"Plate Appearances\"\n  ) %>%\n  fmt_number(columns = next_batter_xwOBA, decimals = 4) %>%\n  fmt_number(columns = pa_count, decimals = 0, sep_mark = \",\") %>%\n  tab_options(\n    table.font.names = \"Times\",\n    table.font.size = 12,\n    heading.title.font.size = 14,\n    heading.subtitle.font.size = 12,\n    table.align = \"center\",\n    data_row.padding = px(6),\n    column_labels.font.weight = \"bold\"\n  )\n\n# Save top 10 table\ngtsave(top_10_re_table, \"outputs/top_10_lineup_protection_2024.html\")\n\n# Top 10 positively affected pitchers\nbottom_10_re_table <- bottom_10 %>%\n  gt() %>%\n  tab_header(\n    title = md(\"**Top 10 Pitchers Positively Affected by Lineup Protection (2024)**\"),\n    subtitle = md(\"Ranked by Random Slope on Next Batter xwOBA\")\n  ) %>%\n  cols_label(\n    name_first = \"First Name\",\n    name_last = \"Last Name\",\n    pitcher = \"MLBAM ID\",\n    next_batter_xwOBA = \"Random Slope\",\n    pa_count = \"Plate Appearances\"\n  ) %>%\n  fmt_number(columns = next_batter_xwOBA, decimals = 4) %>%\n  fmt_number(columns = pa_count, decimals = 0, sep_mark = \",\") %>%\n  tab_options(\n    table.font.names = \"Times\",\n    table.font.size = 12,\n    heading.title.font.size = 14,\n    heading.subtitle.font.size = 12,\n    table.align = \"center\",\n    data_row.padding = px(6),\n    column_labels.font.weight = \"bold\"\n  )\n\n# Save bottom 10 table\ngtsave(bottom_10_re_table, \"outputs/bottom_10_lineup_protection_2024.html\")\n```\n:::\n\n\n\n#### 1B. Drivers of Overall Offensive Effect\n\nLet's now create `m_protection_walk`, `m_protection_strikeout`, `m_protection_hit`, `m_protection_xbh`, and `m_protection_ip_out` to try to decompose the drivers of our coefficients in the models above.\n\nWe can first add `is_hit` and `is_ip_out` to our dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data_final <- pa_data_final %>%\n  mutate(final_event = tolower(final_event)) %>%\n  mutate(\n    is_hit = final_event %in% c(\"single\", \"double\", \"triple\", \"home_run\"),\n    is_ip_out = final_event %in% c(\n      \"field_out\", \"force_out\", \"grounded_into_double_play\",\n      \"strikeout\", \"strikeout_double_play\", \"lineout\", \"flyout\",\n      \"fielders_choice\", \"fielders_choice_out\", \"triple_play\"\n    )\n  )\n```\n:::\n\n\n\nNow, we can make our models: `m_protection_walk`, `m_protection_strikeout`, `m_protection_xbh`, `m_protection_hit`, `m_protection_ip_out`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_protection_walk <- feglm(\n  is_walk ~ next_batter_xwOBA + current_matchup_advantage +\n    next_matchup_advantage + baserunner_state + outs_when_up + run_diff |\n    batter_year + pitcher_year,\n  data = pa_data_final,\n  family = \"binomial\"\n)\n\nm_protection_strikeout <- feglm(\n  is_strikeout ~ next_batter_xwOBA + current_matchup_advantage +\n    next_matchup_advantage + baserunner_state + outs_when_up + run_diff |\n    batter_year + pitcher_year,\n  data = pa_data_final,\n  family = \"binomial\"\n)\n\nm_protection_xbh <- feglm(\n  is_extra_base_hit ~ next_batter_xwOBA + current_matchup_advantage +\n    next_matchup_advantage + baserunner_state + outs_when_up + run_diff |\n    batter_year + pitcher_year,\n  data = pa_data_final,\n  family = \"binomial\"\n)\n\nm_protection_hit <- feglm(\n  is_hit ~ next_batter_xwOBA + current_matchup_advantage +\n    next_matchup_advantage + baserunner_state + outs_when_up + run_diff |\n    batter_year + pitcher_year,\n  data = pa_data_final,\n  family = \"binomial\"\n)\n\nm_protection_ip_out <- feglm(\n  is_ip_out ~ next_batter_xwOBA + current_matchup_advantage +\n    next_matchup_advantage + baserunner_state + outs_when_up + run_diff |\n    batter_year + pitcher_year,\n  data = pa_data_final,\n  family = \"binomial\"\n)\n```\n:::\n\n\n\n\nAnd we can make a texreg table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtmlreg(\n  list(\n    m_protection_walk,\n    m_protection_strikeout,\n    m_protection_xbh,\n    m_protection_hit,\n    m_protection_ip_out\n  ),\n  file = \"outputs/m_protection_event_output.html\",\n  custom.model.names = c(\"Walk\", \"Strikeout\", \"XBH\", \"Hit\", \"In-Play Out\"),\n  stars = c(0.001, 0.01, 0.05, 0.1),\n  custom.note = \"Standard errors in parentheses. *** p < 0.001, ** p < 0.01, * p < 0.05, . p < 0.1\",\n  custom.coef.map = list(\n    \"next_batter_xwOBA\" = \"Next Batter xwOBA\",\n    \"current_matchup_advantage\" = \"Current Matchup\",\n    \"next_matchup_advantage\" = \"Next Matchup\",\n    \"baserunner_state1B\" = \"1B\",\n    \"baserunner_state1B-2B\" = \"1B-2B\",\n    \"baserunner_state1B-3B\" = \"1B-3B\",\n    \"baserunner_state2B\" = \"2B\",\n    \"baserunner_state2B-3B\" = \"2B-3B\",\n    \"baserunner_state3B\" = \"3B\",\n    \"baserunner_stateLoaded\" = \"Loaded\",\n    \"outs_when_up\" = \"Outs\",\n    \"run_diff\" = \"Run Diff\"\n  ),\n  digits = 4,\n  caption = \"Table: Fixed-Effects Linear Models Predicting Distinct PA Events\",\n  single.row = TRUE\n)\n```\n:::\n\n\n\n## II. Increased Interpretability: xBA\n\nFor increased interpretability, we will also make a model for xBA.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_protection_xBA <- feols(\n  pa_xBA ~ next_batter_xwOBA + current_matchup_advantage + \n    next_matchup_advantage + baserunner_state + outs_when_up + run_diff | \n    batter_year + pitcher_year,  # Fixed effects\n  data = pa_data_final\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhtmlreg(\n  m_protection_xBA,\n  file = \"outputs/m_protection_xBA_output.html\",\n  stars = c(0.001, 0.01, 0.05, 0.1),\n  digits = 4,\n  custom.coef.map = list(\n    \"next_batter_xwOBA\" = \"Next Batter xwOBA\",\n    \"current_matchup_advantage\" = \"Current Matchup Advantage\",\n    \"next_matchup_advantage\" = \"Next Matchup Advantage\",\n    \"baserunner_state1B\" = \"Runner on 1B\",\n    \"baserunner_state1B-2B\" = \"Runners on 1B & 2B\",\n    \"baserunner_state1B-3B\" = \"Runners on 1B & 3B\",\n    \"baserunner_state2B\" = \"Runner on 2B\",\n    \"baserunner_state2B-3B\" = \"Runners on 2B & 3B\",\n    \"baserunner_state3B\" = \"Runner on 3B\",\n    \"baserunner_stateLoaded\" = \"Bases Loaded\",\n    \"outs_when_up\" = \"Outs When Up\",\n    \"run_diff\" = \"Run Differential\"\n  ),\n  custom.model.names = \"xBA\",\n  custom.note = \"Standard errors clustered by batter-year. *** p < 0.001, ** p < 0.01, * p < 0.05, . p < 0.1\",\n  caption = \"Table: Fixed-Effects Linear Model Predicting Expected Batting Average (xBA)\",\n  single.row = TRUE\n)\n```\n:::\n\n\n\n## III. Model Selection\nFor Model Selection, we will want to compare `m_protection_1` and `m_protection_slope`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fixest)\nlibrary(lme4)\nlibrary(rsample)\nlibrary(yardstick)\nlibrary(dplyr)\nlibrary(purrr)\n\n# Use filtered dataset\ncommon_data <- pa_filtered  # or define it explicitly if needed\n\n# Create 5-fold CV splits\nset.seed(123)\nfolds <- vfold_cv(pa_filtered, v = 5)\n\n# Function to fit feols model and return RMSE\nfit_feols_rmse <- function(split) {\n  train <- analysis(split)\n  test <- assessment(split)\n  \n  model <- feols(\n    pa_xwOBA ~ next_batter_xwOBA + current_matchup_advantage + \n      next_matchup_advantage + baserunner_state + outs_when_up + run_diff | \n      batter_year + pitcher_year,\n    data = train\n  )\n  \n  preds <- predict(model, newdata = test)\n  rmse_vec(truth = test$pa_xwOBA, estimate = preds)\n}\n\n# Function to fit lmer model and return RMSE\nfit_lmer_rmse <- function(split) {\n  train <- analysis(split)\n  test <- assessment(split)\n  \n  model <- lmer(\n    pa_xwOBA ~ batter_xwOBA + next_batter_xwOBA +\n      current_matchup_advantage + next_matchup_advantage +\n      baserunner_state + outs_when_up + run_diff +\n      (1 + next_batter_xwOBA || pitcher_year),\n    data = train\n  )\n  \n  preds <- predict(model, newdata = test, allow.new.levels = TRUE)\n  rmse_vec(truth = test$pa_xwOBA, estimate = preds)\n}\n\n# Apply to all folds\nresults <- folds %>%\n  mutate(\n    RMSE_feols = map_dbl(splits, fit_feols_rmse),\n    RMSE_lmer = map_dbl(splits, fit_lmer_rmse)\n  )\n\n# Summarize results\nresults_summary <- results %>%\n  summarise(\n    mean_feols = mean(RMSE_feols),\n    mean_lmer = mean(RMSE_lmer)\n  )\n\nresults\n```\n:::\n\n\n\nWe will now want to see which fixed effects actually matter for `m_protection_slope`, and we will perform   to see if dropping each of the fixed effects significantly changes the model fit.\n\n\nOr we can\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get drop1 output\ndrop1_output <- drop1(m_protection_slope, test = \"F\")\n\n# Clean and format the data\ndrop1_df <- drop1_output %>%\n  as.data.frame() %>%\n  tibble::rownames_to_column(var = \"Dropped Term\") %>%\n  filter(`Dropped Term` != \"<none>\") %>%\n  mutate(\n    `Dropped Term` = recode(`Dropped Term`,\n      \"batter_xwOBA\" = \"Batter xwOBA\",\n      \"next_batter_xwOBA\" = \"Next Batter xwOBA\",\n      \"current_matchup_advantage\" = \"Current Matchup\",\n      \"next_matchup_advantage\" = \"Next Matchup\",\n      \"baserunner_state\" = \"Baserunner State\",\n      \"outs_when_up\" = \"Outs\",\n      \"run_diff\" = \"Run Diff\"\n    ),\n    `Signif.` = case_when(\n      `Pr(>F)` < 0.001 ~ \"***\",\n      `Pr(>F)` < 0.01  ~ \"**\",\n      `Pr(>F)` < 0.05  ~ \"*\",\n      `Pr(>F)` < 0.1   ~ \".\",\n      TRUE             ~ \"\"\n    )\n  )\n\n# Build nice-looking gt table\ndrop1_df  = drop1_df %>%\n  gt() %>%\n  tab_header(\n    title = md(\"**Fixed Effect Importance via Drop-One F-tests**\"),\n    subtitle = md(\"Each test evaluates whether removing the fixed effect significantly worsens model fit\")\n  ) %>%\n  cols_label(\n    `Dropped Term` = \"Dropped Term\",\n    `Sum Sq` = \"Sum Sq\",\n    `Mean Sq` = \"Mean Sq\",\n    `NumDF` = \"Num DF\",\n    `DenDF` = \"Den DF\",\n    `F value` = \"F Statistic\",\n    `Pr(>F)` = \"p-value\",\n    `Signif.` = \"Signif.\"\n  ) %>%\n  fmt_number(columns = c(`Sum Sq`, `Mean Sq`, `F value`, `Pr(>F)`), decimals = 2) %>%\n  fmt_number(columns = c(`NumDF`, `DenDF`), decimals = 0, use_seps = TRUE) %>%\n  tab_source_note(md(\"Significance codes: *** p < 0.001, ** p < 0.01, * p < 0.05, . p < 0.1\")) %>%\n  opt_table_font(font = list(google_font(\"Times New Roman\"), default_fonts())) %>%\n  cols_align(align = \"center\", columns = everything())\n\n# Save the table\ngtsave(drop1_df, \"outputs/blog_1_model_selection.html\")\n```\n:::\n\n\n\nGiven this output, we can exclude Next Matchup Advantage and Run Differential from our final model, given that they do not significantly worsen model fit when they are omitted.\n\nWe will create two final models: `m_protection_blog_1_fe` and `m_protection_blog1_re`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_protection_blog_1_fe <- feols(\n  pa_xwOBA ~ next_batter_xwOBA + current_matchup_advantage +\n    baserunner_state + outs_when_up | batter_year + pitcher_year,\n  data = pa_data_final\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nm_protection_blog_1_re <- lmer(\n  pa_xwOBA ~ batter_xwOBA + next_batter_xwOBA + current_matchup_advantage +\n    baserunner_state + outs_when_up +\n    (1 + next_batter_xwOBA || pitcher_year),\n  data = pa_filtered\n)\n```\n:::\n\n\n\nThen, we will create an HTMLReg table to compare the two models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Clean model names\ncustom_model_names <- c(\"Model 1: Fixed Effects\", \"Model 2: Random Effects\")\n\n# 2. Clean coefficient names\ncustom_coefs <- list(\n  \"(Intercept)\" = \"Intercept\",\n  \"batter_xwOBA\" = \"Batter xwOBA\",\n  \"next_batter_xwOBA\" = \"Next Batter xwOBA\",\n  \"current_matchup_advantage\" = \"Current Matchup\",\n  \"baserunner_state1B\" = \"1B\",\n  \"baserunner_state1B-2B\" = \"1B-2B\",\n  \"baserunner_state1B-3B\" = \"1B-3B\",\n  \"baserunner_state2B\" = \"2B\",\n  \"baserunner_state2B-3B\" = \"2B-3B\",\n  \"baserunner_state3B\" = \"3B\",\n  \"baserunner_stateLoaded\" = \"Loaded\",\n  \"outs_when_up\" = \"Outs\"\n)\n\n# 3. Create HTML regression table\nblog_1_final_output = htmlreg(\n  list(m_protection_blog_1_fe, m_protection_blog_1_re),\n  custom.model.names = custom_model_names,\n  custom.coef.map = custom_coefs,\n  stars = c(0.001, 0.01, 0.05, 0.1),\n  custom.note = \"Standard errors in parentheses. *** p < 0.001, ** p < 0.01, * p < 0.05, . p < 0.1\",\n  caption = \"Comparison of Fixed and Random Effects Models for Plate Appearance xwOBA\",\n  single.row = TRUE,\n  digits = 4\n)\n\n# Post-process using base R compatible piping\nblog_1_final_output <- blog_1_final_output |>\n  (\\(x) gsub(\"pitcher_year\\\\.1 next_batter_xwOBA\", \"PitcherYear Ã— Next Batter xwOBA\", x))() |>\n  (\\(x) gsub(\"pitcher_year\", \"PitcherYear\", x))() |>\n  (\\(x) gsub(\"batter_year\", \"BatterYear\", x))()\n\nwriteLines(blog_1_final_output, \"outputs/blog_1_final_output.html\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}