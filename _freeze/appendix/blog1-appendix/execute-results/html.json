{
  "hash": "1d20b74acf45c816685b2c9380f9409e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Appendix: Blog Post #1\"\nauthor: \"Lance Brady\"\ndate: \"2025-02-18\"\ncategories: [lineup protection, lineups, statcast]\nformat: html\neditor: visual\nimage: blog1.jpg\nexecute:\n  eval: false\n---\n\n\n\nFirst, we loaded in our libraries and read the data, which contains almost every pitch from the 2024 season (excluding when poor data was retrieved).\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstatcast_data <- readRDS(\"data/statcast_all_years.rds\")\n```\n:::\n\n\n\nFor each plate appearance, we aggregate key variables. In this code, each plate appearance is identified by grouping on `game_pk` and `at_bat_number`, then we take the last pitch (using `which.max(pitch_number)`) to define final values for fields like `pa_xwOBA`, `pa_xBA`, and `pa_woba`. Specifically, `pa_xwOBA` is assigned the value from `estimated_woba_using_speedangle` on the last pitch, and similarly `pa_xBA` comes from `estimated_ba_using_speedangle`. We also create `pa_BA` as `1` if the `final_event` is `\"single\"`, `\"double\"`, `\"triple\"`, or `\"home_run\"`, and `pa_SLG` by mapping those same events to `1`, `2`, `3`, or `4` respectively. We compute `pitches_per_pa` via `n()`, reflecting how many pitches occurred in each plate appearance. Furthermore, we define `is_extra_base_hit` if `final_event` is `\"double\"`, `\"triple\"`, or `\"home_run\"`, `is_walk` if the `final_event` is `\"walk\"` or `\"intent_walk\"`, and `is_strikeout` if the `final_event` is `\"strikeout\"` or `\"strikeout_double_play\"`. Finally, the code calculates `run_diff` as the difference between `bat_score` and `fld_score` on the last pitch, capturing the score differential before the plate appearance’s outcome is officially applied.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data <- statcast_data %>%\n  group_by(game_pk, at_bat_number) %>%\n  summarize(\n    # Plate appearance identifiers and context from final pitch\n    game_year              = game_year[which.max(pitch_number)],\n    batter                 = batter[which.max(pitch_number)],\n    pitcher                = pitcher[which.max(pitch_number)],\n    inning                 = inning[which.max(pitch_number)],\n    inning_topbot          = inning_topbot[which.max(pitch_number)],\n    batter_handedness      = stand[which.max(pitch_number)],\n    outs_when_up           = outs_when_up[which.max(pitch_number)],\n    run_diff               = bat_score[which.max(pitch_number)] - fld_score[which.max(pitch_number)],\n    \n    # Final pitch values for this PA\n    pa_xwOBA               = estimated_woba_using_speedangle[which.max(pitch_number)],\n    pa_xSLG                = estimated_slg_using_speedangle[which.max(pitch_number)],\n    pa_xBA                 = estimated_ba_using_speedangle[which.max(pitch_number)],\n    pa_woba                = woba_value[which.max(pitch_number)],\n    on_1b                  = on_1b[which.max(pitch_number)],\n    on_2b                  = on_2b[which.max(pitch_number)],\n    on_3b                  = on_3b[which.max(pitch_number)],\n    final_event            = events[which.max(pitch_number)],\n\n    # Count pitches\n    pitches_per_pa         = n(),\n\n    .groups = \"drop\"\n  ) %>%\n  arrange(game_pk, inning, inning_topbot, at_bat_number) %>%\n  mutate(\n    # Basic batting stats\n    pa_BA  = if_else(final_event %in% c(\"single\", \"double\", \"triple\", \"home_run\"), 1, 0),\n    pa_SLG = case_when(\n      final_event == \"single\"   ~ 1,\n      final_event == \"double\"   ~ 2,\n      final_event == \"triple\"   ~ 3,\n      final_event == \"home_run\" ~ 4,\n      TRUE                      ~ 0\n    ),\n    is_extra_base_hit = final_event %in% c(\"double\", \"triple\", \"home_run\"),\n    is_walk           = final_event %in% c(\"walk\", \"intent_walk\"),\n    is_strikeout      = final_event %in% c(\"strikeout\", \"strikeout_double_play\")\n  )\n```\n:::\n\n\n\nWe then find the next batter in the lineup and get their handedness. We can first organize the plate appearances by the game, then which team is hitting (derived from `inning_topbot`, and the plate appearance `at_bat_number`. Except for the last plate appearance for a team in a game, we assume that the protection is coming from the player hitting in the following plate appearance. For the last plate appearance for a team in a game, we make the `potential_next_batter` simply the batter who followed the player the previous time they came up.\n\nThis even works when the last hitter (or both the last and penultimate) in the game is a pinch hitter, as we can look at the second (or third) to last hitter's previous plate appearance, then find who would be following the pinch hitter in the lineup.\n\nNote that this does not account for potential pinch hitters in the on-deck circle at the end of a game, pinch hitters who were in the on-deck circle at the time of the third out in an inning, and changes to a hitter in the middle of a plate appearance.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data <- pa_data %>%\n  ## Order by game, half-inning, and at-bat\n  arrange(game_pk, inning_topbot, at_bat_number) %>%\n  \n  ## Within each half-inning, define a naive next batter/handedness\n  group_by(game_pk, inning_topbot) %>%\n  mutate(\n    naive_next_batter                 = lead(batter),\n    naive_next_batter_handedness      = lead(batter_handedness),\n    # 2-ahead references\n    naive_next_next_batter            = lead(lead(batter)),\n    naive_next_next_batter_handedness = lead(lead(batter_handedness)),\n    # previous references\n    naive_previous_batter             = lag(batter),\n    naive_previous_batter_handedness  = lag(batter_handedness),\n    # 3-ahead references\n    naive_next_next_next_batter            = lead(lead(lead(batter))),\n    naive_next_next_next_batter_handedness = lead(lead(lead(batter_handedness))),\n    # previous-previous references\n    naive_previous_previous_batter            = lag(lag(batter)),\n    naive_previous_previous_batter_handedness = lag(lag(batter_handedness))\n  ) %>%\n  ungroup() %>%\n  \n  ## Wipe out cross-inning naive values\n  mutate(\n    same_half_inning = lead(game_pk) == game_pk & lead(inning_topbot) == inning_topbot,\n    naive_next_batter            = if_else(same_half_inning, naive_next_batter, NA_integer_),\n    naive_next_batter_handedness = if_else(same_half_inning, naive_next_batter_handedness, NA_character_)\n  ) %>%\n  \n  ## For each (game_pk, batter), fill down naive_next_batter\n  group_by(game_pk, batter) %>%\n  fill(naive_next_batter, naive_next_batter_handedness, .direction = \"down\") %>%\n  ungroup() %>%\n  \n  ## Fallback 1 -> Use naive_previous_batter groups\n  group_by(game_pk, naive_previous_batter) %>%\n  # Fill down naive_next_next_batter so each row in the group knows the last seen value\n  fill(naive_next_next_batter, naive_next_next_batter_handedness, .direction = \"down\") %>%\n  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      nth(naive_next_next_batter, n() - 1, default = NA_integer_),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      nth(naive_next_next_batter_handedness, n() - 1, default = NA_character_),\n      naive_next_batter_handedness\n    )\n  ) %>%\n  ungroup() %>%\n  \n  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter UNGROUPED\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      lag(naive_next_next_batter),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      lag(naive_next_next_batter_handedness),\n      naive_next_batter_handedness\n    )\n  ) %>%\n  \n  ## Fallback 2 -> Use naive_previous_previous_batter groups\n  group_by(game_pk, naive_previous_previous_batter) %>%\n  # Fill down naive_next_next_batter so each row in the group knows the last seen value\n  fill(naive_next_next_next_batter, naive_next_next_next_batter_handedness, .direction = \"down\") %>%\n  # If naive_next_batter is still NA, use the second-to-last row's naive_next_next_batter\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      nth(naive_next_next_next_batter, n() - 2, default = NA_integer_),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      nth(naive_next_next_next_batter_handedness, n() - 2, default = NA_character_),\n      naive_next_batter_handedness\n    )\n  ) %>%\n  ungroup() %>%\n  \n  # If naive_next_batter is still NA, use the third-to-last row's naive_next_next_next_batter UNGROUPED\n  mutate(\n    naive_next_batter = if_else(\n      is.na(naive_next_batter),\n      lag(lag(naive_next_next_next_batter)),\n      naive_next_batter\n    ),\n    naive_next_batter_handedness = if_else(\n      is.na(naive_next_batter_handedness),\n      lag(lag(naive_next_next_next_batter_handedness)),\n      naive_next_batter_handedness\n    )\n  ) %>%\n  \n  ## Rename & drop the extras\n  rename(\n    potential_next_batter            = naive_next_batter,\n    potential_next_batter_handedness = naive_next_batter_handedness\n  ) %>%\n  select(\n    -naive_next_next_batter,\n    -naive_next_next_batter_handedness,\n    -naive_previous_batter,\n    -naive_previous_batter_handedness,\n    -naive_next_next_next_batter,\n    -naive_next_next_next_batter_handedness,\n    -naive_previous_previous_batter,\n    -naive_previous_previous_batter_handedness\n  )\n```\n:::\n\n\n\nLet's also create a single baserunner state variable. We can simply check which of `on_1b`, `on_2b`, and `on_3b` have MLBAMIds and create strings based on that.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data <- pa_data %>%\n  mutate(\n    baserunner_state = case_when(\n      !is.na(on_1b) & is.na(on_2b) & is.na(on_3b) ~ \"1B\",\n      is.na(on_1b) & !is.na(on_2b) & is.na(on_3b) ~ \"2B\",\n      is.na(on_1b) & is.na(on_2b) & !is.na(on_3b) ~ \"3B\",\n      !is.na(on_1b) & !is.na(on_2b) & is.na(on_3b) ~ \"1B-2B\",\n      !is.na(on_1b) & is.na(on_2b) & !is.na(on_3b) ~ \"1B-3B\",\n      is.na(on_1b) & !is.na(on_2b) & !is.na(on_3b) ~ \"2B-3B\",\n      !is.na(on_1b) & !is.na(on_2b) & !is.na(on_3b) ~ \"Loaded\",\n      TRUE ~ \"Empty\"\n    )\n  )\n```\n:::\n\n\n\nFor the special case in which it is a tie game with 2 outs and bases loaded in the top of the ninth inning, protection will not matter. Thus, we can take out `potential_next_batter` in those scenarios.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data <- pa_data %>%\n  mutate(\n    # If it’s bottom of the 9th+ with 2 outs, bases loaded, and the game is tied,\n    # remove the potential next batter.\n    potential_next_batter = ifelse(\n      inning_topbot == \"Bot\" & \n        inning >= 9 & \n        outs_when_up == 2 & \n        baserunner_state == \"Loaded\" & \n        run_diff == 0,\n      NA,\n      potential_next_batter\n    )\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Can just read in pa_data if you want to skip the above steps\n## pa_data = readRDS(\"data/pa_data.rds\")\n```\n:::\n\n\n\nTo get our full-season statistics, we will create custom functions to extract Statcast data using BaseballR. We first create a function `get_expected_stats_one_year` that takes in a `year` value and `min_pa` value and outputs a dataframe with each player's—those that had the minimum plate appearances—expected statistics for that year. We chose 200 plate appearances, which is just 40% of the number of plate appearances needed to be qualified for that year, as a player's true value should stabilize around that many plate appearances, and we did not want to cut out too much data. We then use `get_expected_stats_all_years` to get expected statistics across all years of Statcast data (2015-2024).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_expected_stats_one_year <- function(year, min_pa = 200) {\n  # Scrape the \"expected_statistics\" leaderboard for one season\n  # with a minimum PA (e.g. 200).\n  df <- statcast_leaderboards(\n    leaderboard = \"expected_statistics\",\n    year = year,\n    min_pa = min_pa,   # 200\n    player_type = \"batter\"\n  )\n  \n  # Keep only relevant columns & rename them.\n  # The returned columns may include more, but these are typical:\n  # \"year\", \"player_id\", \"pa\", \"bip\", \"ba\", \"est_ba\", \"slg\",\n  # \"est_slg\", \"woba\", \"est_woba\", etc.\n  df <- df %>%\n    select(\n      year,\n      player_id,\n      pa,\n      ba,\n      est_ba,\n      slg,\n      est_slg,\n      woba,\n      est_woba\n      # if you want more columns, add them here\n    ) %>%\n    rename(\n      game_year    = year,      # aligns with pa_data's \"game_year\"\n      batter_id    = player_id, # aligns with pa_data's \"batter\" ID\n      batter_PA    = pa,\n      batter_BA    = ba,\n      batter_xBA   = est_ba,\n      batter_SLG   = slg,\n      batter_xSLG  = est_slg,\n      batter_wOBA  = woba,\n      batter_xwOBA = est_woba\n    )\n  \n  return(df)\n}\n\nget_expected_stats_all_years <- function(start_year, end_year, min_pa = 200) {\n  \n  # Loop over each year, scrape the leaderboard, store results\n  all_stats <- lapply(seq(start_year, end_year), function(yr) {\n    message(\"Scraping year: \", yr)\n    get_expected_stats_one_year(year = yr, min_pa = min_pa)\n  })\n  \n  # Combine all into one data frame\n  all_stats_df <- bind_rows(all_stats)\n  \n  return(all_stats_df)\n}\n```\n:::\n\n\n\nThen, once we put all years of batting statistics into a dataframe titled `batter_stats_all`, we will add it to our plate appearance-level data `pa_data` for both the current batter of each row and the next batter. We will only keep rows for which the next batter has followed the current batter for at least 40 plate appearances. We will remove rows for which there are not complete statistics.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Get all years of batting stats from 2015-2024\nbatter_stats_all <- get_expected_stats_all_years(2015, 2024, min_pa = 200)\n\n## Join with pa_data for current & next batters\npa_data_with_batter <- pa_data %>%\n  left_join(batter_stats_all, by = c(\"game_year\", \"batter\" = \"batter_id\"))\n\nnext_batter_stats_all <- batter_stats_all %>%\n  rename(\n    next_batter_PA    = batter_PA,\n    next_batter_BA    = batter_BA,\n    next_batter_xBA   = batter_xBA,\n    next_batter_SLG   = batter_SLG,\n    next_batter_xSLG  = batter_xSLG,\n    next_batter_wOBA  = batter_wOBA,\n    next_batter_xwOBA = batter_xwOBA\n  )\n\npa_data_with_both <- pa_data_with_batter %>%\n  left_join(next_batter_stats_all, by = c(\"game_year\", \n                                          \"potential_next_batter\" = \"batter_id\"))\n\n## Filter pairs with >= 40 PAs\npa_data_with_both <- pa_data_with_both %>%\n  group_by(game_year, batter, potential_next_batter) %>%\n  mutate(combo_count = n()) %>%\n  ungroup() %>%\n  filter(combo_count >= 40) %>%\n  select(-combo_count)\n\n## Remove rows with missing season stats\npa_data_final <- pa_data_with_both %>%\n  filter(\n    !is.na(batter_xwOBA) & !is.na(batter_xSLG) & !is.na(batter_xBA) &\n    !is.na(batter_wOBA) & !is.na(batter_BA) & !is.na(batter_SLG) &\n    !is.na(next_batter_xwOBA) &\n    !is.na(next_batter_xSLG) &\n    !is.na(next_batter_xBA) &\n    !is.na(next_batter_wOBA) &\n    !is.na(next_batter_BA) &\n    !is.na(next_batter_SLG)\n  )\n```\n:::\n\n\n\nWe need four more columns: `walk_rate` (BB%), `strikeout_rate` (K%), `xbh_rate` (XBH%), and `pitches_per_pa` (P/PA).\n\nWe will get `walk_rate` and `strikeout_rate` from Fangraphs Leaderbaords using BaseballR, and find `xbh_rate` and `pitches_per_pa` manually using our `pa_data` dataset.\n\nFirst, we can get `xbh_rate` and `pitches_per_pa` manually.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_extra_metrics <- pa_data %>%\n  group_by(game_year, batter) %>%\n  summarize(\n    xbh_rate = mean(is_extra_base_hit, na.rm = TRUE),  # extra-base hit rate\n    pitches_per_pa = mean(pitches_per_pa, na.rm = TRUE),    # pitches per plate appearance\n    .groups = \"drop\"\n  ) %>%\n  mutate(game_year = factor(game_year), batter = factor(batter))\n\n## Join to add current batter's extra metrics.\npa_data_final <- pa_data_final %>%\n  left_join(\n    pa_extra_metrics %>% \n      select(game_year, batter, xbh_rate, pitches_per_pa) %>%\n      rename(\n        batter_xbh_rate    = xbh_rate,\n        batter_pitches_per_pa = pitches_per_pa\n      ),\n    by = c(\"game_year\", \"batter\")\n  )\n\n## Join to add next batter's extra metrics.\npa_data_final <- pa_data_final %>%\n  mutate(\n    potential_next_batter = as.factor(potential_next_batter)\n  ) %>%\n  left_join(\n    pa_extra_metrics %>% \n      select(game_year, batter, xbh_rate, pitches_per_pa) %>%\n      rename(\n        next_batter_xbh_rate    = xbh_rate,\n        next_batter_pitches_per_pa = pitches_per_pa\n      ),\n    by = c(\"game_year\", \"potential_next_batter\" = \"batter\")\n  )\n```\n:::\n\n\n\nLet's also get our `walk_rate` and `strikeout_rate` using BaseballR.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Function to get FanGraphs BB% and K% for qualified batters \n## from start_season to end_season (inclusive)\n\nget_fg_batter_rates <- function(start_season, end_season) {\n  # Create a vector of seasons as characters\n  seasons <- as.character(seq(start_season, end_season))\n  \n  # Loop over each season and scrape the batter leaderboard\n  fg_data_list <- lapply(seasons, function(season) {\n    message(\"Scraping FanGraphs batter leaders for season: \", season)\n    df <- fg_batter_leaders(\n      startseason = season,\n      endseason = season,\n      qual = \"y\",      # Only qualified hitters\n      ind = \"1\",       # Split seasons individually\n      pageitems = \"10000\"\n    )\n    # Select only the columns we need.\n    df %>% \n      select(Season, xMLBAMID, BB_pct, K_pct)\n  })\n  \n  # Bind rows together from all seasons\n  fg_data_all <- bind_rows(fg_data_list)\n  \n  # Rename Season to game_year, convert to numeric, and convert xMLBAMID to factor\n  fg_data_all <- fg_data_all %>%\n    rename(game_year = Season) %>%\n    mutate(\n      game_year = as.numeric(game_year),\n      xMLBAMID = as.factor(xMLBAMID)\n    )\n  \n  return(fg_data_all)\n}\n\n## Get FanGraphs batter rates for all seasons 2015-2024\nfg_rates_all <- get_fg_batter_rates(2015, 2024) %>%\n  mutate(game_year = as.factor(game_year), xMLBAMID = as.factor(xMLBAMID))\n\n## Join the scraped FanGraphs rates into pa_data_final\n# Join current batter rates.\npa_data_final <- pa_data_final %>%\n  # Make batter and potential_next_batter into factors\n  mutate(\n    batter = as.factor(batter),\n    potential_next_batter = as.factor(potential_next_batter)\n  ) %>%\n  left_join(\n    fg_rates_all,\n    by = c(\"game_year\", \"batter\" = \"xMLBAMID\")\n  ) %>%\n  rename(\n    batter_bb_pct = BB_pct,\n    batter_k_pct  = K_pct\n  )\n\n# Join next batter rates.\npa_data_final <- pa_data_final %>%\n  left_join(\n    fg_rates_all,\n    by = c(\"game_year\", \"potential_next_batter\" = \"xMLBAMID\")\n  ) %>%\n  rename(\n    next_batter_bb_pct = BB_pct,\n    next_batter_k_pct  = K_pct\n  )\n```\n:::\n\n\n\nNext, we'll add columns for `xwOBA_diff`, `xBA_diff`, and `xSLG_diff`, which are the differences between the current batter's xwOBA, xBA, and xSLG and the plate appearance's xwOBA, xBA, and xSLG.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate differences\npa_data_final <- pa_data_final %>%\n  mutate(\n    xwOBA_diff = pa_xwOBA - batter_xwOBA,\n    xBA_diff   = pa_xBA - batter_xBA,\n    xSLG_diff  = pa_xSLG - batter_xSLG\n  )\n```\n:::\n\n\n\nThe last thing we will do is ensure that all of the variables we expect to act non-linearly are factors for our models. Also, we will relevel the `baserunner_state` variable to make \"Empty\" the reference level.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert certain variables to factors\npa_data_final$batter_handedness <- factor(pa_data_final$batter_handedness)\npa_data_final$potential_next_batter_handedness <- factor(pa_data_final$potential_next_batter_handedness)\npa_data_final$batter <- factor(pa_data_final$batter)\npa_data_final$pitcher <- factor(pa_data_final$pitcher)\npa_data_final$baserunner_state <- factor(pa_data_final$baserunner_state)\npa_data_final$inning <- factor(pa_data_final$inning)\npa_data_final$game_year <- factor(pa_data_final$game_year)\n\npa_data_final$baserunner_state <- relevel(pa_data_final$baserunner_state, ref = \"Empty\")\n```\n:::\n\n\n\nAfter initial modeling, we'd like to add the pitcher's handedness to our dataset. We can do this by matching the `game_pk` and `at_bat_number` of the plate appearance with the same values in the `statcast_all_years` dataframe. This will give us the pitcher's handedness for each plate appearance. We'd also like to create a new variable that indicates the handedness matchup between the current batter and pitcher, as well as the potential next batter and pitcher.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data_final$pitcher_handedness <- statcast_all_years$p_throws[match(paste(pa_data_final$game_pk, pa_data_final$at_bat_number),\n                                                                 paste(statcast_all_years$game_pk, statcast_all_years$at_bat_number))]\n\n# Define factor variables with clear reference categories\npa_data_final <- pa_data_final %>%\n  mutate(\n    handedness_matchup = factor(\n      paste0(batter_handedness, \"_vs_\", pitcher_handedness),\n      levels = c(\"R_vs_R\", \"L_vs_R\", \"R_vs_L\", \"L_vs_L\")\n    ),\n    next_handedness_matchup = factor(\n      paste0(potential_next_batter_handedness, \"_vs_\", pitcher_handedness),\n      levels = c(\"R_vs_R\", \"L_vs_R\", \"R_vs_L\", \"L_vs_L\")\n    )\n  )\n\npa_data_final <- pa_data_final %>%\n  mutate(\n    handedness_matchup = relevel(factor(handedness_matchup), ref = \"R_vs_R\"),\n    next_handedness_matchup = relevel(factor(next_handedness_matchup), ref = \"R_vs_R\")\n  )\n```\n:::\n\n\n\nHowever, when we incorporate `handedness_matchup` and `next_handedness_matchup` into the model, we get a warning that the fixed-effect model matrix is rank deficient. This is because So we know: `batter_handedness`, `potential_next_batter_handedness`, and `pitcher_handedness`, so `handedness_matchup` and `next_handedness_matchup` are not independent. The model can't tell what effects belong to which matchup cleanly without creating overlap. Instead, we can create two new variables: `current_matchup_advantage` and `next_matchup_advantage`. These will be `1` if the batter's handedness is opposite to the pitcher's handedness, and `0` otherwise. This way, we can still capture the matchup effects without creating a rank deficiency.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npa_data_final <- pa_data_final %>%\n  mutate(\n    current_matchup_advantage = if_else(batter_handedness != pitcher_handedness, 1, 0),\n    next_matchup_advantage    = if_else(potential_next_batter_handedness != pitcher_handedness, 1, 0)\n  )\n```\n:::\n\n\n\nThis is our final `pa_data_final` dataset that we can load in for model analysis.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}